/- This module defines a very simple parser combinator library and a JSON parser using it.
Its error messages are quite basic but it demonstrates a "real" application 
-/
module Main
import Prelude
import Option
import Elara.Prim
import List
import Tuple
import String
import Char
import Result qualified

-- Define a simple Parser Combinator type
-- Accepts a string input and returns a result which is either an error message or a tuple of the parsed value and the remaining string
type Parser a = | Parser (String -> Result.Result String (a, String))


-- Run the parser on the given input string
def runParser : Parser a -> String -> Result.Result String (a, String)
let runParser (Parser a) input = a input


-- Lift a pure value into the Parser context
-- i.e. create a parser that consumes no input and returns the given value
def pure : a -> Parser a
let pure a = Parser ( \s -> Result.Ok (a, s) )


-- Map a function over the result of a parser
def map : (a -> b) -> Parser a -> Parser b
let map f p = Parser ( \s -> let result = (runParser p s) in Result.map ( \(a, rest) -> (f a, rest) ) result )

-- Sequence two parsers, keeping the result of the second
#LeftAssociative #Fixity 4
def (*>) : Parser a -> Parser b -> Parser b
let p *> q =
  bind p (\_ -> q)

-- Sequence two parsers, keeping the result of the first
#LeftAssociative #Fixity 4
def (<*) : Parser a -> Parser b -> Parser a
let (<*) (Parser p1) (Parser p2) = Parser ( \s ->
                                match p1 s with
                                    Result.Err e -> Result.Err e
                                    Result.Ok (firstResult, firstLeftover) -> let parser2Result = p2 firstLeftover in match parser2Result with
                                                    Result.Err e -> Result.Err e
                                                    Result.Ok (_, secondLeftover) -> Result.Ok (firstResult, secondLeftover) )

-- Filter the result of a parser based on a predicate
-- If the predicate fails, the parser fails
def filter : (a -> Bool) -> Parser a -> Parser a
let filter pred p = Parser ( \s -> match runParser p s with
                                        Result.Err e -> Result.Err e
                                        Result.Ok (a, xs) -> if pred a then Result.Ok (a, xs) else Result.Err "Predicate failed" )



-- Bind a parser to a function that returns another parser
-- In Haskell, this is the (>>=) operator, but this name is currently taken by IO
def bind : Parser a -> (a -> Parser b) -> Parser b
let bind p f =
  Parser (\s ->
    match runParser p s with
      Result.Err e -> Result.Err e 
      Result.Ok (a, s1) -> runParser (f a) s1)


-- A parser that applies the given parser zero or more times, collecting the results in a list
def many : Parser a -> Parser (List a)
let many p = Parser ( \manyS -> 
    let go acc manyS_ = match (runParser p manyS_) with
                            Result.Err _ -> Result.Ok (reverse acc, manyS_)
                            Result.Ok (a, rest) -> go (a::acc) rest
        in go [] manyS )

-- A parser that applies the first parser one or more times, separated by the second parser
-- e.g. sepBy1 digit (char ',') parses a non-empty list of digits separated by commas
def sepBy1 : Parser a -> Parser sep -> Parser (List a)
let sepBy1 p sep = 
    p `bind` ( \first ->
        many (sep *> p) |> map ( \rest -> first::rest ) )

-- Like sepBy1, but allows zero occurrences of the first parser
def sepBy : Parser a -> Parser sep -> Parser (List a)
let sepBy p sep = sepBy1 p sep <|> pure []

-- Choice operator for parsers
-- Tries the first parser, if it fails, tries the second parser
def (<|>) : Parser a -> Parser a -> Parser a
let (<|>) (Parser p1) (Parser p2) = Parser ( \s -> match p1 s with
                                            Result.Err e -> match p2 s with
                                                                Result.Err e2 -> Result.Err (e ++ " <|> " ++ e2)
                                                                Result.Ok a2 -> Result.Ok a2
                                            Result.Ok a -> Result.Ok a )


-- Makes a parser lazy.
-- Specifically, it delays the construction of the parser until it is actually invoked
-- This is useful for defining recursive parsers.
def lazy : (() -> Parser a) -> Parser a
let lazy f = Parser ( \s -> runParser (f ()) s )


-- A parser that matches a single specific character, and returns it
-- If the next character in the input does not match, the parser fails
def char : Char -> Parser Char 
let char c = Parser ( \charS -> match stringToList charS with
                            [] -> Result.Err ("Expecting character " ++ toString c ++ " but got end of input")
                            (x::xs) -> if x == c then Result.Ok (c, stringFromList xs) 
                                else Result.Err ("Expecting character '" ++ toString c ++ "' but got " ++ toString x))

-- Wraps a parser to skip trailing whitespace
def lexeme : Parser a -> Parser a
let lexeme p = p <* many (char ' ')

-- A parser that matches a specific string
-- If the next characters in the input do not match, the parser fails
def string : String -> Parser String
let string str = 
    match stringToList str with
        []  -> pure ""
        (c::cs) -> char c *> (string (stringFromList cs)) |> map ( \s -> stringCons c s )

-- A parser that matches any single character
def any : Parser Char
let any = Parser ( \anyChar -> match stringToList anyChar with
                            [] -> Result.Err "Expecting any character but got end of input"
                            (x::xs) -> Result.Ok (x, stringFromList xs))


-- A parser that matches a single digit character and returns its integer value
def digit : Parser Int
let digit = map Char.toInt (filter Char.isDigit any)

-- A parser that matches an integer (one or more digits) and returns its integer value
def int : Parser Int
let int = many digit |> filter (\x -> x != []) |> map digitsToInt

-- Helper function to convert a list of digit integers to a single integer value
-- Eg [1,2,3] -> 123
def digitsToInt : List Int -> Int
let digitsToInt ds =
    let digitsToIntHelper ds acc =
            match ds with
                Nil -> acc
                Cons digitValue ds_ ->
                              digitsToIntHelper ds_ (acc * 10 + digitValue)
    digitsToIntHelper ds 0


/- Now we can define our JSON parser using the combinators defined above -/

type Json = JsonNull
     | JsonInt Int
     | JsonString String
     | JsonArray (List Json) 
     | JsonObject (List (Tuple2 String Json))

-- Define a parser for JSON null
def jsonNull : Parser Json
let jsonNull = string "null" |> map ( \_ -> JsonNull )

-- Define a parser for JSON integers
def jsonInt : Parser Json
let jsonInt = int |> map JsonInt

-- Define a parser for JSON strings
def jsonString : Parser Json
let jsonString = 
    -- Parse the body of the string (characters until the next ")
    let stringBody = many (filter ( \c -> c != '"') any ) |> map stringFromList
    in char '"' *> stringBody <* char '"' |> map JsonString

-- Define a parser for JSON arrays, which are lists of JSON values
-- We use the lazy combinator in here so that we can reference the json parser recursively
-- without causing an infinite loop during parser construction
def jsonArray : Parser Json
let jsonArray = 
    let jsonElements = sepBy (lazy (\_ -> json)) (lexeme (char ','))
    in lexeme (char '[') *> (map JsonArray jsonElements) <* lexeme (char ']')

-- Define a parser for JSON objects, which are lists of key-value pairs
-- We use the lazy combinator here as well for the same reason as in jsonArray
def jsonObject : Parser Json
let jsonObject = 
    -- A parser for a single key: value pair in a JSON object
    let jsonPair = 
            jsonString `bind` ( \key -> lexeme (char ':') *> (lazy (\_ -> json)) |> map (Tuple2 key) )
    -- A parser for multiple key: value pairs separated by commas
    let jsonPairs =  sepBy jsonPair (lexeme (char ','))
    -- Combine to form the full object parser
    in lexeme (char '{') *> (jsonPairs |> map JsonObject) <* lexeme (char '}')


-- Finally, define the top-level JSON parser that can parse any JSON value
-- It tries each of the specific JSON parsers in turn
-- and returns the result of the first one that succeeds
def json : Parser Json
let json = jsonNull <|> jsonInt <|> jsonString <|> jsonArray <|> jsonObject


let main = 
    match runParser json "[{\"a\": 1}, 12345, null, ]" with
            Result.Err e -> println ("Failed to parse: " ++ e)
            Result.Ok (result, _) -> println (toString result)