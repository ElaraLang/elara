<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE OrPatterns #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE RecordWildCards #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE StrictData #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE TemplateHaskell #-}</span><span>
</span><span id="line-5"></span><span>
</span><span id="line-6"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html"><span class="hs-identifier">Elara.Lexer.Utils</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-7"></span><span>
</span><span id="line-8"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Codec.Binary.UTF8.String</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">encodeChar</span></span><span class="hs-special">)</span><span>
</span><span id="line-9"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Char</span></span><span>
</span><span id="line-10"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Kind</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Type</span></span><span class="hs-special">)</span><span>
</span><span id="line-11"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List.NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">span</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(&lt;|)</span></span><span class="hs-special">)</span><span>
</span><span id="line-12"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Text</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">T</span></span><span>
</span><span id="line-13"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Name.html"><span class="hs-identifier">Elara.AST.Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#ModuleName"><span class="hs-identifier">ModuleName</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-14"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Region.html"><span class="hs-identifier">Elara.AST.Region</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier">Located</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier">Located</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealPosition"><span class="hs-identifier">RealPosition</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealSourceRegion"><span class="hs-identifier">RealSourceRegion</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#SourceRegion"><span class="hs-identifier">SourceRegion</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#column"><span class="hs-identifier">column</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#line"><span class="hs-identifier">line</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#mkSourceRegionIn"><span class="hs-identifier">mkSourceRegionIn</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#positionToDiagnosePosition"><span class="hs-identifier">positionToDiagnosePosition</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-15"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Error.html"><span class="hs-identifier">Elara.Error</span></a></span><span>
</span><span id="line-16"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Error.Codes.html"><span class="hs-identifier">Elara.Error.Codes</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Codes</span></span><span>
</span><span id="line-17"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html"><span class="hs-identifier">Elara.Lexer.Token</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier">Lexeme</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokPosition"><span class="hs-identifier">TokPosition</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Token"><span class="hs-identifier">Token</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#tokenEndsExpr"><span class="hs-identifier">tokenEndsExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-18"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Error.Diagnose</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Marker</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Note</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Report</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Err</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-19"></span><span>
</span><span id="line-20"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Eff</span></span><span class="hs-special">)</span><span>
</span><span id="line-21"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful.Error.Static</span></span><span>
</span><span id="line-22"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Effectful.State.Extra.html"><span class="hs-identifier">Effectful.State.Extra</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier">use'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful.State.Static.Local</span></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Logging.html"><span class="hs-identifier">Elara.Logging</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier">StructuredDebug</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-25"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Prelude.html"><span class="hs-identifier">Prelude</span></a></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">span</span></span><span class="hs-special">)</span><span>
</span><span id="line-26"></span><span>
</span><span id="line-27"></span><span class="hs-keyword">data</span><span> </span><span id="AlexInput"><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-var">AlexInput</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="AlexInput"><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-var">AlexInput</span></a></span></span><span>
</span><span id="line-28"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="_filePath"><span class="annot"><span class="annottext">AlexInput -&gt; FilePath
</span><a href="Elara.Lexer.Utils.html#_filePath"><span class="hs-identifier hs-var hs-var">_filePath</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span>
</span><span id="line-29"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_prev"><span class="annot"><span class="annottext">AlexInput -&gt; Char
</span><a href="Elara.Lexer.Utils.html#_prev"><span class="hs-identifier hs-var hs-var">_prev</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span>
</span><span id="line-30"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_bytes"><span class="annot"><span class="annottext">AlexInput -&gt; [Word8]
</span><a href="Elara.Lexer.Utils.html#_bytes"><span class="hs-identifier hs-var hs-var">_bytes</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span class="hs-special">]</span><span>
</span><span id="line-31"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_rest"><span class="annot"><span class="annottext">AlexInput -&gt; Text
</span><a href="Elara.Lexer.Utils.html#_rest"><span class="hs-identifier hs-var hs-var">_rest</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span>
</span><span id="line-32"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_position"><span class="annot"><span class="annottext">AlexInput -&gt; RealPosition
</span><a href="Elara.Lexer.Utils.html#_position"><span class="hs-identifier hs-var hs-var">_position</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealPosition"><span class="hs-identifier hs-type">RealPosition</span></a></span><span>
</span><span id="line-33"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-34"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680017528"><span id="local-6989586621680017542"><span id="local-6989586621680017546"><span class="annot"><span class="annottext">Int -&gt; AlexInput -&gt; ShowS
[AlexInput] -&gt; ShowS
AlexInput -&gt; FilePath
(Int -&gt; AlexInput -&gt; ShowS)
-&gt; (AlexInput -&gt; FilePath)
-&gt; ([AlexInput] -&gt; ShowS)
-&gt; Show AlexInput
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; AlexInput -&gt; ShowS
showsPrec :: Int -&gt; AlexInput -&gt; ShowS
$cshow :: AlexInput -&gt; FilePath
show :: AlexInput -&gt; FilePath
$cshowList :: [AlexInput] -&gt; ShowS
showList :: [AlexInput] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-35"></span><span>
</span><span id="line-36"></span><span class="hs-keyword">data</span><span> </span><span id="IndentInfo"><span class="annot"><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-var">IndentInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="IndentInfo"><span class="annot"><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-var">IndentInfo</span></a></span></span><span>
</span><span id="line-37"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="_indent"><span class="annot"><span class="annottext">IndentInfo -&gt; Int
</span><a href="Elara.Lexer.Utils.html#_indent"><span class="hs-identifier hs-var hs-var">_indent</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-38"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_indentPos"><span class="annot"><span class="annottext">IndentInfo -&gt; RealPosition
</span><a href="Elara.Lexer.Utils.html#_indentPos"><span class="hs-identifier hs-var hs-var">_indentPos</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealPosition"><span class="hs-identifier hs-type">RealPosition</span></a></span><span>
</span><span id="line-39"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_openedAtDepth"><span class="annot"><span class="annottext">IndentInfo -&gt; Int
</span><a href="Elara.Lexer.Utils.html#_openedAtDepth"><span class="hs-identifier hs-var hs-var">_openedAtDepth</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-40"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ the delimDepth when this indent was opened</span></span><span>
</span><span id="line-41"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-42"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680017557"><span id="local-6989586621680017564"><span id="local-6989586621680017568"><span class="annot"><span class="annottext">Int -&gt; IndentInfo -&gt; ShowS
[IndentInfo] -&gt; ShowS
IndentInfo -&gt; FilePath
(Int -&gt; IndentInfo -&gt; ShowS)
-&gt; (IndentInfo -&gt; FilePath)
-&gt; ([IndentInfo] -&gt; ShowS)
-&gt; Show IndentInfo
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; IndentInfo -&gt; ShowS
showsPrec :: Int -&gt; IndentInfo -&gt; ShowS
$cshow :: IndentInfo -&gt; FilePath
show :: IndentInfo -&gt; FilePath
$cshowList :: [IndentInfo] -&gt; ShowS
showList :: [IndentInfo] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-43"></span><span>
</span><span id="line-44"></span><span class="hs-keyword">data</span><span> </span><span id="ParseState"><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-var">ParseState</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ParseState"><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-var">ParseState</span></a></span></span><span>
</span><span id="line-45"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="_input"><span class="annot"><span class="annottext">ParseState -&gt; AlexInput
</span><a href="Elara.Lexer.Utils.html#_input"><span class="hs-identifier hs-var hs-var">_input</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-type">AlexInput</span></a></span><span>
</span><span id="line-46"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_lexSC"><span class="annot"><span class="annottext">ParseState -&gt; Int
</span><a href="Elara.Lexer.Utils.html#_lexSC"><span class="hs-identifier hs-var hs-var">_lexSC</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-47"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ lexer start code</span></span><span>
</span><span id="line-48"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_stringBuf"><span class="annot"><span class="annottext">ParseState -&gt; Text
</span><a href="Elara.Lexer.Utils.html#_stringBuf"><span class="hs-identifier hs-var hs-var">_stringBuf</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span>
</span><span id="line-49"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ temporary storage for strings</span></span><span>
</span><span id="line-50"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_pendingTokens"><span class="annot"><span class="annottext">ParseState -&gt; [Lexeme]
</span><a href="Elara.Lexer.Utils.html#_pendingTokens"><span class="hs-identifier hs-var hs-var">_pendingTokens</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-51"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ right now used when Parser consumes the lookahead and decided to put it back</span></span><span>
</span><span id="line-52"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_indentStack"><span class="annot"><span class="annottext">ParseState -&gt; NonEmpty IndentInfo
</span><a href="Elara.Lexer.Utils.html#_indentStack"><span class="hs-identifier hs-var hs-var">_indentStack</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NonEmpty</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-type">IndentInfo</span></a></span><span>
</span><span id="line-53"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ stack of indentation levels</span></span><span>
</span><span id="line-54"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_pendingPosition"><span class="annot"><span class="annottext">ParseState -&gt; RealPosition
</span><a href="Elara.Lexer.Utils.html#_pendingPosition"><span class="hs-identifier hs-var hs-var">_pendingPosition</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokPosition"><span class="hs-identifier hs-type">TokPosition</span></a></span><span>
</span><span id="line-55"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ needed when parsing strings, chars, multi-line strings</span></span><span>
</span><span id="line-56"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_prevEndsExpr"><span class="annot"><span class="annottext">ParseState -&gt; Bool
</span><a href="Elara.Lexer.Utils.html#_prevEndsExpr"><span class="hs-identifier hs-var hs-var">_prevEndsExpr</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-57"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ did the previous token end an expression? (used for offside rule</span></span><span>
</span><span id="line-58"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_delimDepth"><span class="annot"><span class="annottext">ParseState -&gt; Int
</span><a href="Elara.Lexer.Utils.html#_delimDepth"><span class="hs-identifier hs-var hs-var">_delimDepth</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-59"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ current depth of open delimiters ((), [], {</span></span><span>
</span><span id="line-60"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-61"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680017580"><span id="local-6989586621680017595"><span id="local-6989586621680017599"><span class="annot"><span class="annottext">Int -&gt; ParseState -&gt; ShowS
[ParseState] -&gt; ShowS
ParseState -&gt; FilePath
(Int -&gt; ParseState -&gt; ShowS)
-&gt; (ParseState -&gt; FilePath)
-&gt; ([ParseState] -&gt; ShowS)
-&gt; Show ParseState
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; ParseState -&gt; ShowS
showsPrec :: Int -&gt; ParseState -&gt; ShowS
$cshow :: ParseState -&gt; FilePath
show :: ParseState -&gt; FilePath
$cshowList :: [ParseState] -&gt; ShowS
showList :: [ParseState] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-62"></span><span>
</span><span id="line-63"></span><span id="bytes"><span id="filePath"><span id="position"><span id="prev"><span id="rest"><span class="hs-identifier">makeLenses</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">AlexInput</span></span></span></span></span></span><span>
</span><span id="line-64"></span><span id="indent"><span id="indentPos"><span id="openedAtDepth"><span class="hs-identifier">makeLenses</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">IndentInfo</span></span></span></span><span>
</span><span id="line-65"></span><span id="delimDepth"><span id="indentStack"><span id="input"><span id="lexSC"><span id="pendingPosition"><span id="pendingTokens"><span id="prevEndsExpr"><span id="stringBuf"><span class="hs-identifier">makeLenses</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">ParseState</span></span></span></span></span></span></span></span></span><span>
</span><span id="line-66"></span><span>
</span><span id="line-67"></span><span class="hs-keyword">type</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-68"></span><span class="hs-keyword">type</span><span> </span><span id="LexMonad"><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-var">LexMonad</span></a></span></span><span> </span><span id="local-6989586621680017799"><span class="annot"><a href="#local-6989586621680017799"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="hs-special">'</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">State</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-type">ParseState</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Error</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexerError"><span class="hs-identifier hs-type">LexerError</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier hs-type">StructuredDebug</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="#local-6989586621680017799"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-69"></span><span>
</span><span id="line-70"></span><span class="annot"><a href="Elara.Lexer.Utils.html#setPrevEndsExpr"><span class="hs-identifier hs-type">setPrevEndsExpr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-71"></span><span id="setPrevEndsExpr"><span class="annot"><span class="annottext">setPrevEndsExpr :: Bool -&gt; LexMonad ()
</span><a href="Elara.Lexer.Utils.html#setPrevEndsExpr"><span class="hs-identifier hs-var hs-var">setPrevEndsExpr</span></a></span></span><span> </span><span id="local-6989586621680017805"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621680017805"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(ParseState -&gt; ParseState) -&gt; LexMonad ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
(s -&gt; s) -&gt; Eff es ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680017807"><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680017807"><span class="hs-identifier hs-var">st</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680017807"><span class="hs-identifier hs-var">st</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.Lexer.Utils.html#_prevEndsExpr"><span class="hs-identifier hs-var">_prevEndsExpr</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680017805"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-72"></span><span>
</span><span id="line-73"></span><span class="annot"><a href="Elara.Lexer.Utils.html#getPrevEndsExpr"><span class="hs-identifier hs-type">getPrevEndsExpr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-74"></span><span id="getPrevEndsExpr"><span class="annot"><span class="annottext">getPrevEndsExpr :: LexMonad Bool
</span><a href="Elara.Lexer.Utils.html#getPrevEndsExpr"><span class="hs-identifier hs-var hs-var">getPrevEndsExpr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(ParseState -&gt; Bool) -&gt; LexMonad Bool
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]) a.
(HasCallStack, State s :&gt; es) =&gt;
(s -&gt; a) -&gt; Eff es a
</span><span class="hs-identifier hs-var">gets</span></span><span> </span><span class="annot"><span class="annottext">ParseState -&gt; Bool
</span><a href="Elara.Lexer.Utils.html#_prevEndsExpr"><span class="hs-identifier hs-var">_prevEndsExpr</span></a></span><span>
</span><span id="line-75"></span><span>
</span><span id="line-76"></span><span class="annot"><a href="Elara.Lexer.Utils.html#mkIndentInfo"><span class="hs-identifier hs-type">mkIndentInfo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-type">IndentInfo</span></a></span><span>
</span><span id="line-77"></span><span id="mkIndentInfo"><span class="annot"><span class="annottext">mkIndentInfo :: Int -&gt; LexMonad IndentInfo
</span><a href="Elara.Lexer.Utils.html#mkIndentInfo"><span class="hs-identifier hs-var hs-var">mkIndentInfo</span></a></span></span><span> </span><span id="local-6989586621680017830"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680017830"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-78"></span><span>    </span><span id="local-6989586621680017831"><span class="annot"><a href="#local-6989586621680017831"><span class="hs-identifier hs-var">pos</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState RealPosition
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] RealPosition
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput RealPosition -&gt; Lens' ParseState RealPosition
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput RealPosition
</span><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-var">position</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-79"></span><span>    </span><span id="local-6989586621680017833"><span class="annot"><a href="#local-6989586621680017833"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-type">use'</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#delimDepth"><span class="hs-identifier hs-type">delimDepth</span></a></span><span>
</span><span id="line-80"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-type">IndentInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680017830"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680017831"><span class="hs-identifier hs-type">pos</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680017833"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-81"></span><span>
</span><span id="line-82"></span><span class="hs-keyword">data</span><span> </span><span id="LexerError"><span class="annot"><a href="Elara.Lexer.Utils.html#LexerError"><span class="hs-identifier hs-var">LexerError</span></a></span></span><span>
</span><span id="line-83"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-comment">-- | When an element is indented more than expected</span></span><span>
</span><span id="line-84"></span><span>      </span><span id="TooMuchIndentation"><span class="annot"><a href="Elara.Lexer.Utils.html#TooMuchIndentation"><span class="hs-identifier hs-var">TooMuchIndentation</span></a></span></span><span>
</span><span id="line-85"></span><span>        </span><span class="annot"><span class="hs-comment">-- | The expected indentation</span></span><span>
</span><span id="line-86"></span><span>        </span><span class="annot"><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-type">IndentInfo</span></a></span><span>
</span><span id="line-87"></span><span>        </span><span class="annot"><span class="hs-comment">-- | The potential further indentation</span></span><span>
</span><span id="line-88"></span><span>        </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-type">IndentInfo</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-89"></span><span>        </span><span class="annot"><span class="hs-comment">-- | The actual indentation</span></span><span>
</span><span id="line-90"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-91"></span><span>        </span><span class="annot"><span class="hs-comment">-- | The current state of the lexer</span></span><span>
</span><span id="line-92"></span><span>        </span><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-type">ParseState</span></a></span><span>
</span><span id="line-93"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="UnterminatedStringLiteral"><span class="annot"><a href="Elara.Lexer.Utils.html#UnterminatedStringLiteral"><span class="hs-identifier hs-var">UnterminatedStringLiteral</span></a></span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-type">ParseState</span></a></span><span>
</span><span id="line-94"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680017837"><span id="local-6989586621680017847"><span id="local-6989586621680017851"><span class="annot"><span class="annottext">Int -&gt; LexerError -&gt; ShowS
[LexerError] -&gt; ShowS
LexerError -&gt; FilePath
(Int -&gt; LexerError -&gt; ShowS)
-&gt; (LexerError -&gt; FilePath)
-&gt; ([LexerError] -&gt; ShowS)
-&gt; Show LexerError
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; LexerError -&gt; ShowS
showsPrec :: Int -&gt; LexerError -&gt; ShowS
$cshow :: LexerError -&gt; FilePath
show :: LexerError -&gt; FilePath
$cshowList :: [LexerError] -&gt; ShowS
showList :: [LexerError] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-95"></span><span>
</span><span id="line-96"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621680017854"><span id="local-6989586621680017858"><span class="annot"><a href="Elara.Error.html#ReportableError"><span class="hs-identifier hs-type">ReportableError</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexerError"><span class="hs-identifier hs-type">LexerError</span></a></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-97"></span><span>    </span><span id="local-6989586621680017927"><span class="annot"><span class="annottext">report :: forall (r :: [(* -&gt; *) -&gt; * -&gt; *]).
(DiagnosticWriter (Doc AnsiStyle) :&gt; r) =&gt;
LexerError -&gt; Eff r ()
</span><a href="#local-6989586621680017927"><span class="hs-identifier hs-var hs-var hs-var">report</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#TooMuchIndentation"><span class="hs-identifier hs-type">TooMuchIndentation</span></a></span><span> </span><span id="local-6989586621680017929"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680017929"><span class="hs-identifier hs-var">expected</span></a></span></span><span> </span><span id="local-6989586621680017930"><span class="annot"><span class="annottext">Maybe IndentInfo
</span><a href="#local-6989586621680017930"><span class="hs-identifier hs-var">further</span></a></span></span><span> </span><span id="local-6989586621680017931"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680017931"><span class="hs-identifier hs-var">actual</span></a></span></span><span> </span><span id="local-6989586621680017932"><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680017932"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-98"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680017933"><span class="annot"><span class="annottext">fp :: FilePath
</span><a href="#local-6989586621680017933"><span class="hs-identifier hs-var hs-var hs-var">fp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Optic' A_Lens NoIx ParseState FilePath -&gt; ParseState -&gt; FilePath
forall k (is :: IxList) s a.
Is k A_Getter =&gt;
Optic' k is s a -&gt; s -&gt; a
</span><span class="hs-identifier hs-var">view</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput FilePath
-&gt; Optic' A_Lens NoIx ParseState FilePath
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput FilePath
</span><a href="Elara.Lexer.Utils.html#filePath"><span class="hs-identifier hs-var">filePath</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680017932"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-99"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680017935"><span class="annot"><span class="annottext">pos :: RealPosition
</span><a href="#local-6989586621680017935"><span class="hs-identifier hs-var hs-var hs-var">pos</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState RealPosition -&gt; ParseState -&gt; RealPosition
forall k (is :: IxList) s a.
Is k A_Getter =&gt;
Optic' k is s a -&gt; s -&gt; a
</span><span class="hs-identifier hs-var">view</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput RealPosition -&gt; Lens' ParseState RealPosition
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput RealPosition
</span><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-var">position</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680017932"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-100"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680017936"><span class="annot"><span class="annottext">msg :: Doc AnsiStyle
</span><a href="#local-6989586621680017936"><span class="hs-identifier hs-var hs-var hs-var">msg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;Unexpected change in indentation. Expected &quot;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Doc AnsiStyle
forall b a. (Show a, IsString b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680017929"><span class="hs-identifier hs-var">expected</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo Int -&gt; Int
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo Int
</span><a href="Elara.Lexer.Utils.html#indent"><span class="hs-identifier hs-var">indent</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot; spaces, but got &quot;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Doc AnsiStyle
forall b a. (Show a, IsString b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680017931"><span class="hs-identifier hs-var">actual</span></a></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot; spaces.&quot;</span></span><span>
</span><span id="line-101"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680017939"><span class="annot"><span class="annottext">hint :: Doc AnsiStyle
</span><a href="#local-6989586621680017939"><span class="hs-identifier hs-var hs-var hs-var">hint</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe IndentInfo
</span><a href="#local-6989586621680017930"><span class="hs-identifier hs-var">further</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-102"></span><span>                </span><span class="annot"><span class="annottext">Maybe IndentInfo
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;Try removing the extra indentation.&quot;</span></span><span>
</span><span id="line-103"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621680017940"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680017940"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;Try removing the extra indentation or indenting the line by &quot;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Doc AnsiStyle
forall b a. (Show a, IsString b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680017940"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo Int -&gt; Int
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo Int
</span><a href="Elara.Lexer.Utils.html#indent"><span class="hs-identifier hs-var">indent</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680017931"><span class="hs-identifier hs-var">actual</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot; space(s).&quot;</span></span><span>
</span><span id="line-104"></span><span>
</span><span id="line-105"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680017941"><span class="annot"><span class="annottext">baseHints :: [(Position, Marker (Doc AnsiStyle))]
</span><a href="#local-6989586621680017941"><span class="hs-identifier hs-var hs-var hs-var">baseHints</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-106"></span><span>                </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; RealPosition -&gt; Position
</span><a href="Elara.AST.Region.html#positionToDiagnosePosition"><span class="hs-identifier hs-var">positionToDiagnosePosition</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621680017933"><span class="hs-identifier hs-var">fp</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680017935"><span class="hs-identifier hs-var">pos</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Marker (Doc AnsiStyle)
forall msg. msg -&gt; Marker msg
</span><span class="hs-identifier hs-var">This</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;this line is indented incorrectly&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-107"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; RealPosition -&gt; Position
</span><a href="Elara.AST.Region.html#positionToDiagnosePosition"><span class="hs-identifier hs-var">positionToDiagnosePosition</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621680017933"><span class="hs-identifier hs-var">fp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680017929"><span class="hs-identifier hs-var">expected</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo RealPosition -&gt; RealPosition
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo RealPosition
</span><a href="Elara.Lexer.Utils.html#indentPos"><span class="hs-identifier hs-var">indentPos</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Marker (Doc AnsiStyle)
forall msg. msg -&gt; Marker msg
</span><span class="hs-identifier hs-var">Maybe</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;If the decrease in indentation is intentional, the problematic line should line up with this line.&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-108"></span><span>                </span><span class="hs-special">]</span><span>
</span><span id="line-109"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680017944"><span class="annot"><span class="annottext">furtherHints :: [(Position, Marker (Doc AnsiStyle))]
</span><a href="#local-6989586621680017944"><span class="hs-identifier hs-var hs-var">furtherHints</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe IndentInfo
</span><a href="#local-6989586621680017930"><span class="hs-identifier hs-var">further</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-110"></span><span>                </span><span class="annot"><span class="annottext">Maybe IndentInfo
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[(Position, Marker (Doc AnsiStyle))]
</span><a href="#local-6989586621680017941"><span class="hs-identifier hs-var">baseHints</span></a></span><span>
</span><span id="line-111"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621680017945"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680017945"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; RealPosition -&gt; Position
</span><a href="Elara.AST.Region.html#positionToDiagnosePosition"><span class="hs-identifier hs-var">positionToDiagnosePosition</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621680017933"><span class="hs-identifier hs-var">fp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680017945"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo RealPosition -&gt; RealPosition
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo RealPosition
</span><a href="Elara.Lexer.Utils.html#indentPos"><span class="hs-identifier hs-var">indentPos</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Marker (Doc AnsiStyle)
forall msg. msg -&gt; Marker msg
</span><span class="hs-identifier hs-var">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;an offside rule begins here (column &quot;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Doc AnsiStyle
forall b a. (Show a, IsString b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680017945"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo Int -&gt; Int
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo Int
</span><a href="Elara.Lexer.Utils.html#indent"><span class="hs-identifier hs-var">indent</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;). If you think the problematic line is \&quot;related\&quot; to this line, make sure they line up.&quot;</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Position, Marker (Doc AnsiStyle))
-&gt; [(Position, Marker (Doc AnsiStyle))]
-&gt; [(Position, Marker (Doc AnsiStyle))]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[(Position, Marker (Doc AnsiStyle))]
</span><a href="#local-6989586621680017941"><span class="hs-identifier hs-var">baseHints</span></a></span><span>
</span><span id="line-112"></span><span>        </span><span class="annot"><span class="annottext">Report (Doc AnsiStyle) -&gt; Eff r ()
forall t (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, DiagnosticWriter t :&gt; es) =&gt;
Report t -&gt; Eff es ()
</span><a href="Elara.Error.Effect.html#writeReport"><span class="hs-identifier hs-var">writeReport</span></a></span><span> </span><span class="annot"><span class="annottext">(Report (Doc AnsiStyle) -&gt; Eff r ())
-&gt; Report (Doc AnsiStyle) -&gt; Eff r ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-113"></span><span>            </span><span class="annot"><span class="annottext">Maybe (Doc AnsiStyle)
-&gt; Doc AnsiStyle
-&gt; [(Position, Marker (Doc AnsiStyle))]
-&gt; [Note (Doc AnsiStyle)]
-&gt; Report (Doc AnsiStyle)
forall msg.
Maybe msg
-&gt; msg -&gt; [(Position, Marker msg)] -&gt; [Note msg] -&gt; Report msg
</span><span class="hs-identifier hs-var">Err</span></span><span>
</span><span id="line-114"></span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Maybe (Doc AnsiStyle)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
ErrorCode
</span><a href="Elara.Error.Codes.html#tooMuchIndentation"><span class="hs-identifier hs-var">Codes.tooMuchIndentation</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-115"></span><span>                </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><a href="#local-6989586621680017936"><span class="hs-identifier hs-var">msg</span></a></span><span>
</span><span id="line-116"></span><span>                </span><span class="annot"><span class="annottext">[(Position, Marker (Doc AnsiStyle))]
</span><a href="#local-6989586621680017944"><span class="hs-identifier hs-var">furtherHints</span></a></span><span>
</span><span id="line-117"></span><span>                </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Note (Doc AnsiStyle)
forall msg. msg -&gt; Note msg
</span><span class="hs-identifier hs-var">Note</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;When using lightweight syntax, the level of indentation is very important. Currently, I can't tell what expression this line is supposed to be a part of as it doesn't line up with anything, and didn't appear in a place where indentation can begin.&quot;</span></span><span>
</span><span id="line-118"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Note (Doc AnsiStyle)
forall msg. msg -&gt; Note msg
</span><span class="hs-identifier hs-var">Hint</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><a href="#local-6989586621680017939"><span class="hs-identifier hs-var">hint</span></a></span><span>
</span><span id="line-119"></span><span>                </span><span class="hs-special">]</span><span>
</span><span id="line-120"></span><span>    </span><span class="annot"><a href="Elara.Error.html#report"><span class="hs-identifier hs-var">report</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#UnterminatedStringLiteral"><span class="hs-identifier hs-type">UnterminatedStringLiteral</span></a></span><span> </span><span id="local-6989586621680017950"><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680017950"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-121"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680017951"><span class="annot"><span class="annottext">fp :: FilePath
</span><a href="#local-6989586621680017951"><span class="hs-identifier hs-var hs-var hs-var">fp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Optic' A_Lens NoIx ParseState FilePath -&gt; ParseState -&gt; FilePath
forall k (is :: IxList) s a.
Is k A_Getter =&gt;
Optic' k is s a -&gt; s -&gt; a
</span><span class="hs-identifier hs-var">view</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput FilePath
-&gt; Optic' A_Lens NoIx ParseState FilePath
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput FilePath
</span><a href="Elara.Lexer.Utils.html#filePath"><span class="hs-identifier hs-var">filePath</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680017950"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-122"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680017952"><span class="annot"><span class="annottext">pos :: RealPosition
</span><a href="#local-6989586621680017952"><span class="hs-identifier hs-var hs-var hs-var">pos</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState RealPosition -&gt; ParseState -&gt; RealPosition
forall k (is :: IxList) s a.
Is k A_Getter =&gt;
Optic' k is s a -&gt; s -&gt; a
</span><span class="hs-identifier hs-var">view</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput RealPosition -&gt; Lens' ParseState RealPosition
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput RealPosition
</span><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-var">position</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680017950"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-123"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680017954"><span class="annot"><span class="annottext">msg :: Doc AnsiStyle
</span><a href="#local-6989586621680017954"><span class="hs-identifier hs-var hs-var hs-var">msg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;Unterminated string literal.&quot;</span></span><span>
</span><span id="line-124"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680017956"><span class="annot"><span class="annottext">hint :: Doc AnsiStyle
</span><a href="#local-6989586621680017956"><span class="hs-identifier hs-var hs-var">hint</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;Make sure that the string literal is terminated with a double quote (\&quot;).&quot;</span></span><span>
</span><span id="line-125"></span><span>        </span><span class="annot"><span class="annottext">Report (Doc AnsiStyle) -&gt; Eff r ()
forall t (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, DiagnosticWriter t :&gt; es) =&gt;
Report t -&gt; Eff es ()
</span><a href="Elara.Error.Effect.html#writeReport"><span class="hs-identifier hs-var">writeReport</span></a></span><span> </span><span class="annot"><span class="annottext">(Report (Doc AnsiStyle) -&gt; Eff r ())
-&gt; Report (Doc AnsiStyle) -&gt; Eff r ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-126"></span><span>            </span><span class="annot"><span class="annottext">Maybe (Doc AnsiStyle)
-&gt; Doc AnsiStyle
-&gt; [(Position, Marker (Doc AnsiStyle))]
-&gt; [Note (Doc AnsiStyle)]
-&gt; Report (Doc AnsiStyle)
forall msg.
Maybe msg
-&gt; msg -&gt; [(Position, Marker msg)] -&gt; [Note msg] -&gt; Report msg
</span><span class="hs-identifier hs-var">Err</span></span><span>
</span><span id="line-127"></span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Maybe (Doc AnsiStyle)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
ErrorCode
</span><a href="Elara.Error.Codes.html#unterminatedStringLiteral"><span class="hs-identifier hs-var">Codes.unterminatedStringLiteral</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-128"></span><span>                </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><a href="#local-6989586621680017954"><span class="hs-identifier hs-var">msg</span></a></span><span>
</span><span id="line-129"></span><span>                </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; RealPosition -&gt; Position
</span><a href="Elara.AST.Region.html#positionToDiagnosePosition"><span class="hs-identifier hs-var">positionToDiagnosePosition</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621680017951"><span class="hs-identifier hs-var">fp</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680017952"><span class="hs-identifier hs-var">pos</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Marker (Doc AnsiStyle)
forall msg. msg -&gt; Marker msg
</span><span class="hs-identifier hs-var">This</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;this string literal is unterminated&quot;</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-130"></span><span>                </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Note (Doc AnsiStyle)
forall msg. msg -&gt; Note msg
</span><span class="hs-identifier hs-var">Note</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;String literals are delimited by double quotes (\&quot;).&quot;</span></span><span>
</span><span id="line-131"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Note (Doc AnsiStyle)
forall msg. msg -&gt; Note msg
</span><span class="hs-identifier hs-var">Hint</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><a href="#local-6989586621680017956"><span class="hs-identifier hs-var">hint</span></a></span><span>
</span><span id="line-132"></span><span>                </span><span class="hs-special">]</span><span>
</span><span id="line-133"></span><span>
</span><span id="line-134"></span><span class="annot"><a href="Elara.Lexer.Utils.html#initialState"><span class="hs-identifier hs-type">initialState</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-type">ParseState</span></a></span><span>
</span><span id="line-135"></span><span id="initialState"><span class="annot"><span class="annottext">initialState :: FilePath -&gt; Text -&gt; ParseState
</span><a href="Elara.Lexer.Utils.html#initialState"><span class="hs-identifier hs-var hs-var">initialState</span></a></span></span><span> </span><span id="local-6989586621680017961"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621680017961"><span class="hs-identifier hs-var">fp</span></a></span></span><span> </span><span id="local-6989586621680017962"><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680017962"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-136"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-type">ParseState</span></a></span><span>
</span><span id="line-137"></span><span>        </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">_input :: AlexInput
</span><a href="Elara.Lexer.Utils.html#_input"><span class="hs-identifier hs-var">_input</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-138"></span><span>            </span><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-type">AlexInput</span></a></span><span>
</span><span id="line-139"></span><span>                </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">_filePath :: FilePath
</span><a href="Elara.Lexer.Utils.html#_filePath"><span class="hs-identifier hs-var">_filePath</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621680017961"><span class="hs-identifier hs-var">fp</span></a></span><span>
</span><span id="line-140"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_prev :: Char
</span><a href="Elara.Lexer.Utils.html#_prev"><span class="hs-identifier hs-var">_prev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'\n'</span></span><span>
</span><span id="line-141"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_bytes :: [Word8]
</span><a href="Elara.Lexer.Utils.html#_bytes"><span class="hs-identifier hs-var">_bytes</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-142"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_rest :: Text
</span><a href="Elara.Lexer.Utils.html#_rest"><span class="hs-identifier hs-var">_rest</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680017962"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-143"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_position :: RealPosition
</span><a href="Elara.Lexer.Utils.html#_position"><span class="hs-identifier hs-var">_position</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; RealPosition
</span><a href="Elara.AST.Region.html#Position"><span class="hs-identifier hs-var">Position</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-144"></span><span>                </span><span class="hs-special">}</span><span>
</span><span id="line-145"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_lexSC :: Int
</span><a href="Elara.Lexer.Utils.html#_lexSC"><span class="hs-identifier hs-var">_lexSC</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-146"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_stringBuf :: Text
</span><a href="Elara.Lexer.Utils.html#_stringBuf"><span class="hs-identifier hs-var">_stringBuf</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;&quot;</span></span><span>
</span><span id="line-147"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_pendingTokens :: [Lexeme]
</span><a href="Elara.Lexer.Utils.html#_pendingTokens"><span class="hs-identifier hs-var">_pendingTokens</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-148"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_indentStack :: NonEmpty IndentInfo
</span><a href="Elara.Lexer.Utils.html#_indentStack"><span class="hs-identifier hs-var">_indentStack</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-149"></span><span>            </span><span class="annot"><span class="annottext">Int -&gt; RealPosition -&gt; Int -&gt; IndentInfo
</span><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-var">IndentInfo</span></a></span><span>
</span><span id="line-150"></span><span>                </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-151"></span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; RealPosition
</span><a href="Elara.AST.Region.html#Position"><span class="hs-identifier hs-var">Position</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-152"></span><span>                </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-153"></span><span>                </span><span class="annot"><span class="annottext">IndentInfo -&gt; [IndentInfo] -&gt; NonEmpty IndentInfo
forall a. a -&gt; [a] -&gt; NonEmpty a
</span><span class="hs-operator hs-var">:|</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-154"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_pendingPosition :: RealPosition
</span><a href="Elara.Lexer.Utils.html#_pendingPosition"><span class="hs-identifier hs-var">_pendingPosition</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; RealPosition
</span><a href="Elara.AST.Region.html#Position"><span class="hs-identifier hs-var">Position</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-155"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_prevEndsExpr :: Bool
</span><a href="Elara.Lexer.Utils.html#_prevEndsExpr"><span class="hs-identifier hs-var">_prevEndsExpr</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-156"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_delimDepth :: Int
</span><a href="Elara.Lexer.Utils.html#_delimDepth"><span class="hs-identifier hs-var">_delimDepth</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-157"></span><span>        </span><span class="hs-special">}</span><span>
</span><span id="line-158"></span><span>
</span><span id="line-159"></span><span class="annot"><a href="Elara.Lexer.Utils.html#pushFront"><span class="hs-identifier hs-type">pushFront</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-160"></span><span id="pushFront"><span class="annot"><span class="annottext">pushFront :: Lexeme -&gt; LexMonad ()
</span><a href="Elara.Lexer.Utils.html#pushFront"><span class="hs-identifier hs-var hs-var">pushFront</span></a></span></span><span> </span><span id="local-6989586621680017971"><span class="annot"><span class="annottext">Lexeme
</span><a href="#local-6989586621680017971"><span class="hs-identifier hs-var">lex</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(ParseState -&gt; ParseState) -&gt; LexMonad ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
(s -&gt; s) -&gt; Eff es ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState [Lexeme]
-&gt; ([Lexeme] -&gt; [Lexeme]) -&gt; ParseState -&gt; ParseState
forall k (is :: IxList) s t a b.
Is k A_Setter =&gt;
Optic k is s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
</span><span class="hs-identifier hs-var">over</span></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState [Lexeme]
</span><a href="Elara.Lexer.Utils.html#pendingTokens"><span class="hs-identifier hs-var">pendingTokens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lexeme
</span><a href="#local-6989586621680017971"><span class="hs-identifier hs-var">lex</span></a></span><span> </span><span class="annot"><span class="annottext">Lexeme -&gt; [Lexeme] -&gt; [Lexeme]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-161"></span><span>
</span><span id="line-162"></span><span class="annot"><a href="Elara.Lexer.Utils.html#pushBack"><span class="hs-identifier hs-type">pushBack</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-163"></span><span id="pushBack"><span class="annot"><span class="annottext">pushBack :: Lexeme -&gt; LexMonad ()
</span><a href="Elara.Lexer.Utils.html#pushBack"><span class="hs-identifier hs-var hs-var">pushBack</span></a></span></span><span> </span><span id="local-6989586621680017980"><span class="annot"><span class="annottext">Lexeme
</span><a href="#local-6989586621680017980"><span class="hs-identifier hs-var">lex</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(ParseState -&gt; ParseState) -&gt; LexMonad ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
(s -&gt; s) -&gt; Eff es ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState [Lexeme]
-&gt; ([Lexeme] -&gt; [Lexeme]) -&gt; ParseState -&gt; ParseState
forall k (is :: IxList) s t a b.
Is k A_Setter =&gt;
Optic k is s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
</span><span class="hs-identifier hs-var">over</span></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState [Lexeme]
</span><a href="Elara.Lexer.Utils.html#pendingTokens"><span class="hs-identifier hs-var">pendingTokens</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680017981"><span class="annot"><span class="annottext">[Lexeme]
</span><a href="#local-6989586621680017981"><span class="hs-identifier hs-var">toks</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Lexeme]
</span><a href="#local-6989586621680017981"><span class="hs-identifier hs-var">toks</span></a></span><span> </span><span class="annot"><span class="annottext">[Lexeme] -&gt; [Lexeme] -&gt; [Lexeme]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Lexeme
</span><a href="#local-6989586621680017980"><span class="hs-identifier hs-var">lex</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-164"></span><span>
</span><span id="line-165"></span><span class="hs-comment">-- Emits a token, updating the prevEndsExpr state if necessary</span><span>
</span><span id="line-166"></span><span class="annot"><a href="Elara.Lexer.Utils.html#emitAt"><span class="hs-identifier hs-type">emitAt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Token"><span class="hs-identifier hs-type">Token</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#SourceRegion"><span class="hs-identifier hs-type">SourceRegion</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-167"></span><span id="emitAt"><span class="annot"><span class="annottext">emitAt :: Token -&gt; SourceRegion -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitAt"><span class="hs-identifier hs-var hs-var">emitAt</span></a></span></span><span> </span><span id="local-6989586621680017994"><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680017994"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621680017995"><span class="annot"><span class="annottext">SourceRegion
</span><a href="#local-6989586621680017995"><span class="hs-identifier hs-var">region</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-168"></span><span>    </span><span id="local-6989586621680017996"><span class="annot"><a href="#local-6989586621680017996"><span class="hs-identifier hs-var">prevEnds</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">LexMonad Bool
</span><a href="Elara.Lexer.Utils.html#getPrevEndsExpr"><span class="hs-identifier hs-var">getPrevEndsExpr</span></a></span><span>
</span><span id="line-169"></span><span>    </span><span class="hs-comment">-- Suppress LINESEP if previous token cannot end an expression</span><span>
</span><span id="line-170"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621680017994"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-171"></span><span>        </span><span class="annot"><span class="annottext">Token
</span><a href="Elara.Lexer.Token.html#TokenLeftParen"><span class="hs-identifier hs-var">TokenLeftParen</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="Elara.Lexer.Token.html#TokenLeftBracket"><span class="hs-identifier hs-var">TokenLeftBracket</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="Elara.Lexer.Token.html#TokenLeftBrace"><span class="hs-identifier hs-var">TokenLeftBrace</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(ParseState -&gt; ParseState) -&gt; LexMonad ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
(s -&gt; s) -&gt; Eff es ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState Int
</span><a href="Elara.Lexer.Utils.html#delimDepth"><span class="hs-identifier hs-var">delimDepth</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState Int -&gt; (Int -&gt; Int) -&gt; ParseState -&gt; ParseState
forall k (is :: IxList) s t a b.
Is k A_Setter =&gt;
Optic k is s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
</span><span class="hs-operator hs-var">%~</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">LexMonad () -&gt; LexMonad (Maybe Lexeme) -&gt; LexMonad (Maybe Lexeme)
forall a b.
Eff '[State ParseState, Error LexerError, StructuredDebug] a
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] b
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">LexMonad (Maybe Lexeme)
</span><a href="#local-6989586621680018002"><span class="hs-identifier hs-var">emit</span></a></span><span>
</span><span id="line-172"></span><span>        </span><span class="annot"><span class="annottext">Token
</span><a href="Elara.Lexer.Token.html#TokenRightParen"><span class="hs-identifier hs-var">TokenRightParen</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="Elara.Lexer.Token.html#TokenRightBracket"><span class="hs-identifier hs-var">TokenRightBracket</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="Elara.Lexer.Token.html#TokenRightBrace"><span class="hs-identifier hs-var">TokenRightBrace</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Token -&gt; SourceRegion -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitCloser"><span class="hs-identifier hs-var">emitCloser</span></a></span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680017994"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><a href="#local-6989586621680017995"><span class="hs-identifier hs-var">region</span></a></span><span>
</span><span id="line-173"></span><span>        </span><span class="annot"><span class="annottext">Token
</span><a href="Elara.Lexer.Token.html#TokenLineSeparator"><span class="hs-identifier hs-var">TokenLineSeparator</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621680017996"><span class="hs-identifier hs-var">prevEnds</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-174"></span><span>            </span><span class="annot"><span class="annottext">Maybe Lexeme -&gt; LexMonad (Maybe Lexeme)
forall a.
a -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-175"></span><span>        </span><span class="annot"><span class="annottext">Token
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LexMonad (Maybe Lexeme)
</span><a href="#local-6989586621680018002"><span class="hs-identifier hs-var">emit</span></a></span><span>
</span><span id="line-176"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-177"></span><span>    </span><span id="local-6989586621680018002"><span class="annot"><span class="annottext">emit :: LexMonad (Maybe Lexeme)
</span><a href="#local-6989586621680018002"><span class="hs-identifier hs-var hs-var">emit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-178"></span><span>        </span><span class="annot"><span class="annottext">Bool -&gt; LexMonad ()
</span><a href="Elara.Lexer.Utils.html#setPrevEndsExpr"><span class="hs-identifier hs-var">setPrevEndsExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Token -&gt; Bool
</span><a href="Elara.Lexer.Token.html#tokenEndsExpr"><span class="hs-identifier hs-var">tokenEndsExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680017994"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-179"></span><span>        </span><span class="annot"><span class="annottext">Maybe Lexeme -&gt; LexMonad (Maybe Lexeme)
forall a.
a -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lexeme -&gt; Maybe Lexeme
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SourceRegion -&gt; Token -&gt; Lexeme
forall a. SourceRegion -&gt; a -&gt; Located a
</span><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-var">Located</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><a href="#local-6989586621680017995"><span class="hs-identifier hs-var">region</span></a></span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680017994"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-180"></span><span>
</span><span id="line-181"></span><span class="annot"><a href="Elara.Lexer.Utils.html#popPending"><span class="hs-identifier hs-type">popPending</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-182"></span><span id="popPending"><span class="annot"><span class="annottext">popPending :: LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#popPending"><span class="hs-identifier hs-var hs-var">popPending</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-183"></span><span>    </span><span id="local-6989586621680018020"><span class="annot"><a href="#local-6989586621680018020"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Eff
  '[State ParseState, Error LexerError, StructuredDebug] ParseState
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
Eff es s
</span><span class="hs-identifier hs-var">get</span></span><span>
</span><span id="line-184"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#_pendingTokens"><span class="hs-identifier hs-var">_pendingTokens</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018020"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-185"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621680018022"><span class="annot"><span class="annottext">Lexeme
</span><a href="#local-6989586621680018022"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621680018023"><span class="annot"><span class="annottext">[Lexeme]
</span><a href="#local-6989586621680018023"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ParseState -&gt; LexMonad ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
s -&gt; Eff es ()
</span><span class="hs-identifier hs-var">put</span></span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680018020"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.Lexer.Utils.html#_pendingTokens"><span class="hs-identifier hs-var">_pendingTokens</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680018023"><span class="hs-identifier hs-type">xs</span></a></span><span class="hs-special">}</span><span> </span><span class="annot"><span class="annottext">LexMonad () -&gt; LexMonad (Maybe Lexeme) -&gt; LexMonad (Maybe Lexeme)
forall a b.
Eff '[State ParseState, Error LexerError, StructuredDebug] a
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] b
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme -&gt; LexMonad (Maybe Lexeme)
forall a.
a -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lexeme -&gt; Maybe Lexeme
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Lexeme
</span><a href="#local-6989586621680018022"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-186"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme -&gt; LexMonad (Maybe Lexeme)
forall a.
a -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-187"></span><span>
</span><span id="line-188"></span><span class="hs-comment">-- Emit DEDENTs for layout opened inside current delimiter depth, then the closer.</span><span>
</span><span id="line-189"></span><span class="hs-comment">-- Return the first pending token (typically a DEDENT) so stream becomes &#8220;&#8230; &lt;DEDENT&gt; ) &#8230;&#8221;</span><span>
</span><span id="line-190"></span><span class="annot"><a href="Elara.Lexer.Utils.html#emitCloser"><span class="hs-identifier hs-type">emitCloser</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Token"><span class="hs-identifier hs-type">Token</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#SourceRegion"><span class="hs-identifier hs-type">SourceRegion</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-191"></span><span id="emitCloser"><span class="annot"><span class="annottext">emitCloser :: Token -&gt; SourceRegion -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitCloser"><span class="hs-identifier hs-var hs-var">emitCloser</span></a></span></span><span> </span><span id="local-6989586621680018039"><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680018039"><span class="hs-identifier hs-var">closerTok</span></a></span></span><span> </span><span id="local-6989586621680018040"><span class="annot"><span class="annottext">SourceRegion
</span><a href="#local-6989586621680018040"><span class="hs-identifier hs-var">closerReg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-192"></span><span>    </span><span class="annot"><span class="annottext">LexMonad ()
</span><a href="Elara.Lexer.Utils.html#flushLayoutBeforeCloser"><span class="hs-identifier hs-var">flushLayoutBeforeCloser</span></a></span><span>
</span><span id="line-193"></span><span>    </span><span class="annot"><span class="annottext">(ParseState -&gt; ParseState) -&gt; LexMonad ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
(s -&gt; s) -&gt; Eff es ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState Int
</span><a href="Elara.Lexer.Utils.html#delimDepth"><span class="hs-identifier hs-var">delimDepth</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState Int -&gt; (Int -&gt; Int) -&gt; ParseState -&gt; ParseState
forall k (is :: IxList) s t a b.
Is k A_Setter =&gt;
Optic k is s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
</span><span class="hs-operator hs-var">%~</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680018042"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680018042"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Ord a =&gt; a -&gt; a -&gt; a
</span><span class="hs-identifier hs-var">max</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680018042"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-194"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680018044"><span class="annot"><span class="annottext">closerLex :: Lexeme
</span><a href="#local-6989586621680018044"><span class="hs-identifier hs-var hs-var hs-var">closerLex</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SourceRegion -&gt; Token -&gt; Lexeme
forall a. SourceRegion -&gt; a -&gt; Located a
</span><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-var">Located</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><a href="#local-6989586621680018040"><span class="hs-identifier hs-var">closerReg</span></a></span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680018039"><span class="hs-identifier hs-var">closerTok</span></a></span><span>
</span><span id="line-195"></span><span>    </span><span class="annot"><span class="annottext">Lexeme -&gt; LexMonad ()
</span><a href="Elara.Lexer.Utils.html#pushBack"><span class="hs-identifier hs-var">pushBack</span></a></span><span> </span><span class="annot"><span class="annottext">Lexeme
</span><a href="#local-6989586621680018044"><span class="hs-identifier hs-var">closerLex</span></a></span><span>
</span><span id="line-196"></span><span>    </span><span id="local-6989586621680018045"><span class="annot"><a href="#local-6989586621680018045"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#popPending"><span class="hs-identifier hs-var">popPending</span></a></span><span>
</span><span id="line-197"></span><span>    </span><span class="hs-comment">-- keep prevEndsExpr consistent</span><span>
</span><span id="line-198"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621680018045"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-199"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680018046"><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680018046"><span class="hs-identifier hs-var">tok</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; LexMonad ()
</span><a href="Elara.Lexer.Utils.html#setPrevEndsExpr"><span class="hs-identifier hs-var">setPrevEndsExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Token -&gt; Bool
</span><a href="Elara.Lexer.Token.html#tokenEndsExpr"><span class="hs-identifier hs-var">tokenEndsExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680018046"><span class="hs-identifier hs-var">tok</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-200"></span><span>        </span><span class="annot"><span class="annottext">Maybe Lexeme
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; LexMonad ()
</span><a href="Elara.Lexer.Utils.html#setPrevEndsExpr"><span class="hs-identifier hs-var">setPrevEndsExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Token -&gt; Bool
</span><a href="Elara.Lexer.Token.html#tokenEndsExpr"><span class="hs-identifier hs-var">tokenEndsExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680018039"><span class="hs-identifier hs-var">closerTok</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-201"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><a href="#local-6989586621680018045"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-202"></span><span>
</span><span id="line-203"></span><span class="hs-comment">-- Close only layout started at or inside current delimiter depth</span><span>
</span><span id="line-204"></span><span class="annot"><a href="Elara.Lexer.Utils.html#flushLayoutBeforeCloser"><span class="hs-identifier hs-type">flushLayoutBeforeCloser</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-205"></span><span id="flushLayoutBeforeCloser"><span class="annot"><span class="annottext">flushLayoutBeforeCloser :: LexMonad ()
</span><a href="Elara.Lexer.Utils.html#flushLayoutBeforeCloser"><span class="hs-identifier hs-var hs-var">flushLayoutBeforeCloser</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-206"></span><span>    </span><span id="local-6989586621680018080"><span class="annot"><a href="#local-6989586621680018080"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState Int
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] Int
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState Int
</span><a href="Elara.Lexer.Utils.html#delimDepth"><span class="hs-identifier hs-var">delimDepth</span></a></span><span>
</span><span id="line-207"></span><span>    </span><span id="local-6989586621680018081"><span class="annot"><a href="#local-6989586621680018081"><span class="hs-identifier hs-var">st</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">get</span></span><span>
</span><span id="line-208"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680018082"><span class="annot"><a href="#local-6989586621680018082"><span class="hs-identifier hs-var hs-var">stk</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680018081"><span class="hs-identifier hs-var">st</span></a></span><span> </span><span class="annot"><span class="annottext">ParseState
-&gt; Lens' ParseState (NonEmpty IndentInfo) -&gt; NonEmpty IndentInfo
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (NonEmpty IndentInfo)
</span><a href="Elara.Lexer.Utils.html#indentStack"><span class="hs-identifier hs-var">indentStack</span></a></span><span>
</span><span id="line-209"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621680018083"><span class="annot"><a href="#local-6989586621680018083"><span class="hs-identifier hs-var">toClose</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680018084"><span class="annot"><a href="#local-6989586621680018084"><span class="hs-identifier hs-var">keep</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">span</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680018085"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680018085"><span class="hs-identifier hs-var">ii</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680018085"><span class="hs-identifier hs-var">ii</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo Int -&gt; Int
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo Int
</span><a href="Elara.Lexer.Utils.html#openedAtDepth"><span class="hs-identifier hs-var">openedAtDepth</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680018080"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680018082"><span class="hs-identifier hs-type">stk</span></a></span><span>
</span><span id="line-210"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621680018084"><span class="hs-identifier hs-type">keep</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-211"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LexMonad ()
forall (f :: * -&gt; *). Applicative f =&gt; f ()
</span><span class="hs-identifier hs-var">pass</span></span><span> </span><span class="hs-comment">-- base should remain</span><span>
</span><span id="line-212"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621680018087"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680018087"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621680018088"><span class="annot"><span class="annottext">[IndentInfo]
</span><a href="#local-6989586621680018088"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-213"></span><span>            </span><span class="annot"><span class="annottext">ParseState -&gt; LexMonad ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
s -&gt; Eff es ()
</span><span class="hs-identifier hs-var">put</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680018081"><span class="hs-identifier hs-var">st</span></a></span><span> </span><span class="annot"><span class="annottext">ParseState -&gt; (ParseState -&gt; ParseState) -&gt; ParseState
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span><span class="hs-operator hs-var">&amp;</span></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (NonEmpty IndentInfo)
</span><a href="Elara.Lexer.Utils.html#indentStack"><span class="hs-identifier hs-var">indentStack</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (NonEmpty IndentInfo)
-&gt; NonEmpty IndentInfo -&gt; ParseState -&gt; ParseState
forall k (is :: IxList) s t a b.
Is k A_Setter =&gt;
Optic k is s t a b -&gt; b -&gt; s -&gt; t
</span><span class="hs-operator hs-var">.~</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680018087"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; [IndentInfo] -&gt; NonEmpty IndentInfo
forall a. a -&gt; [a] -&gt; NonEmpty a
</span><span class="hs-operator hs-var">:|</span></span><span> </span><span class="annot"><span class="annottext">[IndentInfo]
</span><a href="#local-6989586621680018088"><span class="hs-identifier hs-var">bs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-214"></span><span>            </span><span id="local-6989586621680018091"><span class="annot"><a href="#local-6989586621680018091"><span class="hs-identifier hs-var">curPos</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState RealPosition
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] RealPosition
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput RealPosition -&gt; Lens' ParseState RealPosition
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput RealPosition
</span><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-var">position</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-215"></span><span>            </span><span id="local-6989586621680018092"><span class="annot"><a href="#local-6989586621680018092"><span class="hs-identifier hs-var">ds</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">catMaybes</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">mapM</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680018096"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680018096"><span class="hs-identifier hs-var">lvl</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">RealPosition -&gt; RealPosition -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitDedentAt"><span class="hs-identifier hs-var">emitDedentAt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680018096"><span class="hs-identifier hs-var">lvl</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo RealPosition -&gt; RealPosition
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo RealPosition
</span><a href="Elara.Lexer.Utils.html#indentPos"><span class="hs-identifier hs-var">indentPos</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018091"><span class="hs-identifier hs-var">curPos</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680018083"><span class="hs-identifier hs-type">toClose</span></a></span><span>
</span><span id="line-216"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">mapM_</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#pushFront"><span class="hs-identifier hs-type">pushFront</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">reverse</span></span><span> </span><span class="annot"><a href="#local-6989586621680018092"><span class="hs-identifier hs-type">ds</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-217"></span><span>
</span><span id="line-218"></span><span class="annot"><a href="Elara.Lexer.Utils.html#emitLayoutAt"><span class="hs-identifier hs-type">emitLayoutAt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Token"><span class="hs-identifier hs-type">Token</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealSourceRegion"><span class="hs-identifier hs-type">RealSourceRegion</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-219"></span><span id="emitLayoutAt"><span class="annot"><span class="annottext">emitLayoutAt :: Token -&gt; RealSourceRegion -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitLayoutAt"><span class="hs-identifier hs-var hs-var">emitLayoutAt</span></a></span></span><span> </span><span id="local-6989586621680018102"><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680018102"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621680018103"><span class="annot"><span class="annottext">RealSourceRegion
</span><a href="#local-6989586621680018103"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme -&gt; LexMonad (Maybe Lexeme)
forall a.
a -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lexeme -&gt; Maybe Lexeme
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SourceRegion -&gt; Token -&gt; Lexeme
forall a. SourceRegion -&gt; a -&gt; Located a
</span><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-var">Located</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">RealSourceRegion -&gt; SourceRegion
</span><a href="Elara.AST.Region.html#RealSourceRegion"><span class="hs-identifier hs-var">RealSourceRegion</span></a></span><span> </span><span class="annot"><span class="annottext">RealSourceRegion
</span><a href="#local-6989586621680018103"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680018102"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-220"></span><span>
</span><span id="line-221"></span><span class="annot"><a href="Elara.Lexer.Utils.html#emitIndentAt"><span class="hs-identifier hs-type">emitIndentAt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealPosition"><span class="hs-identifier hs-type">RealPosition</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-222"></span><span id="emitIndentAt"><span class="annot"><span class="annottext">emitIndentAt :: RealPosition -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitIndentAt"><span class="hs-identifier hs-var hs-var">emitIndentAt</span></a></span></span><span> </span><span id="local-6989586621680018107"><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018107"><span class="hs-identifier hs-var">pos</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-223"></span><span>    </span><span id="local-6989586621680018108"><span class="annot"><a href="#local-6989586621680018108"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">RealPosition -&gt; RealPosition -&gt; LexMonad RealSourceRegion
</span><a href="Elara.Lexer.Utils.html#createRegion"><span class="hs-identifier hs-var">createRegion</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018107"><span class="hs-identifier hs-var">pos</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018107"><span class="hs-identifier hs-var">pos</span></a></span><span>
</span><span id="line-224"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#emitLayoutAt"><span class="hs-identifier hs-type">emitLayoutAt</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokenIndent"><span class="hs-identifier hs-type">TokenIndent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018108"><span class="hs-identifier hs-type">r</span></a></span><span>
</span><span id="line-225"></span><span>
</span><span id="line-226"></span><span class="annot"><a href="Elara.Lexer.Utils.html#emitDedentAt"><span class="hs-identifier hs-type">emitDedentAt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokPosition"><span class="hs-identifier hs-type">TokPosition</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokPosition"><span class="hs-identifier hs-type">TokPosition</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-227"></span><span id="emitDedentAt"><span class="annot"><span class="annottext">emitDedentAt :: RealPosition -&gt; RealPosition -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitDedentAt"><span class="hs-identifier hs-var hs-var">emitDedentAt</span></a></span></span><span> </span><span id="local-6989586621680018112"><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018112"><span class="hs-identifier hs-var">start</span></a></span></span><span> </span><span id="local-6989586621680018113"><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018113"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-228"></span><span>    </span><span id="local-6989586621680018114"><span class="annot"><a href="#local-6989586621680018114"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">RealPosition -&gt; RealPosition -&gt; LexMonad RealSourceRegion
</span><a href="Elara.Lexer.Utils.html#createRegion"><span class="hs-identifier hs-var">createRegion</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018112"><span class="hs-identifier hs-var">start</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018113"><span class="hs-identifier hs-var">end</span></a></span><span>
</span><span id="line-229"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#emitLayoutAt"><span class="hs-identifier hs-type">emitLayoutAt</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokenDedent"><span class="hs-identifier hs-type">TokenDedent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018114"><span class="hs-identifier hs-type">r</span></a></span><span>
</span><span id="line-230"></span><span>
</span><span id="line-231"></span><span class="annot"><a href="Elara.Lexer.Utils.html#emitLineSepAt"><span class="hs-identifier hs-type">emitLineSepAt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealPosition"><span class="hs-identifier hs-type">RealPosition</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-232"></span><span id="emitLineSepAt"><span class="annot"><span class="annottext">emitLineSepAt :: RealPosition -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitLineSepAt"><span class="hs-identifier hs-var hs-var">emitLineSepAt</span></a></span></span><span> </span><span id="local-6989586621680018118"><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018118"><span class="hs-identifier hs-var">pos</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-233"></span><span>    </span><span id="local-6989586621680018119"><span class="annot"><a href="#local-6989586621680018119"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">RealPosition -&gt; RealPosition -&gt; LexMonad RealSourceRegion
</span><a href="Elara.Lexer.Utils.html#createRegion"><span class="hs-identifier hs-var">createRegion</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018118"><span class="hs-identifier hs-var">pos</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018118"><span class="hs-identifier hs-var">pos</span></a></span><span>
</span><span id="line-234"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#emitLayoutAt"><span class="hs-identifier hs-type">emitLayoutAt</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokenLineSeparator"><span class="hs-identifier hs-type">TokenLineSeparator</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018119"><span class="hs-identifier hs-type">r</span></a></span><span>
</span><span id="line-235"></span><span>
</span><span id="line-236"></span><span class="annot"><a href="Elara.Lexer.Utils.html#fake"><span class="hs-identifier hs-type">fake</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Token"><span class="hs-identifier hs-type">Token</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-237"></span><span id="fake"><span class="annot"><span class="annottext">fake :: Token -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#fake"><span class="hs-identifier hs-var hs-var">fake</span></a></span></span><span> </span><span id="local-6989586621680018123"><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680018123"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-238"></span><span>    </span><span id="local-6989586621680018124"><span class="annot"><a href="#local-6989586621680018124"><span class="hs-identifier hs-var">region</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Int
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] RealPosition
</span><a href="Elara.Lexer.Utils.html#getPosition"><span class="hs-identifier hs-var">getPosition</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Eff
  '[State ParseState, Error LexerError, StructuredDebug] RealPosition
-&gt; (RealPosition -&gt; LexMonad RealSourceRegion)
-&gt; LexMonad RealSourceRegion
forall a b.
Eff '[State ParseState, Error LexerError, StructuredDebug] a
-&gt; (a
    -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] b)
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">RealPosition -&gt; LexMonad RealSourceRegion
</span><a href="Elara.Lexer.Utils.html#createRegionStartingAt"><span class="hs-identifier hs-var">createRegionStartingAt</span></a></span><span>
</span><span id="line-239"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#emitAt"><span class="hs-identifier hs-type">emitAt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018123"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#RealSourceRegion"><span class="hs-identifier hs-type">RealSourceRegion</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018124"><span class="hs-identifier hs-type">region</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-240"></span><span>
</span><span id="line-241"></span><span class="annot"><a href="Elara.Lexer.Utils.html#startWhite"><span class="hs-identifier hs-type">startWhite</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-242"></span><span id="startWhite"><span class="annot"><span class="annottext">startWhite :: Int -&gt; Text -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#startWhite"><span class="hs-identifier hs-var hs-var">startWhite</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680018212"><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680018212"><span class="hs-identifier hs-var">str</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-243"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680018213"><span class="annot"><span class="annottext">indentation :: Int
</span><a href="#local-6989586621680018213"><span class="hs-identifier hs-var hs-var hs-var">indentation</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Text -&gt; Int
</span><span class="hs-identifier hs-var">T.length</span></span><span> </span><span class="annot"><span class="annottext">(Text -&gt; Int) -&gt; Text -&gt; Int
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Bool) -&gt; Text -&gt; Text
</span><span class="hs-identifier hs-var">T.dropWhile</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char -&gt; Char -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'\n'</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680018212"><span class="hs-identifier hs-var">str</span></a></span><span>
</span><span id="line-244"></span><span>    </span><span id="local-6989586621680018216"><span class="annot"><a href="#local-6989586621680018216"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Eff
  '[State ParseState, Error LexerError, StructuredDebug] ParseState
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
Eff es s
</span><span class="hs-identifier hs-var">get</span></span><span>
</span><span id="line-245"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680018217"><span class="annot"><a href="#local-6989586621680018217"><span class="hs-identifier hs-var">indents</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span id="local-6989586621680018218"><span class="annot"><a href="#local-6989586621680018218"><span class="hs-identifier hs-var">cur</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680018216"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">^.</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#indentStack"><span class="hs-identifier hs-type">indentStack</span></a></span><span>
</span><span id="line-246"></span><span>
</span><span id="line-247"></span><span>    </span><span id="local-6989586621680018219"><span class="annot"><a href="#local-6989586621680018219"><span class="hs-identifier hs-var">curPos</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-type">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-type">input</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">%</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-type">position</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-248"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621680018213"><span class="hs-identifier hs-type">indentation</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">`compare`</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680018218"><span class="hs-identifier hs-type">cur</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">^.</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#indent"><span class="hs-identifier hs-type">indent</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-249"></span><span>        </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">GT</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-250"></span><span>            </span><span id="local-6989586621680018221"><span class="annot"><a href="#local-6989586621680018221"><span class="hs-identifier hs-var">fakeLb</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">RealPosition -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitIndentAt"><span class="hs-identifier hs-var">emitIndentAt</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018219"><span class="hs-identifier hs-var">curPos</span></a></span><span>
</span><span id="line-251"></span><span>            </span><span id="local-6989586621680018222"><span class="annot"><a href="#local-6989586621680018222"><span class="hs-identifier hs-var">indentInfo</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#mkIndentInfo"><span class="hs-identifier hs-type">mkIndentInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018213"><span class="hs-identifier hs-type">indentation</span></a></span><span>
</span><span id="line-252"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680018223"><span class="annot"><a href="#local-6989586621680018223"><span class="hs-identifier hs-var hs-var">push</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Lexeme] -&gt; [Lexeme])
-&gt; (Lexeme -&gt; [Lexeme] -&gt; [Lexeme])
-&gt; Maybe Lexeme
-&gt; [Lexeme]
-&gt; [Lexeme]
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="annot"><span class="annottext">[Lexeme] -&gt; [Lexeme]
forall a. a -&gt; a
</span><a href="Prelude.html#identity"><span class="hs-identifier hs-var">identity</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme
</span><a href="#local-6989586621680018221"><span class="hs-identifier hs-var">fakeLb</span></a></span><span>
</span><span id="line-253"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">put</span></span><span> </span><span class="annot"><a href="#local-6989586621680018216"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.Lexer.Utils.html#_indentStack"><span class="hs-identifier hs-var">_indentStack</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680018222"><span class="hs-identifier hs-type">indentInfo</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;|</span></span><span> </span><span class="annot"><a href="#local-6989586621680018217"><span class="hs-identifier hs-type">indents</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#_pendingTokens"><span class="hs-identifier hs-var">_pendingTokens</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680018223"><span class="hs-identifier hs-type">push</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#_pendingTokens"><span class="hs-identifier hs-var">_pendingTokens</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018216"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span class="hs-special">}</span><span>
</span><span id="line-254"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span>
</span><span id="line-255"></span><span>        </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">LT</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-256"></span><span>            </span><span class="hs-comment">-- If the indentation is less than the current indentation, we need to close the current block</span><span>
</span><span id="line-257"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680018226"><span class="annot"><span class="annottext">[IndentInfo]
</span><a href="#local-6989586621680018226"><span class="hs-identifier hs-var hs-var">closingLevels</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680018227"><span class="annot"><span class="annottext">[IndentInfo]
</span><a href="#local-6989586621680018227"><span class="hs-identifier hs-var hs-var">topAndRest</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(IndentInfo -&gt; Bool)
-&gt; NonEmpty IndentInfo -&gt; ([IndentInfo], [IndentInfo])
forall a. (a -&gt; Bool) -&gt; NonEmpty a -&gt; ([a], [a])
</span><span class="hs-identifier hs-var">span</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Optic' A_Getter NoIx IndentInfo Bool -&gt; IndentInfo -&gt; Bool
forall k (is :: IxList) s a.
Is k A_Getter =&gt;
Optic' k is s a -&gt; s -&gt; a
</span><span class="hs-identifier hs-var">view</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' IndentInfo Int
</span><a href="Elara.Lexer.Utils.html#indent"><span class="hs-identifier hs-var">indent</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo Int
-&gt; Optic A_Getter NoIx Int Int Bool Bool
-&gt; Optic' A_Getter NoIx IndentInfo Bool
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">(Int -&gt; Bool) -&gt; Optic A_Getter NoIx Int Int Bool Bool
forall s a. (s -&gt; a) -&gt; Getter s a
</span><span class="hs-identifier hs-var">to</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680018213"><span class="hs-identifier hs-var">indentation</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">NonEmpty IndentInfo
</span><a href="#local-6989586621680018217"><span class="hs-identifier hs-var">indents</span></a></span><span>
</span><span id="line-258"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[IndentInfo]
</span><a href="#local-6989586621680018227"><span class="hs-identifier hs-var">topAndRest</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-259"></span><span>                </span><span class="hs-special">(</span><span id="local-6989586621680018230"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680018230"><span class="hs-identifier hs-var">top</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621680018231"><span class="annot"><span class="annottext">[IndentInfo]
</span><a href="#local-6989586621680018231"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-260"></span><span>                    </span><span id="local-6989586621680018232"><span class="annot"><a href="#local-6989586621680018232"><span class="hs-identifier hs-var">eofPos</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState RealPosition
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] RealPosition
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput RealPosition -&gt; Lens' ParseState RealPosition
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput RealPosition
</span><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-var">position</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-261"></span><span>
</span><span id="line-262"></span><span>                    </span><span id="local-6989586621680018233"><span class="annot"><a href="#local-6989586621680018233"><span class="hs-identifier hs-var">dedents</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">catMaybes</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">mapM</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680018234"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680018234"><span class="hs-identifier hs-var">lvl</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">RealPosition -&gt; RealPosition -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitDedentAt"><span class="hs-identifier hs-var">emitDedentAt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680018234"><span class="hs-identifier hs-var">lvl</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo RealPosition -&gt; RealPosition
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo RealPosition
</span><a href="Elara.Lexer.Utils.html#indentPos"><span class="hs-identifier hs-var">indentPos</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018232"><span class="hs-identifier hs-var">eofPos</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680018226"><span class="hs-identifier hs-type">closingLevels</span></a></span><span>
</span><span id="line-263"></span><span>                    </span><span class="hs-comment">-- emit at most one layout line separator for this line</span><span>
</span><span id="line-264"></span><span>                    </span><span id="local-6989586621680018235"><span class="annot"><a href="#local-6989586621680018235"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#emitLineSepAt"><span class="hs-identifier hs-type">emitLineSepAt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018232"><span class="hs-identifier hs-type">eofPos</span></a></span><span>
</span><span id="line-265"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680018236"><span class="annot"><a href="#local-6989586621680018236"><span class="hs-identifier hs-var hs-var">closings</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Lexeme]
</span><a href="#local-6989586621680018233"><span class="hs-identifier hs-var">dedents</span></a></span><span> </span><span class="annot"><span class="annottext">[Lexeme] -&gt; [Lexeme] -&gt; [Lexeme]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme -&gt; [Lexeme]
forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme
</span><a href="#local-6989586621680018235"><span class="hs-identifier hs-var">sep</span></a></span><span>
</span><span id="line-266"></span><span>                    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><a href="#local-6989586621680018230"><span class="hs-identifier hs-type">top</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">^.</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#indent"><span class="hs-identifier hs-type">indent</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">==</span></span><span> </span><span class="annot"><a href="#local-6989586621680018213"><span class="hs-identifier hs-type">indentation</span></a></span><span>
</span><span id="line-267"></span><span>                        </span><span class="hs-keyword">then</span><span>
</span><span id="line-268"></span><span>                            </span><span class="annot"><span class="hs-identifier hs-type">put</span></span><span>
</span><span id="line-269"></span><span>                                </span><span class="annot"><a href="#local-6989586621680018216"><span class="hs-identifier hs-type">s</span></a></span><span>
</span><span id="line-270"></span><span>                                    </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#_indentStack"><span class="hs-identifier hs-var">_indentStack</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680018230"><span class="hs-identifier hs-type">top</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span class="annot"><a href="#local-6989586621680018231"><span class="hs-identifier hs-type">xs</span></a></span><span>
</span><span id="line-271"></span><span>                                    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#_pendingTokens"><span class="hs-identifier hs-var">_pendingTokens</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680018236"><span class="hs-identifier hs-type">closings</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;&gt;</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#_pendingTokens"><span class="hs-identifier hs-var">_pendingTokens</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018216"><span class="hs-identifier hs-type">s</span></a></span><span>
</span><span id="line-272"></span><span>                                    </span><span class="hs-special">}</span><span>
</span><span id="line-273"></span><span>                        </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="hs-identifier hs-type">throwError</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#TooMuchIndentation"><span class="hs-identifier hs-type">TooMuchIndentation</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018230"><span class="hs-identifier hs-type">top</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">viaNonEmpty</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">last</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">init</span></span><span> </span><span class="annot"><a href="#local-6989586621680018217"><span class="hs-identifier hs-type">indents</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680018213"><span class="hs-identifier hs-type">indentation</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018216"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-274"></span><span>                </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Text -&gt; LexMonad ()
forall a t. (HasCallStack, IsText t) =&gt; t -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot; Indent stack contains nothing greater than &quot;</span></span><span> </span><span class="annot"><span class="annottext">Text -&gt; Text -&gt; Text
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Text
forall b a. (Show a, IsString b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680018213"><span class="hs-identifier hs-var">indentation</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-275"></span><span>            </span><span class="annot"><span class="annottext">Maybe Lexeme -&gt; LexMonad (Maybe Lexeme)
forall a.
a -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-276"></span><span>        </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">EQ</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-277"></span><span>            </span><span id="local-6989586621680018243"><span class="annot"><a href="#local-6989586621680018243"><span class="hs-identifier hs-var">ends</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">LexMonad Bool
</span><a href="Elara.Lexer.Utils.html#getPrevEndsExpr"><span class="hs-identifier hs-var">getPrevEndsExpr</span></a></span><span>
</span><span id="line-278"></span><span>            </span><span id="local-6989586621680018244"><span class="annot"><a href="#local-6989586621680018244"><span class="hs-identifier hs-var">pos</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-type">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-type">input</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">%</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-type">position</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-279"></span><span>            </span><span class="hs-keyword">if</span><span> </span><span class="annot"><a href="#local-6989586621680018243"><span class="hs-identifier hs-type">ends</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#emitLineSepAt"><span class="hs-identifier hs-type">emitLineSepAt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018244"><span class="hs-identifier hs-type">pos</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span>
</span><span id="line-280"></span><span>
</span><span id="line-281"></span><span class="hs-comment">-- Insert dedent for any leftover unclosed indents</span><span>
</span><span id="line-282"></span><span class="annot"><a href="Elara.Lexer.Utils.html#cleanIndentation"><span class="hs-identifier hs-type">cleanIndentation</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-283"></span><span id="cleanIndentation"><span class="annot"><span class="annottext">cleanIndentation :: Eff '[State ParseState, Error LexerError, StructuredDebug] [Lexeme]
</span><a href="Elara.Lexer.Utils.html#cleanIndentation"><span class="hs-identifier hs-var hs-var">cleanIndentation</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-284"></span><span>    </span><span id="local-6989586621680018272"><span class="annot"><a href="#local-6989586621680018272"><span class="hs-identifier hs-var">indentStack'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (NonEmpty IndentInfo)
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug]
     (NonEmpty IndentInfo)
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (NonEmpty IndentInfo)
</span><a href="Elara.Lexer.Utils.html#indentStack"><span class="hs-identifier hs-var">indentStack</span></a></span><span>
</span><span id="line-285"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621680018272"><span class="hs-identifier hs-type">indentStack'</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-286"></span><span>        </span><span id="local-6989586621680018273"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680018273"><span class="hs-identifier hs-var">_base</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Lexeme]
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] [Lexeme]
forall a.
a -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-287"></span><span>        </span><span class="annot"><span class="annottext">NonEmpty IndentInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-288"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680018274"><span class="annot"><span class="annottext">toClose :: [IndentInfo]
</span><a href="#local-6989586621680018274"><span class="hs-identifier hs-var hs-var hs-var">toClose</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NonEmpty IndentInfo -&gt; [IndentInfo]
forall (f :: * -&gt; *) a. IsNonEmpty f a [a] &quot;init&quot; =&gt; f a -&gt; [a]
</span><span class="hs-identifier hs-var">init</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty IndentInfo
</span><a href="#local-6989586621680018272"><span class="hs-identifier hs-var">indentStack'</span></a></span><span>
</span><span id="line-289"></span><span>                </span><span id="local-6989586621680018275"><span class="annot"><span class="annottext">base :: IndentInfo
</span><a href="#local-6989586621680018275"><span class="hs-identifier hs-var hs-var hs-var">base</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NonEmpty IndentInfo -&gt; IndentInfo
forall (f :: * -&gt; *) a. IsNonEmpty f a a &quot;last&quot; =&gt; f a -&gt; a
</span><span class="hs-identifier hs-var">last</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty IndentInfo
</span><a href="#local-6989586621680018272"><span class="hs-identifier hs-var">indentStack'</span></a></span><span>
</span><span id="line-290"></span><span>            </span><span id="local-6989586621680018276"><span class="annot"><a href="#local-6989586621680018276"><span class="hs-identifier hs-var">eofPos</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState RealPosition
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] RealPosition
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput RealPosition -&gt; Lens' ParseState RealPosition
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput RealPosition
</span><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-var">position</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-291"></span><span>            </span><span id="local-6989586621680018277"><span class="annot"><a href="#local-6989586621680018277"><span class="hs-identifier hs-var">dedents</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">catMaybes</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">mapM</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680018278"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680018278"><span class="hs-identifier hs-var">lvl</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">RealPosition -&gt; RealPosition -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitDedentAt"><span class="hs-identifier hs-var">emitDedentAt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680018278"><span class="hs-identifier hs-var">lvl</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo RealPosition -&gt; RealPosition
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo RealPosition
</span><a href="Elara.Lexer.Utils.html#indentPos"><span class="hs-identifier hs-var">indentPos</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018276"><span class="hs-identifier hs-var">eofPos</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680018274"><span class="hs-identifier hs-type">toClose</span></a></span><span>
</span><span id="line-292"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">modify</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621680018279"><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680018279"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680018279"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.Lexer.Utils.html#_indentStack"><span class="hs-identifier hs-var">_indentStack</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680018275"><span class="hs-identifier hs-type">base</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">}</span><span>
</span><span id="line-293"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><a href="#local-6989586621680018277"><span class="hs-identifier hs-type">dedents</span></a></span><span>
</span><span id="line-294"></span><span>
</span><span id="line-295"></span><span class="hs-comment">-- The functions that must be provided to Alex's basic interface</span><span>
</span><span id="line-296"></span><span>
</span><span id="line-297"></span><span class="hs-comment">-- The input: last character, unused bytes, remaining string</span><span>
</span><span id="line-298"></span><span class="annot"><a href="Elara.Lexer.Utils.html#alexGetByte"><span class="hs-identifier hs-type">alexGetByte</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-type">AlexInput</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-type">AlexInput</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-299"></span><span id="alexGetByte"><span class="annot"><span class="annottext">alexGetByte :: AlexInput -&gt; Maybe (Word8, AlexInput)
</span><a href="Elara.Lexer.Utils.html#alexGetByte"><span class="hs-identifier hs-var hs-var">alexGetByte</span></a></span></span><span> </span><span id="local-6989586621680018290"><span class="annot"><span class="annottext">ai :: AlexInput
</span><a href="#local-6989586621680018290"><span class="hs-identifier hs-var">ai</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-type">AlexInput</span></a></span><span class="hs-special">{</span><span id="local-6989586621680018291"><span id="local-6989586621680018292"><span id="local-6989586621680018293"><span id="local-6989586621680018294"><span id="local-6989586621680018295"><span class="annot"><span class="annottext">Char
FilePath
[Word8]
Text
RealPosition
_filePath :: AlexInput -&gt; FilePath
_prev :: AlexInput -&gt; Char
_bytes :: AlexInput -&gt; [Word8]
_rest :: AlexInput -&gt; Text
_position :: AlexInput -&gt; RealPosition
_filePath :: FilePath
_prev :: Char
_bytes :: [Word8]
_rest :: Text
_position :: RealPosition
</span><a href="Elara.Lexer.Utils.html#_filePath"><span class="hs-glyph hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">..</span></a></span></span></span></span></span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-300"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[Word8]
</span><a href="#local-6989586621680018293"><span class="hs-identifier hs-var">_bytes</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-301"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621680018296"><span class="annot"><span class="annottext">Word8
</span><a href="#local-6989586621680018296"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621680018297"><span class="annot"><span class="annottext">[Word8]
</span><a href="#local-6989586621680018297"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-302"></span><span>            </span><span class="annot"><span class="annottext">(Word8, AlexInput) -&gt; Maybe (Word8, AlexInput)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word8
</span><a href="#local-6989586621680018296"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">AlexInput
</span><a href="#local-6989586621680018290"><span class="hs-identifier hs-var">ai</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.Lexer.Utils.html#_bytes"><span class="hs-identifier hs-var">_bytes</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680018297"><span class="hs-identifier hs-type">bs</span></a></span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-303"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-304"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Text -&gt; Maybe (Char, Text)
</span><span class="hs-identifier hs-var">T.uncons</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680018294"><span class="hs-identifier hs-var">_rest</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-305"></span><span>                </span><span class="annot"><span class="annottext">Maybe (Char, Text)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (Word8, AlexInput)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-306"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680018299"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680018299"><span class="hs-identifier hs-var">char</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680018300"><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680018300"><span class="hs-identifier hs-var">chars</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-307"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Position"><span class="hs-identifier hs-type">Position</span></a></span><span> </span><span id="local-6989586621680018301"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680018301"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621680018302"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680018302"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018295"><span class="hs-identifier hs-var">_position</span></a></span><span>
</span><span id="line-308"></span><span>                        </span><span id="local-6989586621680018303"><span class="annot"><span class="annottext">n' :: Int
</span><a href="#local-6989586621680018303"><span class="hs-identifier hs-var hs-var">n'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680018299"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Char -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'\n'</span></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680018301"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680018301"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-309"></span><span>                        </span><span id="local-6989586621680018304"><span class="annot"><span class="annottext">c' :: Int
</span><a href="#local-6989586621680018304"><span class="hs-identifier hs-var hs-var">c'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680018299"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Char -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'\n'</span></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680018302"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-310"></span><span>                        </span><span class="hs-special">(</span><span id="local-6989586621680018305"><span class="annot"><span class="annottext">Word8
</span><a href="#local-6989586621680018305"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span id="local-6989586621680018306"><span class="annot"><span class="annottext">[Word8]
</span><a href="#local-6989586621680018306"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Item (NonEmpty Word8)] -&gt; NonEmpty Word8
forall l. IsList l =&gt; [Item l] -&gt; l
</span><span class="hs-identifier hs-var">fromList</span></span><span> </span><span class="annot"><span class="annottext">([Item (NonEmpty Word8)] -&gt; NonEmpty Word8)
-&gt; [Item (NonEmpty Word8)] -&gt; NonEmpty Word8
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; [Word8]
</span><span class="hs-identifier hs-var">encodeChar</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680018299"><span class="hs-identifier hs-var">char</span></a></span><span>
</span><span id="line-311"></span><span>                     </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">(Word8, AlexInput) -&gt; Maybe (Word8, AlexInput)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span>
</span><span id="line-312"></span><span>                            </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">Word8
</span><a href="#local-6989586621680018305"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-313"></span><span>                            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">AlexInput
</span><a href="#local-6989586621680018290"><span class="hs-identifier hs-var">ai</span></a></span><span>
</span><span id="line-314"></span><span>                                </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#_prev"><span class="hs-identifier hs-var">_prev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680018299"><span class="hs-identifier hs-type">char</span></a></span><span>
</span><span id="line-315"></span><span>                                </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#_bytes"><span class="hs-identifier hs-var">_bytes</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680018306"><span class="hs-identifier hs-type">bs</span></a></span><span>
</span><span id="line-316"></span><span>                                </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#_rest"><span class="hs-identifier hs-var">_rest</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680018300"><span class="hs-identifier hs-type">chars</span></a></span><span>
</span><span id="line-317"></span><span>                                </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#_position"><span class="hs-identifier hs-var">_position</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#Position"><span class="hs-identifier hs-type">Position</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018303"><span class="hs-identifier hs-type">n'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018304"><span class="hs-identifier hs-type">c'</span></a></span><span>
</span><span id="line-318"></span><span>                                </span><span class="hs-special">}</span><span>
</span><span id="line-319"></span><span>                            </span><span class="hs-special">)</span><span>
</span><span id="line-320"></span><span>
</span><span id="line-321"></span><span class="annot"><a href="Elara.Lexer.Utils.html#getLineNo"><span class="hs-identifier hs-type">getLineNo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-322"></span><span id="getLineNo"><span class="annot"><span class="annottext">getLineNo :: Eff '[State ParseState, Error LexerError, StructuredDebug] Int
</span><a href="Elara.Lexer.Utils.html#getLineNo"><span class="hs-identifier hs-var hs-var">getLineNo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState Int
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] Int
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput RealPosition -&gt; Lens' ParseState RealPosition
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput RealPosition
</span><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-var">position</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState RealPosition
-&gt; Optic A_Lens NoIx RealPosition RealPosition Int Int
-&gt; Lens' ParseState Int
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Optic A_Lens NoIx RealPosition RealPosition Int Int
</span><a href="Elara.AST.Region.html#line"><span class="hs-identifier hs-var">line</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-323"></span><span>
</span><span id="line-324"></span><span class="annot"><a href="Elara.Lexer.Utils.html#getColNo"><span class="hs-identifier hs-type">getColNo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-325"></span><span id="getColNo"><span class="annot"><span class="annottext">getColNo :: Eff '[State ParseState, Error LexerError, StructuredDebug] Int
</span><a href="Elara.Lexer.Utils.html#getColNo"><span class="hs-identifier hs-var hs-var">getColNo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState Int
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] Int
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput RealPosition -&gt; Lens' ParseState RealPosition
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput RealPosition
</span><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-var">position</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState RealPosition
-&gt; Optic A_Lens NoIx RealPosition RealPosition Int Int
-&gt; Lens' ParseState Int
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Optic A_Lens NoIx RealPosition RealPosition Int Int
</span><a href="Elara.AST.Region.html#column"><span class="hs-identifier hs-var">column</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-326"></span><span>
</span><span id="line-327"></span><span class="annot"><a href="Elara.Lexer.Utils.html#getPosition"><span class="hs-identifier hs-type">getPosition</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokPosition"><span class="hs-identifier hs-type">TokPosition</span></a></span><span>
</span><span id="line-328"></span><span id="getPosition"><span class="annot"><span class="annottext">getPosition :: Int
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] RealPosition
</span><a href="Elara.Lexer.Utils.html#getPosition"><span class="hs-identifier hs-var hs-var">getPosition</span></a></span></span><span> </span><span id="local-6989586621680018336"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680018336"><span class="hs-identifier hs-var">tokenLength</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-329"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-type">ParseState</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.Lexer.Utils.html#_input"><span class="hs-identifier hs-var">_input</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-type">AlexInput</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.Lexer.Utils.html#_position"><span class="hs-identifier hs-var">_position</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Position"><span class="hs-identifier hs-type">Position</span></a></span><span> </span><span id="local-6989586621680018337"><span class="annot"><a href="#local-6989586621680018337"><span class="hs-identifier hs-var">ln</span></a></span></span><span> </span><span id="local-6989586621680018338"><span class="annot"><a href="#local-6989586621680018338"><span class="hs-identifier hs-var">cn</span></a></span></span><span class="hs-special">)</span><span class="hs-special">}</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Eff
  '[State ParseState, Error LexerError, StructuredDebug] ParseState
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
Eff es s
</span><span class="hs-identifier hs-var">get</span></span><span>
</span><span id="line-330"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="Elara.AST.Region.html#Position"><span class="hs-identifier hs-type">Position</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018337"><span class="hs-identifier hs-type">ln</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680018338"><span class="hs-identifier hs-type">cn</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">-</span></span><span> </span><span class="annot"><a href="#local-6989586621680018336"><span class="hs-identifier hs-type">tokenLength</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-331"></span><span>
</span><span id="line-332"></span><span class="annot"><a href="Elara.Lexer.Utils.html#createRegion"><span class="hs-identifier hs-type">createRegion</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokPosition"><span class="hs-identifier hs-type">TokPosition</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokPosition"><span class="hs-identifier hs-type">TokPosition</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealSourceRegion"><span class="hs-identifier hs-type">RealSourceRegion</span></a></span><span>
</span><span id="line-333"></span><span id="createRegion"><span class="annot"><span class="annottext">createRegion :: RealPosition -&gt; RealPosition -&gt; LexMonad RealSourceRegion
</span><a href="Elara.Lexer.Utils.html#createRegion"><span class="hs-identifier hs-var hs-var">createRegion</span></a></span></span><span> </span><span id="local-6989586621680018349"><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018349"><span class="hs-identifier hs-var">start</span></a></span></span><span> </span><span id="local-6989586621680018350"><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018350"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-334"></span><span>    </span><span id="local-6989586621680018351"><span class="annot"><a href="#local-6989586621680018351"><span class="hs-identifier hs-var">fp</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Optic' A_Lens NoIx ParseState FilePath
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] FilePath
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput FilePath
-&gt; Optic' A_Lens NoIx ParseState FilePath
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput FilePath
</span><a href="Elara.Lexer.Utils.html#filePath"><span class="hs-identifier hs-var">filePath</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-335"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="Elara.AST.Region.html#mkSourceRegionIn"><span class="hs-identifier hs-type">mkSourceRegionIn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><a href="#local-6989586621680018351"><span class="hs-identifier hs-type">fp</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680018349"><span class="hs-identifier hs-type">start</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018350"><span class="hs-identifier hs-type">end</span></a></span><span>
</span><span id="line-336"></span><span>
</span><span id="line-337"></span><span class="annot"><a href="Elara.Lexer.Utils.html#createRegionStartingAt"><span class="hs-identifier hs-type">createRegionStartingAt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokPosition"><span class="hs-identifier hs-type">TokPosition</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealSourceRegion"><span class="hs-identifier hs-type">RealSourceRegion</span></a></span><span>
</span><span id="line-338"></span><span id="createRegionStartingAt"><span class="annot"><span class="annottext">createRegionStartingAt :: RealPosition -&gt; LexMonad RealSourceRegion
</span><a href="Elara.Lexer.Utils.html#createRegionStartingAt"><span class="hs-identifier hs-var hs-var">createRegionStartingAt</span></a></span></span><span> </span><span id="local-6989586621680018353"><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680018353"><span class="hs-identifier hs-var">start</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-339"></span><span>    </span><span id="local-6989586621680018354"><span class="annot"><a href="#local-6989586621680018354"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Int
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] RealPosition
</span><a href="Elara.Lexer.Utils.html#getPosition"><span class="hs-identifier hs-var">getPosition</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-340"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#createRegion"><span class="hs-identifier hs-type">createRegion</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018353"><span class="hs-identifier hs-type">start</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680018354"><span class="hs-identifier hs-type">end</span></a></span><span>
</span><span id="line-341"></span><span>
</span><span id="line-342"></span><span class="annot"><span class="hs-comment">{- | splits a qualified name into the qualifier and the name.
Throws an error if the name is not qualified.

Examples:

&gt;&gt;&gt; splitQualName &quot;Hello.world&quot;
(ModuleName (&quot;Hello&quot; :| []),&quot;world&quot;)

&gt;&gt;&gt; splitQualName &quot;A.B.C&quot;
(ModuleName (&quot;A&quot; :| [&quot;B&quot;]),&quot;C&quot;)

&gt;&gt;&gt; splitQualName &quot;Prelude..+&quot;
(ModuleName (&quot;Prelude&quot; :| []),&quot;.+&quot;)

&gt;&gt;&gt; splitQualName &quot;A.!.&quot;
(ModuleName (&quot;A&quot; :| []),&quot;!.&quot;)
-}</span></span><span>
</span><span id="line-359"></span><span class="annot"><a href="Elara.Lexer.Utils.html#splitQualName"><span class="hs-identifier hs-type">splitQualName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span class="hs-special">)</span><span>
</span><span id="line-360"></span><span id="splitQualName"><span class="annot"><span class="annottext">splitQualName :: Text -&gt; (ModuleName, Text)
</span><a href="Elara.Lexer.Utils.html#splitQualName"><span class="hs-identifier hs-var hs-var">splitQualName</span></a></span></span><span> </span><span id="local-6989586621680018396"><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680018396"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-361"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680018397"><span class="annot"><span class="annottext">parts :: [Text]
</span><a href="#local-6989586621680018397"><span class="hs-identifier hs-var hs-var">parts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HasCallStack =&gt; Text -&gt; Text -&gt; [Text]
Text -&gt; Text -&gt; [Text]
</span><span class="hs-identifier hs-var">T.splitOn</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;.&quot;</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680018396"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-362"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[Text]
</span><a href="#local-6989586621680018397"><span class="hs-identifier hs-var">parts</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-363"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Text -&gt; (ModuleName, Text)
forall a t. (HasCallStack, IsText t) =&gt; t -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;Empty string&quot;</span></span><span>
</span><span id="line-364"></span><span>        </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;&quot;</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Text -&gt; (ModuleName, Text)
forall a t. (HasCallStack, IsText t) =&gt; t -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;Empty string&quot;</span></span><span>
</span><span id="line-365"></span><span>        </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Text
</span><span class="hs-identifier">_</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Text -&gt; (ModuleName, Text)
forall a t. (HasCallStack, IsText t) =&gt; t -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;No module name&quot;</span></span><span>
</span><span id="line-366"></span><span>        </span><span id="local-6989586621680018399"><span class="annot"><span class="annottext">[Text]
</span><a href="#local-6989586621680018399"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-367"></span><span>            </span><span class="hs-comment">-- we have to be careful here, we can't just take the 'init' because that will break operators that start with .</span><span>
</span><span id="line-368"></span><span>            </span><span class="hs-comment">-- &gt;&gt;&gt; [&quot;Prelude&quot;, &quot;&quot;, &quot;+&quot;] = (&quot;Prelude&quot;, &quot;.+&quot;)</span><span>
</span><span id="line-369"></span><span>            </span><span class="hs-comment">-- &gt;&gt;&gt; [&quot;Prelude&quot;, &quot;T&quot;] = (&quot;Prelude&quot;, &quot;T&quot;)</span><span>
</span><span id="line-370"></span><span>            </span><span class="hs-comment">-- &gt;&gt;&gt; [&quot;Prelude&quot;, &quot;T&quot;, &quot;&quot;] = (&quot;Prelude.T&quot;, &quot;.&quot;)</span><span>
</span><span id="line-371"></span><span>            </span><span class="hs-comment">-- &gt;&gt;&gt; [&quot;A&quot;, &quot;!&quot;, &quot;&quot;] = (&quot;A&quot;, &quot;!.&quot;)</span><span>
</span><span id="line-372"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680018400"><span class="annot"><span class="annottext">isAlphaNumeric :: Text -&gt; Bool
</span><a href="#local-6989586621680018400"><span class="hs-identifier hs-var hs-var">isAlphaNumeric</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Bool) -&gt; Text -&gt; Bool
</span><span class="hs-identifier hs-var">T.all</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680018402"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680018402"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Char -&gt; Bool
</span><span class="hs-identifier hs-var">isAlpha</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680018402"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Bool
</span><span class="hs-identifier hs-var">isDigit</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680018402"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-373"></span><span>                </span><span class="hs-special">(</span><span id="local-6989586621680018406"><span class="annot"><span class="annottext">[Text]
</span><a href="#local-6989586621680018406"><span class="hs-identifier hs-var">modPart</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680018407"><span class="annot"><span class="annottext">[Text]
</span><a href="#local-6989586621680018407"><span class="hs-identifier hs-var">namePart</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Text -&gt; Bool) -&gt; NonEmpty Text -&gt; ([Text], [Text])
forall a. (a -&gt; Bool) -&gt; NonEmpty a -&gt; ([a], [a])
</span><span class="hs-identifier hs-var">span</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Bool -&gt; Bool -&gt; Bool)
-&gt; (Text -&gt; Bool) -&gt; (Text -&gt; Bool) -&gt; Text -&gt; Bool
forall a b c.
(a -&gt; b -&gt; c) -&gt; (Text -&gt; a) -&gt; (Text -&gt; b) -&gt; Text -&gt; c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">(&amp;&amp;)</span></span><span> </span><span class="annot"><span class="annottext">Text -&gt; Bool
</span><a href="#local-6989586621680018400"><span class="hs-identifier hs-var">isAlphaNumeric</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Bool) -&gt; (Text -&gt; Bool) -&gt; Text -&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Text -&gt; Bool
</span><span class="hs-identifier hs-var">T.null</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Item (NonEmpty Text)] -&gt; NonEmpty Text
forall l. IsList l =&gt; [Item l] -&gt; l
</span><span class="hs-identifier hs-var">fromList</span></span><span> </span><span class="annot"><span class="annottext">[Text]
[Item (NonEmpty Text)]
</span><a href="#local-6989586621680018399"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-374"></span><span>             </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">[Text] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[Text]
</span><a href="#local-6989586621680018407"><span class="hs-identifier hs-var">namePart</span></a></span><span>
</span><span id="line-375"></span><span>                    </span><span class="hs-keyword">then</span><span> </span><span class="hs-comment">-- TODO: this isn't very efficient</span><span>
</span><span id="line-376"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NonEmpty Text -&gt; ModuleName
</span><a href="Elara.AST.Name.html#ModuleName"><span class="hs-identifier hs-var">ModuleName</span></a></span><span> </span><span class="annot"><span class="annottext">(NonEmpty Text -&gt; ModuleName) -&gt; NonEmpty Text -&gt; ModuleName
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Item (NonEmpty Text)] -&gt; NonEmpty Text
forall l. IsList l =&gt; [Item l] -&gt; l
</span><span class="hs-identifier hs-var">fromList</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NonEmpty Text -&gt; [Text]
forall (f :: * -&gt; *) a. IsNonEmpty f a [a] &quot;init&quot; =&gt; f a -&gt; [a]
</span><span class="hs-identifier hs-var">init</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Item (NonEmpty Text)] -&gt; NonEmpty Text
forall l. IsList l =&gt; [Item l] -&gt; l
</span><span class="hs-identifier hs-var">fromList</span></span><span> </span><span class="annot"><span class="annottext">[Text]
[Item (NonEmpty Text)]
</span><a href="#local-6989586621680018406"><span class="hs-identifier hs-var">modPart</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">NonEmpty Text -&gt; Text
forall (f :: * -&gt; *) a. IsNonEmpty f a a &quot;last&quot; =&gt; f a -&gt; a
</span><span class="hs-identifier hs-var">last</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Item (NonEmpty Text)] -&gt; NonEmpty Text
forall l. IsList l =&gt; [Item l] -&gt; l
</span><span class="hs-identifier hs-var">fromList</span></span><span> </span><span class="annot"><span class="annottext">[Text]
[Item (NonEmpty Text)]
</span><a href="#local-6989586621680018406"><span class="hs-identifier hs-var">modPart</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-377"></span><span>                    </span><span class="hs-keyword">else</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NonEmpty Text -&gt; ModuleName
</span><a href="Elara.AST.Name.html#ModuleName"><span class="hs-identifier hs-var">ModuleName</span></a></span><span> </span><span class="annot"><span class="annottext">(NonEmpty Text -&gt; ModuleName) -&gt; NonEmpty Text -&gt; ModuleName
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Item (NonEmpty Text)] -&gt; NonEmpty Text
forall l. IsList l =&gt; [Item l] -&gt; l
</span><span class="hs-identifier hs-var">fromList</span></span><span> </span><span class="annot"><span class="annottext">[Text]
[Item (NonEmpty Text)]
</span><a href="#local-6989586621680018406"><span class="hs-identifier hs-var">modPart</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Text -&gt; [Text] -&gt; Text
</span><span class="hs-identifier hs-var">T.intercalate</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;.&quot;</span></span><span> </span><span class="annot"><span class="annottext">[Text]
</span><a href="#local-6989586621680018407"><span class="hs-identifier hs-var">namePart</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-378"></span></pre></body></html>