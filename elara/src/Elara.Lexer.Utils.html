<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE ImpredicativeTypes #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE OrPatterns #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE RecordWildCards #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE StrictData #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE TemplateHaskell #-}</span><span>
</span><span id="line-6"></span><span>
</span><span id="line-7"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html"><span class="hs-identifier">Elara.Lexer.Utils</span></a></span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-8"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier">LexMonad</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-9"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier">ParseState</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-10"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier">AlexInput</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-11"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexerError"><span class="hs-identifier">LexerError</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-12"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#getPosition"><span class="hs-identifier">getPosition</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-13"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#stringBuf"><span class="hs-identifier">stringBuf</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-14"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#lexSC"><span class="hs-identifier">lexSC</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-15"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#commentDepth"><span class="hs-identifier">commentDepth</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-16"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#pendingPosition"><span class="hs-identifier">pendingPosition</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-17"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier">input</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-18"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#pendingTokens"><span class="hs-identifier">pendingTokens</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-19"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier">position</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-20"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#rest"><span class="hs-identifier">rest</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-21"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#cleanIndentation"><span class="hs-identifier">cleanIndentation</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-22"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#createRegionStartingAt"><span class="hs-identifier">createRegionStartingAt</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-23"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#emitAt"><span class="hs-identifier">emitAt</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-24"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#createRegion"><span class="hs-identifier">createRegion</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-25"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#splitQualName"><span class="hs-identifier">splitQualName</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-26"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#startWhite"><span class="hs-identifier">startWhite</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#alexGetByte"><span class="hs-identifier">alexGetByte</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-28"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#initialLexState"><span class="hs-identifier">initialLexState</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-29"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#triggerIndentLayout"><span class="hs-identifier">triggerIndentLayout</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-30"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#triggerBlockLayout"><span class="hs-identifier">triggerBlockLayout</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-31"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#checkBlockLayout"><span class="hs-identifier">checkBlockLayout</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-33"></span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Codec.Binary.UTF8.String</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">encodeChar</span></span><span class="hs-special">)</span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Char</span></span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Kind</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Type</span></span><span class="hs-special">)</span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List.NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">span</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(&lt;|)</span></span><span class="hs-special">)</span><span>
</span><span id="line-38"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Text</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">T</span></span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Name.html"><span class="hs-identifier">Elara.AST.Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#ModuleName"><span class="hs-identifier">ModuleName</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Region.html"><span class="hs-identifier">Elara.AST.Region</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier">Located</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier">Located</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealPosition"><span class="hs-identifier">RealPosition</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealSourceRegion"><span class="hs-identifier">RealSourceRegion</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#SourceRegion"><span class="hs-identifier">SourceRegion</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#mkSourceRegionIn"><span class="hs-identifier">mkSourceRegionIn</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#positionToDiagnosePosition"><span class="hs-identifier">positionToDiagnosePosition</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Error.html"><span class="hs-identifier">Elara.Error</span></a></span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Error.Codes.html"><span class="hs-identifier">Elara.Error.Codes</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Codes</span></span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html"><span class="hs-identifier">Elara.Lexer.Token</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier">Lexeme</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokPosition"><span class="hs-identifier">TokPosition</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Token"><span class="hs-identifier">Token</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#tokenEndsExpr"><span class="hs-identifier">tokenEndsExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Error.Diagnose</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Marker</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Note</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Report</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Err</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-45"></span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Eff</span></span><span class="hs-special">)</span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful.Error.Static</span></span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Effectful.State.Extra.html"><span class="hs-identifier">Effectful.State.Extra</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier">use'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Effectful.State.Extra.html#%25%3D"><span class="hs-operator">(%=)</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Effectful.State.Extra.html#.%3D"><span class="hs-operator">(.=)</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful.State.Static.Local</span></span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Data.Pretty.html"><span class="hs-identifier">Elara.Data.Pretty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Pretty.html#Pretty"><span class="hs-identifier">Pretty</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Logging.html"><span class="hs-identifier">Elara.Logging</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier">StructuredDebug</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Prelude.html"><span class="hs-identifier">Prelude</span></a></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">span</span></span><span class="hs-special">)</span><span>
</span><span id="line-53"></span><span>
</span><span id="line-54"></span><span class="hs-keyword">data</span><span> </span><span id="AlexInput"><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-var">AlexInput</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="AlexInput"><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-var">AlexInput</span></a></span></span><span>
</span><span id="line-55"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="_filePath"><span class="annot"><span class="annottext">AlexInput -&gt; FilePath
</span><a href="Elara.Lexer.Utils.html#_filePath"><span class="hs-identifier hs-var hs-var">_filePath</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span>
</span><span id="line-56"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_prev"><span class="annot"><span class="annottext">AlexInput -&gt; Char
</span><a href="Elara.Lexer.Utils.html#_prev"><span class="hs-identifier hs-var hs-var">_prev</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span>
</span><span id="line-57"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_bytes"><span class="annot"><span class="annottext">AlexInput -&gt; [Word8]
</span><a href="Elara.Lexer.Utils.html#_bytes"><span class="hs-identifier hs-var hs-var">_bytes</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span class="hs-special">]</span><span>
</span><span id="line-58"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_rest"><span class="annot"><span class="annottext">AlexInput -&gt; Text
</span><a href="Elara.Lexer.Utils.html#_rest"><span class="hs-identifier hs-var hs-var">_rest</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span>
</span><span id="line-59"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_position"><span class="annot"><span class="annottext">AlexInput -&gt; RealPosition
</span><a href="Elara.Lexer.Utils.html#_position"><span class="hs-identifier hs-var hs-var">_position</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealPosition"><span class="hs-identifier hs-type">RealPosition</span></a></span><span>
</span><span id="line-60"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-61"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680083035"><span id="local-6989586621680083058"><span id="local-6989586621680083062"><span class="annot"><span class="annottext">Int -&gt; AlexInput -&gt; ShowS
[AlexInput] -&gt; ShowS
AlexInput -&gt; FilePath
(Int -&gt; AlexInput -&gt; ShowS)
-&gt; (AlexInput -&gt; FilePath)
-&gt; ([AlexInput] -&gt; ShowS)
-&gt; Show AlexInput
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; AlexInput -&gt; ShowS
showsPrec :: Int -&gt; AlexInput -&gt; ShowS
$cshow :: AlexInput -&gt; FilePath
show :: AlexInput -&gt; FilePath
$cshowList :: [AlexInput] -&gt; ShowS
showList :: [AlexInput] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680083069"><span id="local-6989586621680083071"><span class="annot"><span class="annottext">(forall x. AlexInput -&gt; Rep AlexInput x)
-&gt; (forall x. Rep AlexInput x -&gt; AlexInput) -&gt; Generic AlexInput
forall x. Rep AlexInput x -&gt; AlexInput
forall x. AlexInput -&gt; Rep AlexInput x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. AlexInput -&gt; Rep AlexInput x
from :: forall x. AlexInput -&gt; Rep AlexInput x
$cto :: forall x. Rep AlexInput x -&gt; AlexInput
to :: forall x. Rep AlexInput x -&gt; AlexInput
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-62"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621680083077"><span class="annot"><a href="Elara.Data.Pretty.html#Pretty"><span class="hs-identifier hs-type">Pretty</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-type">AlexInput</span></a></span></span><span>
</span><span id="line-63"></span><span>
</span><span id="line-64"></span><span class="hs-keyword">data</span><span> </span><span id="IndentInfo"><span class="annot"><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-var">IndentInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="IndentInfo"><span class="annot"><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-var">IndentInfo</span></a></span></span><span>
</span><span id="line-65"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="_indent"><span class="annot"><span class="annottext">IndentInfo -&gt; Int
</span><a href="Elara.Lexer.Utils.html#_indent"><span class="hs-identifier hs-var hs-var">_indent</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-66"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_indentPos"><span class="annot"><span class="annottext">IndentInfo -&gt; RealPosition
</span><a href="Elara.Lexer.Utils.html#_indentPos"><span class="hs-identifier hs-var hs-var">_indentPos</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealPosition"><span class="hs-identifier hs-type">RealPosition</span></a></span><span>
</span><span id="line-67"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_openedAtDepth"><span class="annot"><span class="annottext">IndentInfo -&gt; Int
</span><a href="Elara.Lexer.Utils.html#_openedAtDepth"><span class="hs-identifier hs-var hs-var">_openedAtDepth</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-68"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ the delimDepth when this indent was opened</span></span><span>
</span><span id="line-69"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-70"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680083159"><span id="local-6989586621680083172"><span id="local-6989586621680083176"><span class="annot"><span class="annottext">Int -&gt; IndentInfo -&gt; ShowS
[IndentInfo] -&gt; ShowS
IndentInfo -&gt; FilePath
(Int -&gt; IndentInfo -&gt; ShowS)
-&gt; (IndentInfo -&gt; FilePath)
-&gt; ([IndentInfo] -&gt; ShowS)
-&gt; Show IndentInfo
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; IndentInfo -&gt; ShowS
showsPrec :: Int -&gt; IndentInfo -&gt; ShowS
$cshow :: IndentInfo -&gt; FilePath
show :: IndentInfo -&gt; FilePath
$cshowList :: [IndentInfo] -&gt; ShowS
showList :: [IndentInfo] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680083179"><span id="local-6989586621680083181"><span class="annot"><span class="annottext">(forall x. IndentInfo -&gt; Rep IndentInfo x)
-&gt; (forall x. Rep IndentInfo x -&gt; IndentInfo) -&gt; Generic IndentInfo
forall x. Rep IndentInfo x -&gt; IndentInfo
forall x. IndentInfo -&gt; Rep IndentInfo x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. IndentInfo -&gt; Rep IndentInfo x
from :: forall x. IndentInfo -&gt; Rep IndentInfo x
$cto :: forall x. Rep IndentInfo x -&gt; IndentInfo
to :: forall x. Rep IndentInfo x -&gt; IndentInfo
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-71"></span><span>
</span><span id="line-72"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621680083184"><span class="annot"><a href="Elara.Data.Pretty.html#Pretty"><span class="hs-identifier hs-type">Pretty</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-type">IndentInfo</span></a></span></span><span>
</span><span id="line-73"></span><span>
</span><span id="line-74"></span><span class="hs-keyword">data</span><span> </span><span id="ParseState"><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-var">ParseState</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ParseState"><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-var">ParseState</span></a></span></span><span>
</span><span id="line-75"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="_input"><span class="annot"><span class="annottext">ParseState -&gt; AlexInput
</span><a href="Elara.Lexer.Utils.html#_input"><span class="hs-identifier hs-var hs-var">_input</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-type">AlexInput</span></a></span><span>
</span><span id="line-76"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_lexSC"><span class="annot"><span class="annottext">ParseState -&gt; Int
</span><a href="Elara.Lexer.Utils.html#_lexSC"><span class="hs-identifier hs-var hs-var">_lexSC</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-77"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ lexer start code</span></span><span>
</span><span id="line-78"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_stringBuf"><span class="annot"><span class="annottext">ParseState -&gt; Text
</span><a href="Elara.Lexer.Utils.html#_stringBuf"><span class="hs-identifier hs-var hs-var">_stringBuf</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span>
</span><span id="line-79"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ temporary storage for strings</span></span><span>
</span><span id="line-80"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_pendingTokens"><span class="annot"><span class="annottext">ParseState -&gt; [Lexeme]
</span><a href="Elara.Lexer.Utils.html#_pendingTokens"><span class="hs-identifier hs-var hs-var">_pendingTokens</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-81"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ right now used when Parser consumes the lookahead and decided to put it back</span></span><span>
</span><span id="line-82"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_indentStack"><span class="annot"><span class="annottext">ParseState -&gt; NonEmpty IndentInfo
</span><a href="Elara.Lexer.Utils.html#_indentStack"><span class="hs-identifier hs-var hs-var">_indentStack</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NonEmpty</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-type">IndentInfo</span></a></span><span>
</span><span id="line-83"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ stack of indentation levels</span></span><span>
</span><span id="line-84"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_pendingPosition"><span class="annot"><span class="annottext">ParseState -&gt; RealPosition
</span><a href="Elara.Lexer.Utils.html#_pendingPosition"><span class="hs-identifier hs-var hs-var">_pendingPosition</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokPosition"><span class="hs-identifier hs-type">TokPosition</span></a></span><span>
</span><span id="line-85"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ needed when parsing strings, chars, multi-line strings</span></span><span>
</span><span id="line-86"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_prevEndsExpr"><span class="annot"><span class="annottext">ParseState -&gt; Bool
</span><a href="Elara.Lexer.Utils.html#_prevEndsExpr"><span class="hs-identifier hs-var hs-var">_prevEndsExpr</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-87"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ did the previous token end an expression? (used for offside rule)</span></span><span>
</span><span id="line-88"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_delimDepth"><span class="annot"><span class="annottext">ParseState -&gt; Int
</span><a href="Elara.Lexer.Utils.html#_delimDepth"><span class="hs-identifier hs-var hs-var">_delimDepth</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-89"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ current depth of open delimiters ((), [], {</span></span><span>
</span><span id="line-90"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_commentDepth"><span class="annot"><span class="annottext">ParseState -&gt; Int
</span><a href="Elara.Lexer.Utils.html#_commentDepth"><span class="hs-identifier hs-var hs-var">_commentDepth</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-91"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ nested comment depth</span></span><span>
</span><span id="line-92"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="_layoutExpected"><span class="annot"><span class="annottext">ParseState -&gt; Maybe LayoutExpectation
</span><a href="Elara.Lexer.Utils.html#_layoutExpected"><span class="hs-identifier hs-var hs-var">_layoutExpected</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LayoutExpectation"><span class="hs-identifier hs-type">LayoutExpectation</span></a></span><span>
</span><span id="line-93"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ Tracks if the previous token triggers a layout block</span></span><span>
</span><span id="line-94"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-95"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680083232"><span id="local-6989586621680083264"><span id="local-6989586621680083268"><span class="annot"><span class="annottext">Int -&gt; ParseState -&gt; ShowS
[ParseState] -&gt; ShowS
ParseState -&gt; FilePath
(Int -&gt; ParseState -&gt; ShowS)
-&gt; (ParseState -&gt; FilePath)
-&gt; ([ParseState] -&gt; ShowS)
-&gt; Show ParseState
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; ParseState -&gt; ShowS
showsPrec :: Int -&gt; ParseState -&gt; ShowS
$cshow :: ParseState -&gt; FilePath
show :: ParseState -&gt; FilePath
$cshowList :: [ParseState] -&gt; ShowS
showList :: [ParseState] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680083275"><span id="local-6989586621680083277"><span class="annot"><span class="annottext">(forall x. ParseState -&gt; Rep ParseState x)
-&gt; (forall x. Rep ParseState x -&gt; ParseState) -&gt; Generic ParseState
forall x. Rep ParseState x -&gt; ParseState
forall x. ParseState -&gt; Rep ParseState x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. ParseState -&gt; Rep ParseState x
from :: forall x. ParseState -&gt; Rep ParseState x
$cto :: forall x. Rep ParseState x -&gt; ParseState
to :: forall x. Rep ParseState x -&gt; ParseState
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-96"></span><span>
</span><span id="line-97"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621680083280"><span class="annot"><a href="Elara.Data.Pretty.html#Pretty"><span class="hs-identifier hs-type">Pretty</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-type">ParseState</span></a></span></span><span>
</span><span id="line-98"></span><span>
</span><span id="line-99"></span><span class="hs-keyword">data</span><span> </span><span id="LayoutExpectation"><span class="annot"><a href="Elara.Lexer.Utils.html#LayoutExpectation"><span class="hs-identifier hs-var">LayoutExpectation</span></a></span></span><span>
</span><span id="line-100"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-comment">-- | Just checks alignment (like match/with)</span></span><span>
</span><span id="line-101"></span><span>      </span><span id="ExpectIndent"><span class="annot"><a href="Elara.Lexer.Utils.html#ExpectIndent"><span class="hs-identifier hs-var">ExpectIndent</span></a></span></span><span>
</span><span id="line-102"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-comment">-- | Starts a new block at the next token (let/where/do)</span></span><span>
</span><span id="line-103"></span><span>      </span><span id="ExpectBlock"><span class="annot"><a href="Elara.Lexer.Utils.html#ExpectBlock"><span class="hs-identifier hs-var">ExpectBlock</span></a></span></span><span>
</span><span id="line-104"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680083382"><span id="local-6989586621680083387"><span class="annot"><span class="annottext">LayoutExpectation -&gt; LayoutExpectation -&gt; Bool
(LayoutExpectation -&gt; LayoutExpectation -&gt; Bool)
-&gt; (LayoutExpectation -&gt; LayoutExpectation -&gt; Bool)
-&gt; Eq LayoutExpectation
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: LayoutExpectation -&gt; LayoutExpectation -&gt; Bool
== :: LayoutExpectation -&gt; LayoutExpectation -&gt; Bool
$c/= :: LayoutExpectation -&gt; LayoutExpectation -&gt; Bool
/= :: LayoutExpectation -&gt; LayoutExpectation -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680083392"><span id="local-6989586621680083397"><span id="local-6989586621680083400"><span class="annot"><span class="annottext">Int -&gt; LayoutExpectation -&gt; ShowS
[LayoutExpectation] -&gt; ShowS
LayoutExpectation -&gt; FilePath
(Int -&gt; LayoutExpectation -&gt; ShowS)
-&gt; (LayoutExpectation -&gt; FilePath)
-&gt; ([LayoutExpectation] -&gt; ShowS)
-&gt; Show LayoutExpectation
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; LayoutExpectation -&gt; ShowS
showsPrec :: Int -&gt; LayoutExpectation -&gt; ShowS
$cshow :: LayoutExpectation -&gt; FilePath
show :: LayoutExpectation -&gt; FilePath
$cshowList :: [LayoutExpectation] -&gt; ShowS
showList :: [LayoutExpectation] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680083403"><span id="local-6989586621680083405"><span class="annot"><span class="annottext">(forall x. LayoutExpectation -&gt; Rep LayoutExpectation x)
-&gt; (forall x. Rep LayoutExpectation x -&gt; LayoutExpectation)
-&gt; Generic LayoutExpectation
forall x. Rep LayoutExpectation x -&gt; LayoutExpectation
forall x. LayoutExpectation -&gt; Rep LayoutExpectation x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. LayoutExpectation -&gt; Rep LayoutExpectation x
from :: forall x. LayoutExpectation -&gt; Rep LayoutExpectation x
$cto :: forall x. Rep LayoutExpectation x -&gt; LayoutExpectation
to :: forall x. Rep LayoutExpectation x -&gt; LayoutExpectation
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-105"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621680083408"><span class="annot"><a href="Elara.Data.Pretty.html#Pretty"><span class="hs-identifier hs-type">Pretty</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LayoutExpectation"><span class="hs-identifier hs-type">LayoutExpectation</span></a></span></span><span>
</span><span id="line-106"></span><span>
</span><span id="line-107"></span><span id="position"><span id="rest"><span id="bytes"><span id="filePath"><span id="prev"><span class="hs-identifier">makeLenses</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">AlexInput</span></span></span></span></span></span><span>
</span><span id="line-108"></span><span id="indent"><span id="indentPos"><span id="openedAtDepth"><span class="hs-identifier">makeLenses</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">IndentInfo</span></span></span></span><span>
</span><span id="line-109"></span><span id="stringBuf"><span id="lexSC"><span id="commentDepth"><span id="pendingPosition"><span id="input"><span id="pendingTokens"><span id="delimDepth"><span id="indentStack"><span id="layoutExpected"><span id="prevEndsExpr"><span class="hs-identifier">makeLenses</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">ParseState</span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-110"></span><span>
</span><span id="line-111"></span><span class="hs-keyword">type</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-112"></span><span class="hs-keyword">type</span><span> </span><span id="LexMonad"><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-var">LexMonad</span></a></span></span><span> </span><span id="local-6989586621680083661"><span class="annot"><a href="#local-6989586621680083661"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="hs-special">'</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">State</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-type">ParseState</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Error</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexerError"><span class="hs-identifier hs-type">LexerError</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier hs-type">StructuredDebug</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="#local-6989586621680083661"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-113"></span><span>
</span><span id="line-114"></span><span class="annot"><a href="Elara.Lexer.Utils.html#setPrevEndsExpr"><span class="hs-identifier hs-type">setPrevEndsExpr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-115"></span><span id="setPrevEndsExpr"><span class="annot"><span class="annottext">setPrevEndsExpr :: Bool -&gt; LexMonad ()
</span><a href="Elara.Lexer.Utils.html#setPrevEndsExpr"><span class="hs-identifier hs-var hs-var">setPrevEndsExpr</span></a></span></span><span> </span><span id="local-6989586621680083667"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621680083667"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(ParseState -&gt; ParseState) -&gt; LexMonad ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
(s -&gt; s) -&gt; Eff es ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680083669"><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680083669"><span class="hs-identifier hs-var">st</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680083669"><span class="hs-identifier hs-var">st</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.Lexer.Utils.html#_prevEndsExpr"><span class="hs-identifier hs-var">_prevEndsExpr</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680083667"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-116"></span><span>
</span><span id="line-117"></span><span class="annot"><a href="Elara.Lexer.Utils.html#getPrevEndsExpr"><span class="hs-identifier hs-type">getPrevEndsExpr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-118"></span><span id="getPrevEndsExpr"><span class="annot"><span class="annottext">getPrevEndsExpr :: LexMonad Bool
</span><a href="Elara.Lexer.Utils.html#getPrevEndsExpr"><span class="hs-identifier hs-var hs-var">getPrevEndsExpr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(ParseState -&gt; Bool) -&gt; LexMonad Bool
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]) a.
(HasCallStack, State s :&gt; es) =&gt;
(s -&gt; a) -&gt; Eff es a
</span><span class="hs-identifier hs-var">gets</span></span><span> </span><span class="annot"><span class="annottext">ParseState -&gt; Bool
</span><a href="Elara.Lexer.Utils.html#_prevEndsExpr"><span class="hs-identifier hs-var">_prevEndsExpr</span></a></span><span>
</span><span id="line-119"></span><span>
</span><span id="line-120"></span><span class="annot"><a href="Elara.Lexer.Utils.html#mkIndentInfo"><span class="hs-identifier hs-type">mkIndentInfo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-type">IndentInfo</span></a></span><span>
</span><span id="line-121"></span><span id="mkIndentInfo"><span class="annot"><span class="annottext">mkIndentInfo :: Int -&gt; LexMonad IndentInfo
</span><a href="Elara.Lexer.Utils.html#mkIndentInfo"><span class="hs-identifier hs-var hs-var">mkIndentInfo</span></a></span></span><span> </span><span id="local-6989586621680083692"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680083692"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-122"></span><span>    </span><span id="local-6989586621680083693"><span class="annot"><a href="#local-6989586621680083693"><span class="hs-identifier hs-var">pos</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState RealPosition
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] RealPosition
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput RealPosition -&gt; Lens' ParseState RealPosition
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput RealPosition
</span><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-var">position</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-123"></span><span>    </span><span id="local-6989586621680083695"><span class="annot"><a href="#local-6989586621680083695"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-type">use'</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#delimDepth"><span class="hs-identifier hs-type">delimDepth</span></a></span><span>
</span><span id="line-124"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-type">IndentInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680083692"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680083693"><span class="hs-identifier hs-type">pos</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680083695"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-125"></span><span>
</span><span id="line-126"></span><span class="hs-keyword">data</span><span> </span><span id="LexerError"><span class="annot"><a href="Elara.Lexer.Utils.html#LexerError"><span class="hs-identifier hs-var">LexerError</span></a></span></span><span>
</span><span id="line-127"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-comment">-- | When an element is indented more than expected</span></span><span>
</span><span id="line-128"></span><span>      </span><span id="TooMuchIndentation"><span class="annot"><a href="Elara.Lexer.Utils.html#TooMuchIndentation"><span class="hs-identifier hs-var">TooMuchIndentation</span></a></span></span><span>
</span><span id="line-129"></span><span>        </span><span class="annot"><span class="hs-comment">-- | The expected indentation</span></span><span>
</span><span id="line-130"></span><span>        </span><span class="annot"><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-type">IndentInfo</span></a></span><span>
</span><span id="line-131"></span><span>        </span><span class="annot"><span class="hs-comment">-- | The potential further indentation</span></span><span>
</span><span id="line-132"></span><span>        </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-type">IndentInfo</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-133"></span><span>        </span><span class="annot"><span class="hs-comment">-- | The actual indentation</span></span><span>
</span><span id="line-134"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-135"></span><span>        </span><span class="annot"><span class="hs-comment">-- | The current state of the lexer</span></span><span>
</span><span id="line-136"></span><span>        </span><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-type">ParseState</span></a></span><span>
</span><span id="line-137"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="UnterminatedStringLiteral"><span class="annot"><a href="Elara.Lexer.Utils.html#UnterminatedStringLiteral"><span class="hs-identifier hs-var">UnterminatedStringLiteral</span></a></span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-type">ParseState</span></a></span><span>
</span><span id="line-138"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="GenericAlexError"><span class="annot"><a href="Elara.Lexer.Utils.html#GenericAlexError"><span class="hs-identifier hs-var">GenericAlexError</span></a></span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-type">AlexInput</span></a></span><span>
</span><span id="line-139"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680083700"><span id="local-6989586621680083715"><span id="local-6989586621680083719"><span class="annot"><span class="annottext">Int -&gt; LexerError -&gt; ShowS
[LexerError] -&gt; ShowS
LexerError -&gt; FilePath
(Int -&gt; LexerError -&gt; ShowS)
-&gt; (LexerError -&gt; FilePath)
-&gt; ([LexerError] -&gt; ShowS)
-&gt; Show LexerError
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; LexerError -&gt; ShowS
showsPrec :: Int -&gt; LexerError -&gt; ShowS
$cshow :: LexerError -&gt; FilePath
show :: LexerError -&gt; FilePath
$cshowList :: [LexerError] -&gt; ShowS
showList :: [LexerError] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680083722"><span id="local-6989586621680083724"><span class="annot"><span class="annottext">(forall x. LexerError -&gt; Rep LexerError x)
-&gt; (forall x. Rep LexerError x -&gt; LexerError) -&gt; Generic LexerError
forall x. Rep LexerError x -&gt; LexerError
forall x. LexerError -&gt; Rep LexerError x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. LexerError -&gt; Rep LexerError x
from :: forall x. LexerError -&gt; Rep LexerError x
$cto :: forall x. Rep LexerError x -&gt; LexerError
to :: forall x. Rep LexerError x -&gt; LexerError
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-140"></span><span>
</span><span id="line-141"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621680083727"><span class="annot"><a href="Elara.Data.Pretty.html#Pretty"><span class="hs-identifier hs-type">Pretty</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexerError"><span class="hs-identifier hs-type">LexerError</span></a></span></span><span>
</span><span id="line-142"></span><span>
</span><span id="line-143"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621680083773"><span class="annot"><a href="Elara.Error.html#ReportableError"><span class="hs-identifier hs-type">ReportableError</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexerError"><span class="hs-identifier hs-type">LexerError</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-144"></span><span>    </span><span id="local-6989586621680083780"><span class="annot"><span class="annottext">errorCode :: LexerError -&gt; Maybe ErrorCode
</span><a href="#local-6989586621680083780"><span class="hs-identifier hs-var hs-var hs-var">errorCode</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#TooMuchIndentation"><span class="hs-identifier hs-type">TooMuchIndentation</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ErrorCode -&gt; Maybe ErrorCode
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Doc ann
ErrorCode
</span><a href="Elara.Error.Codes.html#tooMuchIndentation"><span class="hs-identifier hs-var">Codes.tooMuchIndentation</span></a></span><span>
</span><span id="line-145"></span><span>    </span><span class="annot"><a href="Elara.Error.html#errorCode"><span class="hs-identifier hs-var">errorCode</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#UnterminatedStringLiteral"><span class="hs-identifier hs-type">UnterminatedStringLiteral</span></a></span><span> </span><span class="annot"><span class="annottext">ParseState
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ErrorCode -&gt; Maybe ErrorCode
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Doc ann
ErrorCode
</span><a href="Elara.Error.Codes.html#unterminatedStringLiteral"><span class="hs-identifier hs-var">Codes.unterminatedStringLiteral</span></a></span><span>
</span><span id="line-146"></span><span>    </span><span class="annot"><a href="Elara.Error.html#errorCode"><span class="hs-identifier hs-var">errorCode</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#GenericAlexError"><span class="hs-identifier hs-type">GenericAlexError</span></a></span><span> </span><span class="annot"><span class="annottext">AlexInput
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ErrorCode -&gt; Maybe ErrorCode
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Doc ann
ErrorCode
</span><a href="Elara.Error.Codes.html#genericLexicalError"><span class="hs-identifier hs-var">Codes.genericLexicalError</span></a></span><span>
</span><span id="line-147"></span><span>
</span><span id="line-148"></span><span>    </span><span id="local-6989586621680083851"><span class="annot"><span class="annottext">getReport :: LexerError -&gt; Maybe (Report (Doc AnsiStyle))
</span><a href="#local-6989586621680083851"><span class="hs-identifier hs-var hs-var hs-var">getReport</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#TooMuchIndentation"><span class="hs-identifier hs-type">TooMuchIndentation</span></a></span><span> </span><span id="local-6989586621680083853"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680083853"><span class="hs-identifier hs-var">expected</span></a></span></span><span> </span><span id="local-6989586621680083854"><span class="annot"><span class="annottext">Maybe IndentInfo
</span><a href="#local-6989586621680083854"><span class="hs-identifier hs-var">further</span></a></span></span><span> </span><span id="local-6989586621680083855"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680083855"><span class="hs-identifier hs-var">actual</span></a></span></span><span> </span><span id="local-6989586621680083856"><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680083856"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-149"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680083857"><span class="annot"><span class="annottext">fp :: FilePath
</span><a href="#local-6989586621680083857"><span class="hs-identifier hs-var hs-var hs-var">fp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Optic' A_Lens NoIx ParseState FilePath -&gt; ParseState -&gt; FilePath
forall k (is :: IxList) s a.
Is k A_Getter =&gt;
Optic' k is s a -&gt; s -&gt; a
</span><span class="hs-identifier hs-var">view</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput FilePath
-&gt; Optic' A_Lens NoIx ParseState FilePath
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput FilePath
</span><a href="Elara.Lexer.Utils.html#filePath"><span class="hs-identifier hs-var">filePath</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680083856"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-150"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680083859"><span class="annot"><span class="annottext">pos :: RealPosition
</span><a href="#local-6989586621680083859"><span class="hs-identifier hs-var hs-var hs-var">pos</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState RealPosition -&gt; ParseState -&gt; RealPosition
forall k (is :: IxList) s a.
Is k A_Getter =&gt;
Optic' k is s a -&gt; s -&gt; a
</span><span class="hs-identifier hs-var">view</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput RealPosition -&gt; Lens' ParseState RealPosition
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput RealPosition
</span><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-var">position</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680083856"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-151"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680083860"><span class="annot"><span class="annottext">msg :: Doc AnsiStyle
</span><a href="#local-6989586621680083860"><span class="hs-identifier hs-var hs-var hs-var">msg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;Unexpected change in indentation. Expected &quot;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Doc AnsiStyle
forall b a. (Show a, IsString b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680083853"><span class="hs-identifier hs-var">expected</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo Int -&gt; Int
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo Int
</span><a href="Elara.Lexer.Utils.html#indent"><span class="hs-identifier hs-var">indent</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot; spaces, but got &quot;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Doc AnsiStyle
forall b a. (Show a, IsString b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680083855"><span class="hs-identifier hs-var">actual</span></a></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot; spaces.&quot;</span></span><span>
</span><span id="line-152"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680083863"><span class="annot"><span class="annottext">hint :: Doc AnsiStyle
</span><a href="#local-6989586621680083863"><span class="hs-identifier hs-var hs-var hs-var">hint</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe IndentInfo
</span><a href="#local-6989586621680083854"><span class="hs-identifier hs-var">further</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-153"></span><span>                </span><span class="annot"><span class="annottext">Maybe IndentInfo
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;Try removing the extra indentation.&quot;</span></span><span>
</span><span id="line-154"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621680083864"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680083864"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;Try removing the extra indentation or indenting the line by &quot;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Doc AnsiStyle
forall b a. (Show a, IsString b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680083864"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo Int -&gt; Int
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo Int
</span><a href="Elara.Lexer.Utils.html#indent"><span class="hs-identifier hs-var">indent</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680083855"><span class="hs-identifier hs-var">actual</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot; space(s).&quot;</span></span><span>
</span><span id="line-155"></span><span>
</span><span id="line-156"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680083865"><span class="annot"><span class="annottext">baseHints :: [(Position, Marker (Doc AnsiStyle))]
</span><a href="#local-6989586621680083865"><span class="hs-identifier hs-var hs-var hs-var">baseHints</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-157"></span><span>                </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; RealPosition -&gt; Position
</span><a href="Elara.AST.Region.html#positionToDiagnosePosition"><span class="hs-identifier hs-var">positionToDiagnosePosition</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621680083857"><span class="hs-identifier hs-var">fp</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680083859"><span class="hs-identifier hs-var">pos</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Marker (Doc AnsiStyle)
forall msg. msg -&gt; Marker msg
</span><span class="hs-identifier hs-var">This</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;this line is indented incorrectly&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-158"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; RealPosition -&gt; Position
</span><a href="Elara.AST.Region.html#positionToDiagnosePosition"><span class="hs-identifier hs-var">positionToDiagnosePosition</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621680083857"><span class="hs-identifier hs-var">fp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680083853"><span class="hs-identifier hs-var">expected</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo RealPosition -&gt; RealPosition
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo RealPosition
</span><a href="Elara.Lexer.Utils.html#indentPos"><span class="hs-identifier hs-var">indentPos</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Marker (Doc AnsiStyle)
forall msg. msg -&gt; Marker msg
</span><span class="hs-identifier hs-var">Maybe</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;If the decrease in indentation is intentional, the problematic line should line up with this line.&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-159"></span><span>                </span><span class="hs-special">]</span><span>
</span><span id="line-160"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680083868"><span class="annot"><span class="annottext">furtherHints :: [(Position, Marker (Doc AnsiStyle))]
</span><a href="#local-6989586621680083868"><span class="hs-identifier hs-var hs-var">furtherHints</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe IndentInfo
</span><a href="#local-6989586621680083854"><span class="hs-identifier hs-var">further</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-161"></span><span>                </span><span class="annot"><span class="annottext">Maybe IndentInfo
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[(Position, Marker (Doc AnsiStyle))]
</span><a href="#local-6989586621680083865"><span class="hs-identifier hs-var">baseHints</span></a></span><span>
</span><span id="line-162"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621680083869"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680083869"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; RealPosition -&gt; Position
</span><a href="Elara.AST.Region.html#positionToDiagnosePosition"><span class="hs-identifier hs-var">positionToDiagnosePosition</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621680083857"><span class="hs-identifier hs-var">fp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680083869"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo RealPosition -&gt; RealPosition
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo RealPosition
</span><a href="Elara.Lexer.Utils.html#indentPos"><span class="hs-identifier hs-var">indentPos</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Marker (Doc AnsiStyle)
forall msg. msg -&gt; Marker msg
</span><span class="hs-identifier hs-var">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;an offside rule begins here (column &quot;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Doc AnsiStyle
forall b a. (Show a, IsString b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680083869"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo Int -&gt; Int
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo Int
</span><a href="Elara.Lexer.Utils.html#indent"><span class="hs-identifier hs-var">indent</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;). If you think the problematic line is \&quot;related\&quot; to this line, make sure they line up.&quot;</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Position, Marker (Doc AnsiStyle))
-&gt; [(Position, Marker (Doc AnsiStyle))]
-&gt; [(Position, Marker (Doc AnsiStyle))]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[(Position, Marker (Doc AnsiStyle))]
</span><a href="#local-6989586621680083865"><span class="hs-identifier hs-var">baseHints</span></a></span><span>
</span><span id="line-163"></span><span>
</span><span id="line-164"></span><span>        </span><span class="annot"><span class="annottext">Report (Doc AnsiStyle) -&gt; Maybe (Report (Doc AnsiStyle))
forall a. a -&gt; Maybe a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(Report (Doc AnsiStyle) -&gt; Maybe (Report (Doc AnsiStyle)))
-&gt; Report (Doc AnsiStyle) -&gt; Maybe (Report (Doc AnsiStyle))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-165"></span><span>            </span><span class="annot"><span class="annottext">Maybe (Doc AnsiStyle)
-&gt; Doc AnsiStyle
-&gt; [(Position, Marker (Doc AnsiStyle))]
-&gt; [Note (Doc AnsiStyle)]
-&gt; Report (Doc AnsiStyle)
forall msg.
Maybe msg
-&gt; msg -&gt; [(Position, Marker msg)] -&gt; [Note msg] -&gt; Report msg
</span><span class="hs-identifier hs-var">Err</span></span><span>
</span><span id="line-166"></span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Maybe (Doc AnsiStyle)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
ErrorCode
</span><a href="Elara.Error.Codes.html#tooMuchIndentation"><span class="hs-identifier hs-var">Codes.tooMuchIndentation</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-167"></span><span>                </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><a href="#local-6989586621680083860"><span class="hs-identifier hs-var">msg</span></a></span><span>
</span><span id="line-168"></span><span>                </span><span class="annot"><span class="annottext">[(Position, Marker (Doc AnsiStyle))]
</span><a href="#local-6989586621680083868"><span class="hs-identifier hs-var">furtherHints</span></a></span><span>
</span><span id="line-169"></span><span>                </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Note (Doc AnsiStyle)
forall msg. msg -&gt; Note msg
</span><span class="hs-identifier hs-var">Note</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;When using lightweight syntax, the level of indentation is very important. Currently, I can't tell what expression this line is supposed to be a part of as it doesn't line up with anything, and didn't appear in a place where indentation can begin.&quot;</span></span><span>
</span><span id="line-170"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Note (Doc AnsiStyle)
forall msg. msg -&gt; Note msg
</span><span class="hs-identifier hs-var">Hint</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><a href="#local-6989586621680083863"><span class="hs-identifier hs-var">hint</span></a></span><span>
</span><span id="line-171"></span><span>                </span><span class="hs-special">]</span><span>
</span><span id="line-172"></span><span>    </span><span class="annot"><a href="Elara.Error.html#getReport"><span class="hs-identifier hs-var">getReport</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#GenericAlexError"><span class="hs-identifier hs-type">GenericAlexError</span></a></span><span> </span><span id="local-6989586621680083872"><span class="annot"><span class="annottext">AlexInput
</span><a href="#local-6989586621680083872"><span class="hs-identifier hs-var">ai</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-173"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680083873"><span class="annot"><span class="annottext">fp :: FilePath
</span><a href="#local-6989586621680083873"><span class="hs-identifier hs-var hs-var hs-var">fp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput FilePath -&gt; AlexInput -&gt; FilePath
forall k (is :: IxList) s a.
Is k A_Getter =&gt;
Optic' k is s a -&gt; s -&gt; a
</span><span class="hs-identifier hs-var">view</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput FilePath
</span><a href="Elara.Lexer.Utils.html#filePath"><span class="hs-identifier hs-var">filePath</span></a></span><span> </span><span class="annot"><span class="annottext">AlexInput
</span><a href="#local-6989586621680083872"><span class="hs-identifier hs-var">ai</span></a></span><span>
</span><span id="line-174"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680083874"><span class="annot"><span class="annottext">pos :: RealPosition
</span><a href="#local-6989586621680083874"><span class="hs-identifier hs-var hs-var hs-var">pos</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput RealPosition -&gt; AlexInput -&gt; RealPosition
forall k (is :: IxList) s a.
Is k A_Getter =&gt;
Optic' k is s a -&gt; s -&gt; a
</span><span class="hs-identifier hs-var">view</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput RealPosition
</span><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-var">position</span></a></span><span> </span><span class="annot"><span class="annottext">AlexInput
</span><a href="#local-6989586621680083872"><span class="hs-identifier hs-var">ai</span></a></span><span>
</span><span id="line-175"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680083876"><span class="annot"><span class="annottext">msg :: Doc AnsiStyle
</span><a href="#local-6989586621680083876"><span class="hs-identifier hs-var hs-var">msg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;Lexical error&quot;</span></span><span>
</span><span id="line-176"></span><span>
</span><span id="line-177"></span><span>        </span><span class="annot"><span class="annottext">Report (Doc AnsiStyle) -&gt; Maybe (Report (Doc AnsiStyle))
forall a. a -&gt; Maybe a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(Report (Doc AnsiStyle) -&gt; Maybe (Report (Doc AnsiStyle)))
-&gt; Report (Doc AnsiStyle) -&gt; Maybe (Report (Doc AnsiStyle))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-178"></span><span>            </span><span class="annot"><span class="annottext">Maybe (Doc AnsiStyle)
-&gt; Doc AnsiStyle
-&gt; [(Position, Marker (Doc AnsiStyle))]
-&gt; [Note (Doc AnsiStyle)]
-&gt; Report (Doc AnsiStyle)
forall msg.
Maybe msg
-&gt; msg -&gt; [(Position, Marker msg)] -&gt; [Note msg] -&gt; Report msg
</span><span class="hs-identifier hs-var">Err</span></span><span>
</span><span id="line-179"></span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Maybe (Doc AnsiStyle)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
ErrorCode
</span><a href="Elara.Error.Codes.html#genericLexicalError"><span class="hs-identifier hs-var">Codes.genericLexicalError</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-180"></span><span>                </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><a href="#local-6989586621680083876"><span class="hs-identifier hs-var">msg</span></a></span><span>
</span><span id="line-181"></span><span>                </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; RealPosition -&gt; Position
</span><a href="Elara.AST.Region.html#positionToDiagnosePosition"><span class="hs-identifier hs-var">positionToDiagnosePosition</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621680083873"><span class="hs-identifier hs-var">fp</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680083874"><span class="hs-identifier hs-var">pos</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Marker (Doc AnsiStyle)
forall msg. msg -&gt; Marker msg
</span><span class="hs-identifier hs-var">This</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;lexical error occurred here&quot;</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-182"></span><span>                </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Note (Doc AnsiStyle)
forall msg. msg -&gt; Note msg
</span><span class="hs-identifier hs-var">Note</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;The lexer encountered an invalid character or sequence of characters that it could not process.&quot;</span></span><span>
</span><span id="line-183"></span><span>                </span><span class="hs-special">]</span><span>
</span><span id="line-184"></span><span>    </span><span class="annot"><a href="Elara.Error.html#getReport"><span class="hs-identifier hs-var">getReport</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#UnterminatedStringLiteral"><span class="hs-identifier hs-type">UnterminatedStringLiteral</span></a></span><span> </span><span id="local-6989586621680083877"><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680083877"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-185"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680083878"><span class="annot"><span class="annottext">fp :: FilePath
</span><a href="#local-6989586621680083878"><span class="hs-identifier hs-var hs-var hs-var">fp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Optic' A_Lens NoIx ParseState FilePath -&gt; ParseState -&gt; FilePath
forall k (is :: IxList) s a.
Is k A_Getter =&gt;
Optic' k is s a -&gt; s -&gt; a
</span><span class="hs-identifier hs-var">view</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput FilePath
-&gt; Optic' A_Lens NoIx ParseState FilePath
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput FilePath
</span><a href="Elara.Lexer.Utils.html#filePath"><span class="hs-identifier hs-var">filePath</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680083877"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-186"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680083879"><span class="annot"><span class="annottext">pos :: RealPosition
</span><a href="#local-6989586621680083879"><span class="hs-identifier hs-var hs-var hs-var">pos</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState RealPosition -&gt; ParseState -&gt; RealPosition
forall k (is :: IxList) s a.
Is k A_Getter =&gt;
Optic' k is s a -&gt; s -&gt; a
</span><span class="hs-identifier hs-var">view</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput RealPosition -&gt; Lens' ParseState RealPosition
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput RealPosition
</span><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-var">position</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680083877"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-187"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680083881"><span class="annot"><span class="annottext">msg :: Doc AnsiStyle
</span><a href="#local-6989586621680083881"><span class="hs-identifier hs-var hs-var hs-var">msg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;Unterminated string literal.&quot;</span></span><span>
</span><span id="line-188"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680083883"><span class="annot"><span class="annottext">hint :: Doc AnsiStyle
</span><a href="#local-6989586621680083883"><span class="hs-identifier hs-var hs-var">hint</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;Make sure that the string literal is terminated with a double quote (\&quot;).&quot;</span></span><span>
</span><span id="line-189"></span><span>        </span><span class="annot"><span class="annottext">Report (Doc AnsiStyle) -&gt; Maybe (Report (Doc AnsiStyle))
forall a. a -&gt; Maybe a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(Report (Doc AnsiStyle) -&gt; Maybe (Report (Doc AnsiStyle)))
-&gt; Report (Doc AnsiStyle) -&gt; Maybe (Report (Doc AnsiStyle))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-190"></span><span>            </span><span class="annot"><span class="annottext">Maybe (Doc AnsiStyle)
-&gt; Doc AnsiStyle
-&gt; [(Position, Marker (Doc AnsiStyle))]
-&gt; [Note (Doc AnsiStyle)]
-&gt; Report (Doc AnsiStyle)
forall msg.
Maybe msg
-&gt; msg -&gt; [(Position, Marker msg)] -&gt; [Note msg] -&gt; Report msg
</span><span class="hs-identifier hs-var">Err</span></span><span>
</span><span id="line-191"></span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Maybe (Doc AnsiStyle)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
ErrorCode
</span><a href="Elara.Error.Codes.html#unterminatedStringLiteral"><span class="hs-identifier hs-var">Codes.unterminatedStringLiteral</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-192"></span><span>                </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><a href="#local-6989586621680083881"><span class="hs-identifier hs-var">msg</span></a></span><span>
</span><span id="line-193"></span><span>                </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; RealPosition -&gt; Position
</span><a href="Elara.AST.Region.html#positionToDiagnosePosition"><span class="hs-identifier hs-var">positionToDiagnosePosition</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621680083878"><span class="hs-identifier hs-var">fp</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680083879"><span class="hs-identifier hs-var">pos</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Marker (Doc AnsiStyle)
forall msg. msg -&gt; Marker msg
</span><span class="hs-identifier hs-var">This</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;this string literal is unterminated&quot;</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-194"></span><span>                </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Note (Doc AnsiStyle)
forall msg. msg -&gt; Note msg
</span><span class="hs-identifier hs-var">Note</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;String literals are delimited by double quotes (\&quot;).&quot;</span></span><span>
</span><span id="line-195"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Note (Doc AnsiStyle)
forall msg. msg -&gt; Note msg
</span><span class="hs-identifier hs-var">Hint</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><a href="#local-6989586621680083883"><span class="hs-identifier hs-var">hint</span></a></span><span>
</span><span id="line-196"></span><span>                </span><span class="hs-special">]</span><span>
</span><span id="line-197"></span><span>
</span><span id="line-198"></span><span class="annot"><a href="Elara.Lexer.Utils.html#initialLexState"><span class="hs-identifier hs-type">initialLexState</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-type">ParseState</span></a></span><span>
</span><span id="line-199"></span><span id="initialLexState"><span class="annot"><span class="annottext">initialLexState :: FilePath -&gt; Text -&gt; ParseState
</span><a href="Elara.Lexer.Utils.html#initialLexState"><span class="hs-identifier hs-var hs-var">initialLexState</span></a></span></span><span> </span><span id="local-6989586621680083894"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621680083894"><span class="hs-identifier hs-var">fp</span></a></span></span><span> </span><span id="local-6989586621680083895"><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680083895"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-200"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-type">ParseState</span></a></span><span>
</span><span id="line-201"></span><span>        </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">_input :: AlexInput
</span><a href="Elara.Lexer.Utils.html#_input"><span class="hs-identifier hs-var">_input</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-202"></span><span>            </span><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-type">AlexInput</span></a></span><span>
</span><span id="line-203"></span><span>                </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">_filePath :: FilePath
</span><a href="Elara.Lexer.Utils.html#_filePath"><span class="hs-identifier hs-var">_filePath</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621680083894"><span class="hs-identifier hs-var">fp</span></a></span><span>
</span><span id="line-204"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_prev :: Char
</span><a href="Elara.Lexer.Utils.html#_prev"><span class="hs-identifier hs-var">_prev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'\n'</span></span><span>
</span><span id="line-205"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_bytes :: [Word8]
</span><a href="Elara.Lexer.Utils.html#_bytes"><span class="hs-identifier hs-var">_bytes</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-206"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_rest :: Text
</span><a href="Elara.Lexer.Utils.html#_rest"><span class="hs-identifier hs-var">_rest</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680083895"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-207"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_position :: RealPosition
</span><a href="Elara.Lexer.Utils.html#_position"><span class="hs-identifier hs-var">_position</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; RealPosition
</span><a href="Elara.AST.Region.html#Position"><span class="hs-identifier hs-var">Position</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-208"></span><span>                </span><span class="hs-special">}</span><span>
</span><span id="line-209"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_lexSC :: Int
</span><a href="Elara.Lexer.Utils.html#_lexSC"><span class="hs-identifier hs-var">_lexSC</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-210"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_stringBuf :: Text
</span><a href="Elara.Lexer.Utils.html#_stringBuf"><span class="hs-identifier hs-var">_stringBuf</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;&quot;</span></span><span>
</span><span id="line-211"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_pendingTokens :: [Lexeme]
</span><a href="Elara.Lexer.Utils.html#_pendingTokens"><span class="hs-identifier hs-var">_pendingTokens</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-212"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_indentStack :: NonEmpty IndentInfo
</span><a href="Elara.Lexer.Utils.html#_indentStack"><span class="hs-identifier hs-var">_indentStack</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-213"></span><span>            </span><span class="annot"><span class="annottext">Int -&gt; RealPosition -&gt; Int -&gt; IndentInfo
</span><a href="Elara.Lexer.Utils.html#IndentInfo"><span class="hs-identifier hs-var">IndentInfo</span></a></span><span>
</span><span id="line-214"></span><span>                </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-215"></span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; RealPosition
</span><a href="Elara.AST.Region.html#Position"><span class="hs-identifier hs-var">Position</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-216"></span><span>                </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-217"></span><span>                </span><span class="annot"><span class="annottext">IndentInfo -&gt; [IndentInfo] -&gt; NonEmpty IndentInfo
forall a. a -&gt; [a] -&gt; NonEmpty a
</span><span class="hs-operator hs-var">:|</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-218"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_pendingPosition :: RealPosition
</span><a href="Elara.Lexer.Utils.html#_pendingPosition"><span class="hs-identifier hs-var">_pendingPosition</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; RealPosition
</span><a href="Elara.AST.Region.html#Position"><span class="hs-identifier hs-var">Position</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-219"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_prevEndsExpr :: Bool
</span><a href="Elara.Lexer.Utils.html#_prevEndsExpr"><span class="hs-identifier hs-var">_prevEndsExpr</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-220"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_delimDepth :: Int
</span><a href="Elara.Lexer.Utils.html#_delimDepth"><span class="hs-identifier hs-var">_delimDepth</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-221"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_commentDepth :: Int
</span><a href="Elara.Lexer.Utils.html#_commentDepth"><span class="hs-identifier hs-var">_commentDepth</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-222"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">_layoutExpected :: Maybe LayoutExpectation
</span><a href="Elara.Lexer.Utils.html#_layoutExpected"><span class="hs-identifier hs-var">_layoutExpected</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe LayoutExpectation
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-223"></span><span>        </span><span class="hs-special">}</span><span>
</span><span id="line-224"></span><span>
</span><span id="line-225"></span><span class="annot"><a href="Elara.Lexer.Utils.html#pushFront"><span class="hs-identifier hs-type">pushFront</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-226"></span><span id="pushFront"><span class="annot"><span class="annottext">pushFront :: Lexeme -&gt; LexMonad ()
</span><a href="Elara.Lexer.Utils.html#pushFront"><span class="hs-identifier hs-var hs-var">pushFront</span></a></span></span><span> </span><span id="local-6989586621680083904"><span class="annot"><span class="annottext">Lexeme
</span><a href="#local-6989586621680083904"><span class="hs-identifier hs-var">lex</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(ParseState -&gt; ParseState) -&gt; LexMonad ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
(s -&gt; s) -&gt; Eff es ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState [Lexeme]
-&gt; ([Lexeme] -&gt; [Lexeme]) -&gt; ParseState -&gt; ParseState
forall k (is :: IxList) s t a b.
Is k A_Setter =&gt;
Optic k is s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
</span><span class="hs-identifier hs-var">over</span></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState [Lexeme]
</span><a href="Elara.Lexer.Utils.html#pendingTokens"><span class="hs-identifier hs-var">pendingTokens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lexeme
</span><a href="#local-6989586621680083904"><span class="hs-identifier hs-var">lex</span></a></span><span> </span><span class="annot"><span class="annottext">Lexeme -&gt; [Lexeme] -&gt; [Lexeme]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-227"></span><span>
</span><span id="line-228"></span><span class="annot"><a href="Elara.Lexer.Utils.html#pushBack"><span class="hs-identifier hs-type">pushBack</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-229"></span><span id="pushBack"><span class="annot"><span class="annottext">pushBack :: Lexeme -&gt; LexMonad ()
</span><a href="Elara.Lexer.Utils.html#pushBack"><span class="hs-identifier hs-var hs-var">pushBack</span></a></span></span><span> </span><span id="local-6989586621680083913"><span class="annot"><span class="annottext">Lexeme
</span><a href="#local-6989586621680083913"><span class="hs-identifier hs-var">lex</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(ParseState -&gt; ParseState) -&gt; LexMonad ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
(s -&gt; s) -&gt; Eff es ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState [Lexeme]
-&gt; ([Lexeme] -&gt; [Lexeme]) -&gt; ParseState -&gt; ParseState
forall k (is :: IxList) s t a b.
Is k A_Setter =&gt;
Optic k is s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
</span><span class="hs-identifier hs-var">over</span></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState [Lexeme]
</span><a href="Elara.Lexer.Utils.html#pendingTokens"><span class="hs-identifier hs-var">pendingTokens</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680083914"><span class="annot"><span class="annottext">[Lexeme]
</span><a href="#local-6989586621680083914"><span class="hs-identifier hs-var">toks</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Lexeme]
</span><a href="#local-6989586621680083914"><span class="hs-identifier hs-var">toks</span></a></span><span> </span><span class="annot"><span class="annottext">[Lexeme] -&gt; [Lexeme] -&gt; [Lexeme]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Lexeme
</span><a href="#local-6989586621680083913"><span class="hs-identifier hs-var">lex</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-230"></span><span>
</span><span id="line-231"></span><span class="annot"><a href="Elara.Lexer.Utils.html#triggerIndentLayout"><span class="hs-identifier hs-type">triggerIndentLayout</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-232"></span><span id="triggerIndentLayout"><span class="annot"><span class="annottext">triggerIndentLayout :: LexMonad ()
</span><a href="Elara.Lexer.Utils.html#triggerIndentLayout"><span class="hs-identifier hs-var hs-var">triggerIndentLayout</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-233"></span><span>    </span><span class="annot"><span class="annottext">Lens' ParseState (Maybe LayoutExpectation)
</span><a href="Elara.Lexer.Utils.html#layoutExpected"><span class="hs-identifier hs-var">layoutExpected</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (Maybe LayoutExpectation)
-&gt; Maybe LayoutExpectation -&gt; LexMonad ()
forall k s (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) a b.
(Is k A_Setter, State s :&gt; r) =&gt;
Optic k is s s a b -&gt; b -&gt; Eff r ()
</span><a href="Effectful.State.Extra.html#.%3D"><span class="hs-operator hs-var">.=</span></a></span><span> </span><span class="annot"><span class="annottext">LayoutExpectation -&gt; Maybe LayoutExpectation
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">LayoutExpectation
</span><a href="Elara.Lexer.Utils.html#ExpectIndent"><span class="hs-identifier hs-var">ExpectIndent</span></a></span><span>
</span><span id="line-234"></span><span>
</span><span id="line-235"></span><span class="annot"><a href="Elara.Lexer.Utils.html#triggerBlockLayout"><span class="hs-identifier hs-type">triggerBlockLayout</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-236"></span><span id="triggerBlockLayout"><span class="annot"><span class="annottext">triggerBlockLayout :: LexMonad ()
</span><a href="Elara.Lexer.Utils.html#triggerBlockLayout"><span class="hs-identifier hs-var hs-var">triggerBlockLayout</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (Maybe LayoutExpectation)
</span><a href="Elara.Lexer.Utils.html#layoutExpected"><span class="hs-identifier hs-var">layoutExpected</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (Maybe LayoutExpectation)
-&gt; Maybe LayoutExpectation -&gt; LexMonad ()
forall k s (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) a b.
(Is k A_Setter, State s :&gt; r) =&gt;
Optic k is s s a b -&gt; b -&gt; Eff r ()
</span><a href="Effectful.State.Extra.html#.%3D"><span class="hs-operator hs-var">.=</span></a></span><span> </span><span class="annot"><span class="annottext">LayoutExpectation -&gt; Maybe LayoutExpectation
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">LayoutExpectation
</span><a href="Elara.Lexer.Utils.html#ExpectBlock"><span class="hs-identifier hs-var">ExpectBlock</span></a></span><span>
</span><span id="line-237"></span><span>
</span><span id="line-238"></span><span class="annot"><span class="hs-comment">{- | If a (block) layout is expected, check the current token's indentation against the top of the stack,
and insert an INDENT token if necessary
-}</span></span><span>
</span><span id="line-241"></span><span class="annot"><a href="Elara.Lexer.Utils.html#checkBlockLayout"><span class="hs-identifier hs-type">checkBlockLayout</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-242"></span><span id="checkBlockLayout"><span class="annot"><span class="annottext">checkBlockLayout :: Int -&gt; LexMonad ()
</span><a href="Elara.Lexer.Utils.html#checkBlockLayout"><span class="hs-identifier hs-var hs-var">checkBlockLayout</span></a></span></span><span> </span><span id="local-6989586621680083934"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680083934"><span class="hs-identifier hs-var">tokenLen</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-243"></span><span>    </span><span id="local-6989586621680083935"><span class="annot"><a href="#local-6989586621680083935"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (Maybe LayoutExpectation)
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug]
     (Maybe LayoutExpectation)
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (Maybe LayoutExpectation)
</span><a href="Elara.Lexer.Utils.html#layoutExpected"><span class="hs-identifier hs-var">layoutExpected</span></a></span><span>
</span><span id="line-244"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621680083935"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-245"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">LayoutExpectation
</span><a href="Elara.Lexer.Utils.html#ExpectBlock"><span class="hs-identifier hs-var">ExpectBlock</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-246"></span><span>            </span><span id="local-6989586621680083936"><span class="annot"><a href="#local-6989586621680083936"><span class="hs-identifier hs-var">pos</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Position"><span class="hs-identifier hs-type">Position</span></a></span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680083937"><span class="annot"><a href="#local-6989586621680083937"><span class="hs-identifier hs-var">col</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Int
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] RealPosition
</span><a href="Elara.Lexer.Utils.html#getPosition"><span class="hs-identifier hs-var">getPosition</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680083934"><span class="hs-identifier hs-var">tokenLen</span></a></span><span>
</span><span id="line-247"></span><span>
</span><span id="line-248"></span><span>            </span><span id="local-6989586621680083938"><span class="annot"><a href="#local-6989586621680083938"><span class="hs-identifier hs-var">indentInfo</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#mkIndentInfo"><span class="hs-identifier hs-type">mkIndentInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680083937"><span class="hs-identifier hs-type">col</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">-</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-249"></span><span>            </span><span class="annot"><a href="Elara.Lexer.Utils.html#indentStack"><span class="hs-identifier hs-type">indentStack</span></a></span><span> </span><span class="annot"><a href="Effectful.State.Extra.html#%25%3D"><span class="hs-operator hs-type">%=</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">indentInfo</span></span><span> </span><span class="annot"><span class="hs-operator">&lt;|</span></span><span class="hs-special">)</span><span>
</span><span id="line-250"></span><span>
</span><span id="line-251"></span><span>            </span><span class="hs-comment">-- push a virtual indent token before the current token</span><span>
</span><span id="line-252"></span><span>            </span><span id="local-6989586621680083939"><span class="annot"><a href="#local-6989586621680083939"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#createRegion"><span class="hs-identifier hs-type">createRegion</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680083936"><span class="hs-identifier hs-type">pos</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680083936"><span class="hs-identifier hs-type">pos</span></a></span><span>
</span><span id="line-253"></span><span>            </span><span class="annot"><a href="Elara.Lexer.Utils.html#pushFront"><span class="hs-identifier hs-type">pushFront</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#RealSourceRegion"><span class="hs-identifier hs-type">RealSourceRegion</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680083939"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokenIndent"><span class="hs-identifier hs-type">TokenIndent</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-254"></span><span>
</span><span id="line-255"></span><span>            </span><span class="hs-comment">-- reset</span><span>
</span><span id="line-256"></span><span>            </span><span class="annot"><a href="Elara.Lexer.Utils.html#layoutExpected"><span class="hs-identifier hs-type">layoutExpected</span></a></span><span> </span><span class="annot"><a href="Effectful.State.Extra.html#.%3D"><span class="hs-operator hs-type">.=</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span>
</span><span id="line-257"></span><span>        </span><span class="annot"><span class="annottext">Maybe LayoutExpectation
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LexMonad ()
forall (f :: * -&gt; *). Applicative f =&gt; f ()
</span><span class="hs-identifier hs-var">pass</span></span><span>
</span><span id="line-258"></span><span>
</span><span id="line-259"></span><span class="hs-comment">-- Emits a token, updating the prevEndsExpr state if necessary</span><span>
</span><span id="line-260"></span><span class="annot"><a href="Elara.Lexer.Utils.html#emitAt"><span class="hs-identifier hs-type">emitAt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Token"><span class="hs-identifier hs-type">Token</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#SourceRegion"><span class="hs-identifier hs-type">SourceRegion</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-261"></span><span id="emitAt"><span class="annot"><span class="annottext">emitAt :: Token -&gt; SourceRegion -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitAt"><span class="hs-identifier hs-var hs-var">emitAt</span></a></span></span><span> </span><span id="local-6989586621680083964"><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680083964"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621680083965"><span class="annot"><span class="annottext">SourceRegion
</span><a href="#local-6989586621680083965"><span class="hs-identifier hs-var">region</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-262"></span><span>    </span><span class="annot"><span class="annottext">Lens' ParseState (Maybe LayoutExpectation)
</span><a href="Elara.Lexer.Utils.html#layoutExpected"><span class="hs-identifier hs-var">layoutExpected</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (Maybe LayoutExpectation)
-&gt; Maybe LayoutExpectation -&gt; LexMonad ()
forall k s (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) a b.
(Is k A_Setter, State s :&gt; r) =&gt;
Optic k is s s a b -&gt; b -&gt; Eff r ()
</span><a href="Effectful.State.Extra.html#.%3D"><span class="hs-operator hs-var">.=</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe LayoutExpectation
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-comment">-- reset layout expectation</span><span>
</span><span id="line-263"></span><span>    </span><span id="local-6989586621680083966"><span class="annot"><a href="#local-6989586621680083966"><span class="hs-identifier hs-var">prevEnds</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">LexMonad Bool
</span><a href="Elara.Lexer.Utils.html#getPrevEndsExpr"><span class="hs-identifier hs-var">getPrevEndsExpr</span></a></span><span>
</span><span id="line-264"></span><span>    </span><span class="hs-comment">-- Suppress LINESEP if previous token cannot end an expression</span><span>
</span><span id="line-265"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621680083964"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-266"></span><span>        </span><span class="annot"><span class="annottext">Token
</span><a href="Elara.Lexer.Token.html#TokenLeftParen"><span class="hs-identifier hs-var">TokenLeftParen</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="Elara.Lexer.Token.html#TokenLeftBracket"><span class="hs-identifier hs-var">TokenLeftBracket</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="Elara.Lexer.Token.html#TokenLeftBrace"><span class="hs-identifier hs-var">TokenLeftBrace</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(ParseState -&gt; ParseState) -&gt; LexMonad ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
(s -&gt; s) -&gt; Eff es ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState Int
</span><a href="Elara.Lexer.Utils.html#delimDepth"><span class="hs-identifier hs-var">delimDepth</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState Int -&gt; (Int -&gt; Int) -&gt; ParseState -&gt; ParseState
forall k (is :: IxList) s t a b.
Is k A_Setter =&gt;
Optic k is s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
</span><span class="hs-operator hs-var">%~</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">LexMonad () -&gt; LexMonad (Maybe Lexeme) -&gt; LexMonad (Maybe Lexeme)
forall a b.
Eff '[State ParseState, Error LexerError, StructuredDebug] a
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] b
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">LexMonad (Maybe Lexeme)
</span><a href="#local-6989586621680083972"><span class="hs-identifier hs-var">emit</span></a></span><span>
</span><span id="line-267"></span><span>        </span><span class="annot"><span class="annottext">Token
</span><a href="Elara.Lexer.Token.html#TokenRightParen"><span class="hs-identifier hs-var">TokenRightParen</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="Elara.Lexer.Token.html#TokenRightBracket"><span class="hs-identifier hs-var">TokenRightBracket</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="Elara.Lexer.Token.html#TokenRightBrace"><span class="hs-identifier hs-var">TokenRightBrace</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Token -&gt; SourceRegion -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitCloser"><span class="hs-identifier hs-var">emitCloser</span></a></span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680083964"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><a href="#local-6989586621680083965"><span class="hs-identifier hs-var">region</span></a></span><span>
</span><span id="line-268"></span><span>        </span><span class="annot"><span class="annottext">Token
</span><a href="Elara.Lexer.Token.html#TokenLineSeparator"><span class="hs-identifier hs-var">TokenLineSeparator</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621680083966"><span class="hs-identifier hs-var">prevEnds</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-269"></span><span>            </span><span class="annot"><span class="annottext">Maybe Lexeme -&gt; LexMonad (Maybe Lexeme)
forall a.
a -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-270"></span><span>        </span><span class="annot"><span class="annottext">Token
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LexMonad (Maybe Lexeme)
</span><a href="#local-6989586621680083972"><span class="hs-identifier hs-var">emit</span></a></span><span>
</span><span id="line-271"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-272"></span><span>    </span><span id="local-6989586621680083972"><span class="annot"><span class="annottext">emit :: LexMonad (Maybe Lexeme)
</span><a href="#local-6989586621680083972"><span class="hs-identifier hs-var hs-var">emit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-273"></span><span>        </span><span class="annot"><span class="annottext">Bool -&gt; LexMonad ()
</span><a href="Elara.Lexer.Utils.html#setPrevEndsExpr"><span class="hs-identifier hs-var">setPrevEndsExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Token -&gt; Bool
</span><a href="Elara.Lexer.Token.html#tokenEndsExpr"><span class="hs-identifier hs-var">tokenEndsExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680083964"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-274"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680083979"><span class="annot"><span class="annottext">lex :: Lexeme
</span><a href="#local-6989586621680083979"><span class="hs-identifier hs-var hs-var hs-var">lex</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SourceRegion -&gt; Token -&gt; Lexeme
forall a. SourceRegion -&gt; a -&gt; Located a
</span><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-var">Located</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><a href="#local-6989586621680083965"><span class="hs-identifier hs-var">region</span></a></span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680083964"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-275"></span><span>        </span><span id="local-6989586621680083980"><span class="annot"><a href="#local-6989586621680083980"><span class="hs-identifier hs-var">pending</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState [Lexeme]
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] [Lexeme]
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState [Lexeme]
</span><a href="Elara.Lexer.Utils.html#pendingTokens"><span class="hs-identifier hs-var">pendingTokens</span></a></span><span>
</span><span id="line-276"></span><span>        </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="hs-identifier hs-type">null</span></span><span> </span><span class="annot"><a href="#local-6989586621680083980"><span class="hs-identifier hs-type">pending</span></a></span><span>
</span><span id="line-277"></span><span>            </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><a href="#local-6989586621680083979"><span class="hs-identifier hs-type">lex</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-278"></span><span>            </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-279"></span><span>                </span><span class="annot"><a href="Elara.Lexer.Utils.html#pushBack"><span class="hs-identifier hs-type">pushBack</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680083979"><span class="hs-identifier hs-type">lex</span></a></span><span>
</span><span id="line-280"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span>
</span><span id="line-281"></span><span>
</span><span id="line-282"></span><span class="annot"><a href="Elara.Lexer.Utils.html#popPending"><span class="hs-identifier hs-type">popPending</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-283"></span><span id="popPending"><span class="annot"><span class="annottext">popPending :: LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#popPending"><span class="hs-identifier hs-var hs-var">popPending</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-284"></span><span>    </span><span id="local-6989586621680083993"><span class="annot"><a href="#local-6989586621680083993"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Eff
  '[State ParseState, Error LexerError, StructuredDebug] ParseState
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
Eff es s
</span><span class="hs-identifier hs-var">get</span></span><span>
</span><span id="line-285"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#_pendingTokens"><span class="hs-identifier hs-var">_pendingTokens</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680083993"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-286"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621680083995"><span class="annot"><span class="annottext">Lexeme
</span><a href="#local-6989586621680083995"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621680083996"><span class="annot"><span class="annottext">[Lexeme]
</span><a href="#local-6989586621680083996"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ParseState -&gt; LexMonad ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
s -&gt; Eff es ()
</span><span class="hs-identifier hs-var">put</span></span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680083993"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.Lexer.Utils.html#_pendingTokens"><span class="hs-identifier hs-var">_pendingTokens</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680083996"><span class="hs-identifier hs-type">xs</span></a></span><span class="hs-special">}</span><span> </span><span class="annot"><span class="annottext">LexMonad () -&gt; LexMonad (Maybe Lexeme) -&gt; LexMonad (Maybe Lexeme)
forall a b.
Eff '[State ParseState, Error LexerError, StructuredDebug] a
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] b
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme -&gt; LexMonad (Maybe Lexeme)
forall a.
a -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lexeme -&gt; Maybe Lexeme
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Lexeme
</span><a href="#local-6989586621680083995"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-287"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme -&gt; LexMonad (Maybe Lexeme)
forall a.
a -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-288"></span><span>
</span><span id="line-289"></span><span class="annot"><span class="hs-comment">{- | Emit DEDENTs for layout opened inside current delimiter depth, then the closer.
Return the first pending token (typically a DEDENT) so stream becomes &quot;&#8230; &lt;DEDENT&gt; ) &#8230;&quot;
-}</span></span><span>
</span><span id="line-292"></span><span class="annot"><a href="Elara.Lexer.Utils.html#emitCloser"><span class="hs-identifier hs-type">emitCloser</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Token"><span class="hs-identifier hs-type">Token</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#SourceRegion"><span class="hs-identifier hs-type">SourceRegion</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-293"></span><span id="emitCloser"><span class="annot"><span class="annottext">emitCloser :: Token -&gt; SourceRegion -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitCloser"><span class="hs-identifier hs-var hs-var">emitCloser</span></a></span></span><span> </span><span id="local-6989586621680084012"><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680084012"><span class="hs-identifier hs-var">closerTok</span></a></span></span><span> </span><span id="local-6989586621680084013"><span class="annot"><span class="annottext">SourceRegion
</span><a href="#local-6989586621680084013"><span class="hs-identifier hs-var">closerReg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-294"></span><span>    </span><span class="annot"><span class="annottext">LexMonad ()
</span><a href="Elara.Lexer.Utils.html#flushLayoutBeforeCloser"><span class="hs-identifier hs-var">flushLayoutBeforeCloser</span></a></span><span>
</span><span id="line-295"></span><span>    </span><span class="annot"><span class="annottext">(ParseState -&gt; ParseState) -&gt; LexMonad ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
(s -&gt; s) -&gt; Eff es ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState Int
</span><a href="Elara.Lexer.Utils.html#delimDepth"><span class="hs-identifier hs-var">delimDepth</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState Int -&gt; (Int -&gt; Int) -&gt; ParseState -&gt; ParseState
forall k (is :: IxList) s t a b.
Is k A_Setter =&gt;
Optic k is s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
</span><span class="hs-operator hs-var">%~</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680084015"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680084015"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Ord a =&gt; a -&gt; a -&gt; a
</span><span class="hs-identifier hs-var">max</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680084015"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-296"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680084017"><span class="annot"><span class="annottext">closerLex :: Lexeme
</span><a href="#local-6989586621680084017"><span class="hs-identifier hs-var hs-var hs-var">closerLex</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SourceRegion -&gt; Token -&gt; Lexeme
forall a. SourceRegion -&gt; a -&gt; Located a
</span><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-var">Located</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><a href="#local-6989586621680084013"><span class="hs-identifier hs-var">closerReg</span></a></span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680084012"><span class="hs-identifier hs-var">closerTok</span></a></span><span>
</span><span id="line-297"></span><span>    </span><span class="annot"><span class="annottext">Lexeme -&gt; LexMonad ()
</span><a href="Elara.Lexer.Utils.html#pushBack"><span class="hs-identifier hs-var">pushBack</span></a></span><span> </span><span class="annot"><span class="annottext">Lexeme
</span><a href="#local-6989586621680084017"><span class="hs-identifier hs-var">closerLex</span></a></span><span>
</span><span id="line-298"></span><span>    </span><span id="local-6989586621680084018"><span class="annot"><a href="#local-6989586621680084018"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#popPending"><span class="hs-identifier hs-var">popPending</span></a></span><span>
</span><span id="line-299"></span><span>    </span><span class="hs-comment">-- keep prevEndsExpr consistent</span><span>
</span><span id="line-300"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621680084018"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-301"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680084019"><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680084019"><span class="hs-identifier hs-var">tok</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; LexMonad ()
</span><a href="Elara.Lexer.Utils.html#setPrevEndsExpr"><span class="hs-identifier hs-var">setPrevEndsExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Token -&gt; Bool
</span><a href="Elara.Lexer.Token.html#tokenEndsExpr"><span class="hs-identifier hs-var">tokenEndsExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680084019"><span class="hs-identifier hs-var">tok</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-302"></span><span>        </span><span class="annot"><span class="annottext">Maybe Lexeme
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; LexMonad ()
</span><a href="Elara.Lexer.Utils.html#setPrevEndsExpr"><span class="hs-identifier hs-var">setPrevEndsExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Token -&gt; Bool
</span><a href="Elara.Lexer.Token.html#tokenEndsExpr"><span class="hs-identifier hs-var">tokenEndsExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680084012"><span class="hs-identifier hs-var">closerTok</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-303"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><a href="#local-6989586621680084018"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-304"></span><span>
</span><span id="line-305"></span><span class="annot"><span class="hs-comment">-- | Close only layout started at or inside current delimiter depth</span></span><span>
</span><span id="line-306"></span><span class="annot"><a href="Elara.Lexer.Utils.html#flushLayoutBeforeCloser"><span class="hs-identifier hs-type">flushLayoutBeforeCloser</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-307"></span><span id="flushLayoutBeforeCloser"><span class="annot"><span class="annottext">flushLayoutBeforeCloser :: LexMonad ()
</span><a href="Elara.Lexer.Utils.html#flushLayoutBeforeCloser"><span class="hs-identifier hs-var hs-var">flushLayoutBeforeCloser</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-308"></span><span>    </span><span id="local-6989586621680084052"><span class="annot"><a href="#local-6989586621680084052"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState Int
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] Int
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState Int
</span><a href="Elara.Lexer.Utils.html#delimDepth"><span class="hs-identifier hs-var">delimDepth</span></a></span><span>
</span><span id="line-309"></span><span>    </span><span id="local-6989586621680084053"><span class="annot"><a href="#local-6989586621680084053"><span class="hs-identifier hs-var">st</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">get</span></span><span>
</span><span id="line-310"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680084054"><span class="annot"><a href="#local-6989586621680084054"><span class="hs-identifier hs-var hs-var">stk</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680084053"><span class="hs-identifier hs-var">st</span></a></span><span> </span><span class="annot"><span class="annottext">ParseState
-&gt; Lens' ParseState (NonEmpty IndentInfo) -&gt; NonEmpty IndentInfo
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (NonEmpty IndentInfo)
</span><a href="Elara.Lexer.Utils.html#indentStack"><span class="hs-identifier hs-var">indentStack</span></a></span><span>
</span><span id="line-311"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621680084055"><span class="annot"><a href="#local-6989586621680084055"><span class="hs-identifier hs-var">toClose</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680084056"><span class="annot"><a href="#local-6989586621680084056"><span class="hs-identifier hs-var">keep</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">span</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680084057"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680084057"><span class="hs-identifier hs-var">ii</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680084057"><span class="hs-identifier hs-var">ii</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo Int -&gt; Int
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo Int
</span><a href="Elara.Lexer.Utils.html#openedAtDepth"><span class="hs-identifier hs-var">openedAtDepth</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680084052"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680084054"><span class="hs-identifier hs-type">stk</span></a></span><span>
</span><span id="line-312"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621680084056"><span class="hs-identifier hs-type">keep</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-313"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LexMonad ()
forall (f :: * -&gt; *). Applicative f =&gt; f ()
</span><span class="hs-identifier hs-var">pass</span></span><span> </span><span class="hs-comment">-- base should remain</span><span>
</span><span id="line-314"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621680084058"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680084058"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621680084059"><span class="annot"><span class="annottext">[IndentInfo]
</span><a href="#local-6989586621680084059"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-315"></span><span>            </span><span class="annot"><span class="annottext">ParseState -&gt; LexMonad ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
s -&gt; Eff es ()
</span><span class="hs-identifier hs-var">put</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680084053"><span class="hs-identifier hs-var">st</span></a></span><span> </span><span class="annot"><span class="annottext">ParseState -&gt; (ParseState -&gt; ParseState) -&gt; ParseState
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span><span class="hs-operator hs-var">&amp;</span></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (NonEmpty IndentInfo)
</span><a href="Elara.Lexer.Utils.html#indentStack"><span class="hs-identifier hs-var">indentStack</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (NonEmpty IndentInfo)
-&gt; NonEmpty IndentInfo -&gt; ParseState -&gt; ParseState
forall k (is :: IxList) s t a b.
Is k A_Setter =&gt;
Optic k is s t a b -&gt; b -&gt; s -&gt; t
</span><span class="hs-operator hs-var">.~</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680084058"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; [IndentInfo] -&gt; NonEmpty IndentInfo
forall a. a -&gt; [a] -&gt; NonEmpty a
</span><span class="hs-operator hs-var">:|</span></span><span> </span><span class="annot"><span class="annottext">[IndentInfo]
</span><a href="#local-6989586621680084059"><span class="hs-identifier hs-var">bs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-316"></span><span>            </span><span id="local-6989586621680084062"><span class="annot"><a href="#local-6989586621680084062"><span class="hs-identifier hs-var">curPos</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState RealPosition
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] RealPosition
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput RealPosition -&gt; Lens' ParseState RealPosition
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput RealPosition
</span><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-var">position</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-317"></span><span>            </span><span id="local-6989586621680084063"><span class="annot"><a href="#local-6989586621680084063"><span class="hs-identifier hs-var">ds</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">catMaybes</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">mapM</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680084067"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680084067"><span class="hs-identifier hs-var">lvl</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">RealPosition -&gt; RealPosition -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitDedentAt"><span class="hs-identifier hs-var">emitDedentAt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680084067"><span class="hs-identifier hs-var">lvl</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo RealPosition -&gt; RealPosition
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo RealPosition
</span><a href="Elara.Lexer.Utils.html#indentPos"><span class="hs-identifier hs-var">indentPos</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084062"><span class="hs-identifier hs-var">curPos</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680084055"><span class="hs-identifier hs-type">toClose</span></a></span><span>
</span><span id="line-318"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">mapM_</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#pushFront"><span class="hs-identifier hs-type">pushFront</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">reverse</span></span><span> </span><span class="annot"><a href="#local-6989586621680084063"><span class="hs-identifier hs-type">ds</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-319"></span><span>
</span><span id="line-320"></span><span class="annot"><a href="Elara.Lexer.Utils.html#emitLayoutAt"><span class="hs-identifier hs-type">emitLayoutAt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Token"><span class="hs-identifier hs-type">Token</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealSourceRegion"><span class="hs-identifier hs-type">RealSourceRegion</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-321"></span><span id="emitLayoutAt"><span class="annot"><span class="annottext">emitLayoutAt :: Token -&gt; RealSourceRegion -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitLayoutAt"><span class="hs-identifier hs-var hs-var">emitLayoutAt</span></a></span></span><span> </span><span id="local-6989586621680084073"><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680084073"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621680084074"><span class="annot"><span class="annottext">RealSourceRegion
</span><a href="#local-6989586621680084074"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme -&gt; LexMonad (Maybe Lexeme)
forall a.
a -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lexeme -&gt; Maybe Lexeme
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SourceRegion -&gt; Token -&gt; Lexeme
forall a. SourceRegion -&gt; a -&gt; Located a
</span><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-var">Located</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">RealSourceRegion -&gt; SourceRegion
</span><a href="Elara.AST.Region.html#RealSourceRegion"><span class="hs-identifier hs-var">RealSourceRegion</span></a></span><span> </span><span class="annot"><span class="annottext">RealSourceRegion
</span><a href="#local-6989586621680084074"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621680084073"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-322"></span><span>
</span><span id="line-323"></span><span class="annot"><a href="Elara.Lexer.Utils.html#emitIndentAt"><span class="hs-identifier hs-type">emitIndentAt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealPosition"><span class="hs-identifier hs-type">RealPosition</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-324"></span><span id="emitIndentAt"><span class="annot"><span class="annottext">emitIndentAt :: RealPosition -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitIndentAt"><span class="hs-identifier hs-var hs-var">emitIndentAt</span></a></span></span><span> </span><span id="local-6989586621680084077"><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084077"><span class="hs-identifier hs-var">pos</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-325"></span><span>    </span><span id="local-6989586621680084078"><span class="annot"><a href="#local-6989586621680084078"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">RealPosition -&gt; RealPosition -&gt; LexMonad RealSourceRegion
</span><a href="Elara.Lexer.Utils.html#createRegion"><span class="hs-identifier hs-var">createRegion</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084077"><span class="hs-identifier hs-var">pos</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084077"><span class="hs-identifier hs-var">pos</span></a></span><span>
</span><span id="line-326"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#emitLayoutAt"><span class="hs-identifier hs-type">emitLayoutAt</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokenIndent"><span class="hs-identifier hs-type">TokenIndent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680084078"><span class="hs-identifier hs-type">r</span></a></span><span>
</span><span id="line-327"></span><span>
</span><span id="line-328"></span><span class="annot"><a href="Elara.Lexer.Utils.html#emitDedentAt"><span class="hs-identifier hs-type">emitDedentAt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokPosition"><span class="hs-identifier hs-type">TokPosition</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokPosition"><span class="hs-identifier hs-type">TokPosition</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-329"></span><span id="emitDedentAt"><span class="annot"><span class="annottext">emitDedentAt :: RealPosition -&gt; RealPosition -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitDedentAt"><span class="hs-identifier hs-var hs-var">emitDedentAt</span></a></span></span><span> </span><span id="local-6989586621680084080"><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084080"><span class="hs-identifier hs-var">start</span></a></span></span><span> </span><span id="local-6989586621680084081"><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084081"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-330"></span><span>    </span><span id="local-6989586621680084082"><span class="annot"><a href="#local-6989586621680084082"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">RealPosition -&gt; RealPosition -&gt; LexMonad RealSourceRegion
</span><a href="Elara.Lexer.Utils.html#createRegion"><span class="hs-identifier hs-var">createRegion</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084080"><span class="hs-identifier hs-var">start</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084081"><span class="hs-identifier hs-var">end</span></a></span><span>
</span><span id="line-331"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#emitLayoutAt"><span class="hs-identifier hs-type">emitLayoutAt</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokenDedent"><span class="hs-identifier hs-type">TokenDedent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680084082"><span class="hs-identifier hs-type">r</span></a></span><span>
</span><span id="line-332"></span><span>
</span><span id="line-333"></span><span class="annot"><a href="Elara.Lexer.Utils.html#emitLineSepAt"><span class="hs-identifier hs-type">emitLineSepAt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealPosition"><span class="hs-identifier hs-type">RealPosition</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-334"></span><span id="emitLineSepAt"><span class="annot"><span class="annottext">emitLineSepAt :: RealPosition -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitLineSepAt"><span class="hs-identifier hs-var hs-var">emitLineSepAt</span></a></span></span><span> </span><span id="local-6989586621680084086"><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084086"><span class="hs-identifier hs-var">pos</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-335"></span><span>    </span><span id="local-6989586621680084087"><span class="annot"><a href="#local-6989586621680084087"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">RealPosition -&gt; RealPosition -&gt; LexMonad RealSourceRegion
</span><a href="Elara.Lexer.Utils.html#createRegion"><span class="hs-identifier hs-var">createRegion</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084086"><span class="hs-identifier hs-var">pos</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084086"><span class="hs-identifier hs-var">pos</span></a></span><span>
</span><span id="line-336"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#emitLayoutAt"><span class="hs-identifier hs-type">emitLayoutAt</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokenLineSeparator"><span class="hs-identifier hs-type">TokenLineSeparator</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680084087"><span class="hs-identifier hs-type">r</span></a></span><span>
</span><span id="line-337"></span><span>
</span><span id="line-338"></span><span class="annot"><a href="Elara.Lexer.Utils.html#startWhite"><span class="hs-identifier hs-type">startWhite</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-339"></span><span id="startWhite"><span class="annot"><span class="annottext">startWhite :: Int -&gt; Text -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#startWhite"><span class="hs-identifier hs-var hs-var">startWhite</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680084187"><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680084187"><span class="hs-identifier hs-var">str</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-340"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680084188"><span class="annot"><span class="annottext">indentation :: Int
</span><a href="#local-6989586621680084188"><span class="hs-identifier hs-var hs-var hs-var">indentation</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Text -&gt; Int
</span><span class="hs-identifier hs-var">T.length</span></span><span> </span><span class="annot"><span class="annottext">(Text -&gt; Int) -&gt; Text -&gt; Int
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Bool) -&gt; Text -&gt; Text
</span><span class="hs-identifier hs-var">T.dropWhile</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char -&gt; Char -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'\n'</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680084187"><span class="hs-identifier hs-var">str</span></a></span><span>
</span><span id="line-341"></span><span>    </span><span id="local-6989586621680084191"><span class="annot"><a href="#local-6989586621680084191"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Eff
  '[State ParseState, Error LexerError, StructuredDebug] ParseState
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
Eff es s
</span><span class="hs-identifier hs-var">get</span></span><span>
</span><span id="line-342"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680084192"><span class="annot"><a href="#local-6989586621680084192"><span class="hs-identifier hs-var">indents</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span id="local-6989586621680084193"><span class="annot"><a href="#local-6989586621680084193"><span class="hs-identifier hs-var">cur</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680084191"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">^.</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#indentStack"><span class="hs-identifier hs-type">indentStack</span></a></span><span>
</span><span id="line-343"></span><span>
</span><span id="line-344"></span><span>    </span><span id="local-6989586621680084194"><span class="annot"><a href="#local-6989586621680084194"><span class="hs-identifier hs-var">curPos</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-type">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-type">input</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">%</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-type">position</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-345"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680084195"><span class="annot"><a href="#local-6989586621680084195"><span class="hs-identifier hs-var hs-var">expectingLayout</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe LayoutExpectation -&gt; Bool
forall a. Maybe a -&gt; Bool
</span><span class="hs-identifier hs-var">isJust</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680084191"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">ParseState
-&gt; Lens' ParseState (Maybe LayoutExpectation)
-&gt; Maybe LayoutExpectation
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (Maybe LayoutExpectation)
</span><a href="Elara.Lexer.Utils.html#layoutExpected"><span class="hs-identifier hs-var">layoutExpected</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-346"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#layoutExpected"><span class="hs-identifier hs-type">layoutExpected</span></a></span><span> </span><span class="annot"><a href="Effectful.State.Extra.html#.%3D"><span class="hs-operator hs-type">.=</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span>
</span><span id="line-347"></span><span>
</span><span id="line-348"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621680084188"><span class="hs-identifier hs-type">indentation</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">`compare`</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680084193"><span class="hs-identifier hs-type">cur</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">^.</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#indent"><span class="hs-identifier hs-type">indent</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-349"></span><span>        </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">GT</span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621680084195"><span class="hs-identifier hs-var">expectingLayout</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-350"></span><span>            </span><span id="local-6989586621680084198"><span class="annot"><a href="#local-6989586621680084198"><span class="hs-identifier hs-var">fakeLb</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">RealPosition -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitIndentAt"><span class="hs-identifier hs-var">emitIndentAt</span></a></span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084194"><span class="hs-identifier hs-var">curPos</span></a></span><span>
</span><span id="line-351"></span><span>            </span><span id="local-6989586621680084199"><span class="annot"><a href="#local-6989586621680084199"><span class="hs-identifier hs-var">indentInfo</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#mkIndentInfo"><span class="hs-identifier hs-type">mkIndentInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680084188"><span class="hs-identifier hs-type">indentation</span></a></span><span>
</span><span id="line-352"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680084200"><span class="annot"><a href="#local-6989586621680084200"><span class="hs-identifier hs-var hs-var">push</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Lexeme] -&gt; [Lexeme])
-&gt; (Lexeme -&gt; [Lexeme] -&gt; [Lexeme])
-&gt; Maybe Lexeme
-&gt; [Lexeme]
-&gt; [Lexeme]
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="annot"><span class="annottext">[Lexeme] -&gt; [Lexeme]
forall a. a -&gt; a
</span><a href="Prelude.html#identity"><span class="hs-identifier hs-var">identity</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme
</span><a href="#local-6989586621680084198"><span class="hs-identifier hs-var">fakeLb</span></a></span><span>
</span><span id="line-353"></span><span>            </span><span class="hs-comment">-- Indent starts a block, usually shouldn't immediately end expr</span><span>
</span><span id="line-354"></span><span>            </span><span class="annot"><a href="Elara.Lexer.Utils.html#setPrevEndsExpr"><span class="hs-identifier hs-type">setPrevEndsExpr</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">False</span></span><span>
</span><span id="line-355"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">put</span></span><span> </span><span class="annot"><a href="#local-6989586621680084191"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.Lexer.Utils.html#_indentStack"><span class="hs-identifier hs-var">_indentStack</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680084199"><span class="hs-identifier hs-type">indentInfo</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;|</span></span><span> </span><span class="annot"><a href="#local-6989586621680084192"><span class="hs-identifier hs-type">indents</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#_pendingTokens"><span class="hs-identifier hs-var">_pendingTokens</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680084200"><span class="hs-identifier hs-type">push</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#_pendingTokens"><span class="hs-identifier hs-var">_pendingTokens</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680084191"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span class="hs-special">}</span><span>
</span><span id="line-356"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span>
</span><span id="line-357"></span><span>        </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">GT</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme -&gt; LexMonad (Maybe Lexeme)
forall a.
a -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-comment">-- ignore indentation increases that don't follow layout triggers</span><span>
</span><span id="line-358"></span><span>        </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">LT</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-359"></span><span>            </span><span class="hs-comment">-- Pop all levels strictly greater than current indentation</span><span>
</span><span id="line-360"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680084203"><span class="annot"><span class="annottext">[IndentInfo]
</span><a href="#local-6989586621680084203"><span class="hs-identifier hs-var hs-var">closingLevels</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680084204"><span class="annot"><span class="annottext">[IndentInfo]
</span><a href="#local-6989586621680084204"><span class="hs-identifier hs-var hs-var">topAndRest</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(IndentInfo -&gt; Bool)
-&gt; NonEmpty IndentInfo -&gt; ([IndentInfo], [IndentInfo])
forall a. (a -&gt; Bool) -&gt; NonEmpty a -&gt; ([a], [a])
</span><span class="hs-identifier hs-var">span</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Optic' A_Getter NoIx IndentInfo Bool -&gt; IndentInfo -&gt; Bool
forall k (is :: IxList) s a.
Is k A_Getter =&gt;
Optic' k is s a -&gt; s -&gt; a
</span><span class="hs-identifier hs-var">view</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' IndentInfo Int
</span><a href="Elara.Lexer.Utils.html#indent"><span class="hs-identifier hs-var">indent</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo Int
-&gt; Optic A_Getter NoIx Int Int Bool Bool
-&gt; Optic' A_Getter NoIx IndentInfo Bool
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">(Int -&gt; Bool) -&gt; Optic A_Getter NoIx Int Int Bool Bool
forall s a. (s -&gt; a) -&gt; Getter s a
</span><span class="hs-identifier hs-var">to</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680084188"><span class="hs-identifier hs-var">indentation</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">NonEmpty IndentInfo
</span><a href="#local-6989586621680084192"><span class="hs-identifier hs-var">indents</span></a></span><span>
</span><span id="line-361"></span><span>
</span><span id="line-362"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[IndentInfo]
</span><a href="#local-6989586621680084204"><span class="hs-identifier hs-var">topAndRest</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-363"></span><span>                </span><span class="hs-special">(</span><span id="local-6989586621680084207"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680084207"><span class="hs-identifier hs-var">top</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621680084208"><span class="annot"><span class="annottext">[IndentInfo]
</span><a href="#local-6989586621680084208"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-364"></span><span>                    </span><span id="local-6989586621680084209"><span class="annot"><a href="#local-6989586621680084209"><span class="hs-identifier hs-var">eofPos</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState RealPosition
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] RealPosition
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput RealPosition -&gt; Lens' ParseState RealPosition
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput RealPosition
</span><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-var">position</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-365"></span><span>
</span><span id="line-366"></span><span>                    </span><span class="hs-comment">-- emit DEDENTs for everything we popped</span><span>
</span><span id="line-367"></span><span>                    </span><span id="local-6989586621680084210"><span class="annot"><a href="#local-6989586621680084210"><span class="hs-identifier hs-var">dedents</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">catMaybes</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">mapM</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680084211"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680084211"><span class="hs-identifier hs-var">lvl</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">RealPosition -&gt; RealPosition -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitDedentAt"><span class="hs-identifier hs-var">emitDedentAt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680084211"><span class="hs-identifier hs-var">lvl</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo RealPosition -&gt; RealPosition
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo RealPosition
</span><a href="Elara.Lexer.Utils.html#indentPos"><span class="hs-identifier hs-var">indentPos</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084209"><span class="hs-identifier hs-var">eofPos</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680084203"><span class="hs-identifier hs-type">closingLevels</span></a></span><span>
</span><span id="line-368"></span><span>
</span><span id="line-369"></span><span>                    </span><span class="hs-comment">-- check validity against the new top of stack</span><span>
</span><span id="line-370"></span><span>                    </span><span class="hs-comment">-- a valid continuation is one that is &gt;= top indent</span><span>
</span><span id="line-371"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680084212"><span class="annot"><a href="#local-6989586621680084212"><span class="hs-identifier hs-var hs-var">validContinuation</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680084188"><span class="hs-identifier hs-var">indentation</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680084207"><span class="hs-identifier hs-var">top</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo Int -&gt; Int
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo Int
</span><a href="Elara.Lexer.Utils.html#indent"><span class="hs-identifier hs-var">indent</span></a></span><span>
</span><span id="line-372"></span><span>
</span><span id="line-373"></span><span>                    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><a href="#local-6989586621680084212"><span class="hs-identifier hs-type">validContinuation</span></a></span><span>
</span><span id="line-374"></span><span>                        </span><span class="hs-keyword">then</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-375"></span><span>                            </span><span class="hs-comment">-- emit separator _only_ if we match exactly, i.e. it's a new statement</span><span>
</span><span id="line-376"></span><span>                            </span><span class="hs-comment">-- if indentation &gt; top, it's a continuation, so no separator</span><span>
</span><span id="line-377"></span><span>                            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680084213"><span class="annot"><a href="#local-6989586621680084213"><span class="hs-identifier hs-var hs-var">isNewStmt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680084188"><span class="hs-identifier hs-var">indentation</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680084207"><span class="hs-identifier hs-var">top</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo Int -&gt; Int
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo Int
</span><a href="Elara.Lexer.Utils.html#indent"><span class="hs-identifier hs-var">indent</span></a></span><span>
</span><span id="line-378"></span><span>
</span><span id="line-379"></span><span>                            </span><span id="local-6989586621680084214"><span class="annot"><a href="#local-6989586621680084214"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-380"></span><span>                                </span><span class="hs-keyword">if</span><span> </span><span class="annot"><a href="#local-6989586621680084213"><span class="hs-identifier hs-type">isNewStmt</span></a></span><span>
</span><span id="line-381"></span><span>                                    </span><span class="hs-keyword">then</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#emitLineSepAt"><span class="hs-identifier hs-type">emitLineSepAt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680084209"><span class="hs-identifier hs-type">eofPos</span></a></span><span>
</span><span id="line-382"></span><span>                                    </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span class="hs-comment">-- no separator for continuations</span><span>
</span><span id="line-383"></span><span>                            </span><span class="annot"><a href="Elara.Lexer.Utils.html#setPrevEndsExpr"><span class="hs-identifier hs-type">setPrevEndsExpr</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">False</span></span><span>
</span><span id="line-384"></span><span>
</span><span id="line-385"></span><span>                            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680084215"><span class="annot"><a href="#local-6989586621680084215"><span class="hs-identifier hs-var hs-var">closings</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Lexeme]
</span><a href="#local-6989586621680084210"><span class="hs-identifier hs-var">dedents</span></a></span><span> </span><span class="annot"><span class="annottext">[Lexeme] -&gt; [Lexeme] -&gt; [Lexeme]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme -&gt; [Lexeme]
forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme
</span><a href="#local-6989586621680084214"><span class="hs-identifier hs-var">sep</span></a></span><span>
</span><span id="line-386"></span><span>
</span><span id="line-387"></span><span>                            </span><span class="annot"><a href="Elara.Lexer.Utils.html#indentStack"><span class="hs-identifier hs-type">indentStack</span></a></span><span> </span><span class="annot"><a href="Effectful.State.Extra.html#.%3D"><span class="hs-operator hs-type">.=</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680084207"><span class="hs-identifier hs-type">top</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span class="annot"><a href="#local-6989586621680084208"><span class="hs-identifier hs-type">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-388"></span><span>                            </span><span class="annot"><a href="Elara.Lexer.Utils.html#pendingTokens"><span class="hs-identifier hs-type">pendingTokens</span></a></span><span> </span><span class="annot"><a href="Effectful.State.Extra.html#%25%3D"><span class="hs-operator hs-type">%=</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">closings</span></span><span> </span><span class="annot"><span class="hs-operator">&lt;&gt;</span></span><span class="hs-special">)</span><span>
</span><span id="line-389"></span><span>
</span><span id="line-390"></span><span>                            </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span>
</span><span id="line-391"></span><span>                        </span><span class="hs-keyword">else</span><span>
</span><span id="line-392"></span><span>                            </span><span class="annot"><span class="hs-identifier hs-type">throwError</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#TooMuchIndentation"><span class="hs-identifier hs-type">TooMuchIndentation</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680084207"><span class="hs-identifier hs-type">top</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">viaNonEmpty</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">last</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">init</span></span><span> </span><span class="annot"><a href="#local-6989586621680084192"><span class="hs-identifier hs-type">indents</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680084188"><span class="hs-identifier hs-type">indentation</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680084191"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-393"></span><span>                </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Text
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug]
     (Maybe (ZonkAny 0))
forall a t. (HasCallStack, IsText t) =&gt; t -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot; Indent stack contains nothing greater than &quot;</span></span><span> </span><span class="annot"><span class="annottext">Text -&gt; Text -&gt; Text
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Text
forall b a. (Show a, IsString b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680084188"><span class="hs-identifier hs-var">indentation</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-394"></span><span>            </span><span class="annot"><span class="annottext">Maybe Lexeme -&gt; LexMonad (Maybe Lexeme)
forall a.
a -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe Lexeme
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-395"></span><span>        </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">EQ</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-396"></span><span>            </span><span id="local-6989586621680084222"><span class="annot"><a href="#local-6989586621680084222"><span class="hs-identifier hs-var">ends</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">LexMonad Bool
</span><a href="Elara.Lexer.Utils.html#getPrevEndsExpr"><span class="hs-identifier hs-var">getPrevEndsExpr</span></a></span><span>
</span><span id="line-397"></span><span>            </span><span id="local-6989586621680084223"><span class="annot"><a href="#local-6989586621680084223"><span class="hs-identifier hs-var">pos</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-type">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-type">input</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">%</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-type">position</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-398"></span><span>            </span><span class="hs-keyword">if</span><span> </span><span class="annot"><a href="#local-6989586621680084222"><span class="hs-identifier hs-type">ends</span></a></span><span>
</span><span id="line-399"></span><span>                </span><span class="hs-keyword">then</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-400"></span><span>                    </span><span class="annot"><a href="Elara.Lexer.Utils.html#setPrevEndsExpr"><span class="hs-identifier hs-type">setPrevEndsExpr</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">False</span></span><span>
</span><span id="line-401"></span><span>                    </span><span class="annot"><a href="Elara.Lexer.Utils.html#emitLineSepAt"><span class="hs-identifier hs-type">emitLineSepAt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680084223"><span class="hs-identifier hs-type">pos</span></a></span><span>
</span><span id="line-402"></span><span>                </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span>
</span><span id="line-403"></span><span>
</span><span id="line-404"></span><span class="hs-comment">-- Insert dedent for any leftover unclosed indents</span><span>
</span><span id="line-405"></span><span class="annot"><a href="Elara.Lexer.Utils.html#cleanIndentation"><span class="hs-identifier hs-type">cleanIndentation</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-406"></span><span id="cleanIndentation"><span class="annot"><span class="annottext">cleanIndentation :: Eff '[State ParseState, Error LexerError, StructuredDebug] [Lexeme]
</span><a href="Elara.Lexer.Utils.html#cleanIndentation"><span class="hs-identifier hs-var hs-var">cleanIndentation</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-407"></span><span>    </span><span id="local-6989586621680084249"><span class="annot"><a href="#local-6989586621680084249"><span class="hs-identifier hs-var">indentStack'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (NonEmpty IndentInfo)
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug]
     (NonEmpty IndentInfo)
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState (NonEmpty IndentInfo)
</span><a href="Elara.Lexer.Utils.html#indentStack"><span class="hs-identifier hs-var">indentStack</span></a></span><span>
</span><span id="line-408"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621680084249"><span class="hs-identifier hs-type">indentStack'</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-409"></span><span>        </span><span id="local-6989586621680084250"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680084250"><span class="hs-identifier hs-var">_base</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Lexeme]
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] [Lexeme]
forall a.
a -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-410"></span><span>        </span><span class="annot"><span class="annottext">NonEmpty IndentInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-411"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680084251"><span class="annot"><span class="annottext">toClose :: [IndentInfo]
</span><a href="#local-6989586621680084251"><span class="hs-identifier hs-var hs-var hs-var">toClose</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NonEmpty IndentInfo -&gt; [IndentInfo]
forall (f :: * -&gt; *) a. IsNonEmpty f a [a] &quot;init&quot; =&gt; f a -&gt; [a]
</span><span class="hs-identifier hs-var">init</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty IndentInfo
</span><a href="#local-6989586621680084249"><span class="hs-identifier hs-var">indentStack'</span></a></span><span>
</span><span id="line-412"></span><span>                </span><span id="local-6989586621680084252"><span class="annot"><span class="annottext">base :: IndentInfo
</span><a href="#local-6989586621680084252"><span class="hs-identifier hs-var hs-var hs-var">base</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NonEmpty IndentInfo -&gt; IndentInfo
forall (f :: * -&gt; *) a. IsNonEmpty f a a &quot;last&quot; =&gt; f a -&gt; a
</span><span class="hs-identifier hs-var">last</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty IndentInfo
</span><a href="#local-6989586621680084249"><span class="hs-identifier hs-var">indentStack'</span></a></span><span>
</span><span id="line-413"></span><span>            </span><span id="local-6989586621680084253"><span class="annot"><a href="#local-6989586621680084253"><span class="hs-identifier hs-var">eofPos</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Lens' ParseState RealPosition
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] RealPosition
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput RealPosition -&gt; Lens' ParseState RealPosition
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput RealPosition
</span><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-var">position</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-414"></span><span>            </span><span id="local-6989586621680084254"><span class="annot"><a href="#local-6989586621680084254"><span class="hs-identifier hs-var">dedents</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">catMaybes</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">mapM</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680084255"><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680084255"><span class="hs-identifier hs-var">lvl</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">RealPosition -&gt; RealPosition -&gt; LexMonad (Maybe Lexeme)
</span><a href="Elara.Lexer.Utils.html#emitDedentAt"><span class="hs-identifier hs-var">emitDedentAt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IndentInfo
</span><a href="#local-6989586621680084255"><span class="hs-identifier hs-var">lvl</span></a></span><span> </span><span class="annot"><span class="annottext">IndentInfo -&gt; Lens' IndentInfo RealPosition -&gt; RealPosition
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Lens' IndentInfo RealPosition
</span><a href="Elara.Lexer.Utils.html#indentPos"><span class="hs-identifier hs-var">indentPos</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084253"><span class="hs-identifier hs-var">eofPos</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680084251"><span class="hs-identifier hs-type">toClose</span></a></span><span>
</span><span id="line-415"></span><span>            </span><span class="annot"><a href="Elara.Lexer.Utils.html#indentStack"><span class="hs-identifier hs-type">indentStack</span></a></span><span> </span><span class="annot"><a href="Effectful.State.Extra.html#.%3D"><span class="hs-operator hs-type">.=</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680084252"><span class="hs-identifier hs-type">base</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-416"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><a href="#local-6989586621680084254"><span class="hs-identifier hs-type">dedents</span></a></span><span>
</span><span id="line-417"></span><span>
</span><span id="line-418"></span><span class="hs-comment">-- The functions that must be provided to Alex's basic interface</span><span>
</span><span id="line-419"></span><span>
</span><span id="line-420"></span><span class="annot"><span class="hs-comment">-- | Read a byte from the input</span></span><span>
</span><span id="line-421"></span><span class="annot"><a href="Elara.Lexer.Utils.html#alexGetByte"><span class="hs-identifier hs-type">alexGetByte</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-type">AlexInput</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-type">AlexInput</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-422"></span><span id="alexGetByte"><span class="annot"><span class="annottext">alexGetByte :: AlexInput -&gt; Maybe (Word8, AlexInput)
</span><a href="Elara.Lexer.Utils.html#alexGetByte"><span class="hs-identifier hs-var hs-var">alexGetByte</span></a></span></span><span> </span><span id="local-6989586621680084265"><span class="annot"><span class="annottext">ai :: AlexInput
</span><a href="#local-6989586621680084265"><span class="hs-identifier hs-var">ai</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-type">AlexInput</span></a></span><span class="hs-special">{</span><span id="local-6989586621680084266"><span id="local-6989586621680084267"><span id="local-6989586621680084268"><span id="local-6989586621680084269"><span id="local-6989586621680084270"><span class="annot"><span class="annottext">Char
FilePath
[Word8]
Text
RealPosition
_filePath :: AlexInput -&gt; FilePath
_prev :: AlexInput -&gt; Char
_bytes :: AlexInput -&gt; [Word8]
_rest :: AlexInput -&gt; Text
_position :: AlexInput -&gt; RealPosition
_filePath :: FilePath
_prev :: Char
_bytes :: [Word8]
_rest :: Text
_position :: RealPosition
</span><a href="Elara.Lexer.Utils.html#_filePath"><span class="hs-glyph hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">..</span></a></span></span></span></span></span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-423"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[Word8]
</span><a href="#local-6989586621680084268"><span class="hs-identifier hs-var">_bytes</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-424"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621680084271"><span class="annot"><span class="annottext">Word8
</span><a href="#local-6989586621680084271"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621680084272"><span class="annot"><span class="annottext">[Word8]
</span><a href="#local-6989586621680084272"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-425"></span><span>            </span><span class="annot"><span class="annottext">(Word8, AlexInput) -&gt; Maybe (Word8, AlexInput)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word8
</span><a href="#local-6989586621680084271"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">AlexInput
</span><a href="#local-6989586621680084265"><span class="hs-identifier hs-var">ai</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.Lexer.Utils.html#_bytes"><span class="hs-identifier hs-var">_bytes</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680084272"><span class="hs-identifier hs-type">bs</span></a></span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-426"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-427"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Text -&gt; Maybe (Char, Text)
</span><span class="hs-identifier hs-var">T.uncons</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680084269"><span class="hs-identifier hs-var">_rest</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-428"></span><span>                </span><span class="annot"><span class="annottext">Maybe (Char, Text)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (Word8, AlexInput)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-429"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680084274"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680084274"><span class="hs-identifier hs-var">char</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680084275"><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680084275"><span class="hs-identifier hs-var">chars</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-430"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Position"><span class="hs-identifier hs-type">Position</span></a></span><span> </span><span id="local-6989586621680084276"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680084276"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621680084277"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680084277"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084270"><span class="hs-identifier hs-var">_position</span></a></span><span>
</span><span id="line-431"></span><span>                        </span><span id="local-6989586621680084278"><span class="annot"><span class="annottext">n' :: Int
</span><a href="#local-6989586621680084278"><span class="hs-identifier hs-var hs-var">n'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680084274"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Char -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'\n'</span></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680084276"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680084276"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-432"></span><span>                        </span><span id="local-6989586621680084279"><span class="annot"><span class="annottext">c' :: Int
</span><a href="#local-6989586621680084279"><span class="hs-identifier hs-var hs-var">c'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680084274"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Char -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'\n'</span></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680084277"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-433"></span><span>                        </span><span class="hs-special">(</span><span id="local-6989586621680084280"><span class="annot"><span class="annottext">Word8
</span><a href="#local-6989586621680084280"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span id="local-6989586621680084281"><span class="annot"><span class="annottext">[Word8]
</span><a href="#local-6989586621680084281"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Item (NonEmpty Word8)] -&gt; NonEmpty Word8
forall l. IsList l =&gt; [Item l] -&gt; l
</span><span class="hs-identifier hs-var">fromList</span></span><span> </span><span class="annot"><span class="annottext">([Item (NonEmpty Word8)] -&gt; NonEmpty Word8)
-&gt; [Item (NonEmpty Word8)] -&gt; NonEmpty Word8
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; [Word8]
</span><span class="hs-identifier hs-var">encodeChar</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680084274"><span class="hs-identifier hs-var">char</span></a></span><span>
</span><span id="line-434"></span><span>                     </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">(Word8, AlexInput) -&gt; Maybe (Word8, AlexInput)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span>
</span><span id="line-435"></span><span>                            </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">Word8
</span><a href="#local-6989586621680084280"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-436"></span><span>                            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">AlexInput
</span><a href="#local-6989586621680084265"><span class="hs-identifier hs-var">ai</span></a></span><span>
</span><span id="line-437"></span><span>                                </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#_prev"><span class="hs-identifier hs-var">_prev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680084274"><span class="hs-identifier hs-type">char</span></a></span><span>
</span><span id="line-438"></span><span>                                </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#_bytes"><span class="hs-identifier hs-var">_bytes</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680084281"><span class="hs-identifier hs-type">bs</span></a></span><span>
</span><span id="line-439"></span><span>                                </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#_rest"><span class="hs-identifier hs-var">_rest</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680084275"><span class="hs-identifier hs-type">chars</span></a></span><span>
</span><span id="line-440"></span><span>                                </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#_position"><span class="hs-identifier hs-var">_position</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#Position"><span class="hs-identifier hs-type">Position</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680084278"><span class="hs-identifier hs-type">n'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680084279"><span class="hs-identifier hs-type">c'</span></a></span><span>
</span><span id="line-441"></span><span>                                </span><span class="hs-special">}</span><span>
</span><span id="line-442"></span><span>                            </span><span class="hs-special">)</span><span>
</span><span id="line-443"></span><span>
</span><span id="line-444"></span><span class="annot"><a href="Elara.Lexer.Utils.html#getPosition"><span class="hs-identifier hs-type">getPosition</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokPosition"><span class="hs-identifier hs-type">TokPosition</span></a></span><span>
</span><span id="line-445"></span><span id="getPosition"><span class="annot"><span class="annottext">getPosition :: Int
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] RealPosition
</span><a href="Elara.Lexer.Utils.html#getPosition"><span class="hs-identifier hs-var hs-var">getPosition</span></a></span></span><span> </span><span id="local-6989586621680084288"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680084288"><span class="hs-identifier hs-var">tokenLength</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-446"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#ParseState"><span class="hs-identifier hs-type">ParseState</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.Lexer.Utils.html#_input"><span class="hs-identifier hs-var">_input</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#AlexInput"><span class="hs-identifier hs-type">AlexInput</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.Lexer.Utils.html#_position"><span class="hs-identifier hs-var">_position</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Position"><span class="hs-identifier hs-type">Position</span></a></span><span> </span><span id="local-6989586621680084289"><span class="annot"><a href="#local-6989586621680084289"><span class="hs-identifier hs-var">ln</span></a></span></span><span> </span><span id="local-6989586621680084290"><span class="annot"><a href="#local-6989586621680084290"><span class="hs-identifier hs-var">cn</span></a></span></span><span class="hs-special">)</span><span class="hs-special">}</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Eff
  '[State ParseState, Error LexerError, StructuredDebug] ParseState
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
Eff es s
</span><span class="hs-identifier hs-var">get</span></span><span>
</span><span id="line-447"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="Elara.AST.Region.html#Position"><span class="hs-identifier hs-type">Position</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680084289"><span class="hs-identifier hs-type">ln</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680084290"><span class="hs-identifier hs-type">cn</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">-</span></span><span> </span><span class="annot"><a href="#local-6989586621680084288"><span class="hs-identifier hs-type">tokenLength</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-448"></span><span>
</span><span id="line-449"></span><span class="annot"><a href="Elara.Lexer.Utils.html#createRegion"><span class="hs-identifier hs-type">createRegion</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokPosition"><span class="hs-identifier hs-type">TokPosition</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokPosition"><span class="hs-identifier hs-type">TokPosition</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealSourceRegion"><span class="hs-identifier hs-type">RealSourceRegion</span></a></span><span>
</span><span id="line-450"></span><span id="createRegion"><span class="annot"><span class="annottext">createRegion :: RealPosition -&gt; RealPosition -&gt; LexMonad RealSourceRegion
</span><a href="Elara.Lexer.Utils.html#createRegion"><span class="hs-identifier hs-var hs-var">createRegion</span></a></span></span><span> </span><span id="local-6989586621680084301"><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084301"><span class="hs-identifier hs-var">start</span></a></span></span><span> </span><span id="local-6989586621680084302"><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084302"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-451"></span><span>    </span><span id="local-6989586621680084303"><span class="annot"><a href="#local-6989586621680084303"><span class="hs-identifier hs-var">fp</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Optic' A_Lens NoIx ParseState FilePath
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] FilePath
forall k a (r :: [(* -&gt; *) -&gt; * -&gt; *]) (is :: IxList) b.
(Is k A_Getter, State a :&gt; r) =&gt;
Optic' k is a b -&gt; Eff r b
</span><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-var">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Lens' ParseState AlexInput
-&gt; Lens' AlexInput FilePath
-&gt; Optic' A_Lens NoIx ParseState FilePath
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Lens' AlexInput FilePath
</span><a href="Elara.Lexer.Utils.html#filePath"><span class="hs-identifier hs-var">filePath</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-452"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="Elara.AST.Region.html#mkSourceRegionIn"><span class="hs-identifier hs-type">mkSourceRegionIn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><a href="#local-6989586621680084303"><span class="hs-identifier hs-type">fp</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680084301"><span class="hs-identifier hs-type">start</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680084302"><span class="hs-identifier hs-type">end</span></a></span><span>
</span><span id="line-453"></span><span>
</span><span id="line-454"></span><span class="annot"><a href="Elara.Lexer.Utils.html#createRegionStartingAt"><span class="hs-identifier hs-type">createRegionStartingAt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#TokPosition"><span class="hs-identifier hs-type">TokPosition</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Region.html#RealSourceRegion"><span class="hs-identifier hs-type">RealSourceRegion</span></a></span><span>
</span><span id="line-455"></span><span id="createRegionStartingAt"><span class="annot"><span class="annottext">createRegionStartingAt :: RealPosition -&gt; LexMonad RealSourceRegion
</span><a href="Elara.Lexer.Utils.html#createRegionStartingAt"><span class="hs-identifier hs-var hs-var">createRegionStartingAt</span></a></span></span><span> </span><span id="local-6989586621680084306"><span class="annot"><span class="annottext">RealPosition
</span><a href="#local-6989586621680084306"><span class="hs-identifier hs-var">start</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-456"></span><span>    </span><span id="local-6989586621680084307"><span class="annot"><a href="#local-6989586621680084307"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Int
-&gt; Eff
     '[State ParseState, Error LexerError, StructuredDebug] RealPosition
</span><a href="Elara.Lexer.Utils.html#getPosition"><span class="hs-identifier hs-var">getPosition</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-457"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Utils.html#createRegion"><span class="hs-identifier hs-type">createRegion</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680084306"><span class="hs-identifier hs-type">start</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680084307"><span class="hs-identifier hs-type">end</span></a></span><span>
</span><span id="line-458"></span><span>
</span><span id="line-459"></span><span class="annot"><span class="hs-comment">{- | Splits a qualified name into the qualifier and the name.
Throws an error if the name is not qualified.

Examples:

&gt;&gt;&gt; splitQualName &quot;Hello.world&quot;
(ModuleName (&quot;Hello&quot; :| []),&quot;world&quot;)

&gt;&gt;&gt; splitQualName &quot;A.B.C&quot;
(ModuleName (&quot;A&quot; :| [&quot;B&quot;]),&quot;C&quot;)

&gt;&gt;&gt; splitQualName &quot;Prelude..+&quot;
(ModuleName (&quot;Prelude&quot; :| []),&quot;.+&quot;)

&gt;&gt;&gt; splitQualName &quot;A.!.&quot;
(ModuleName (&quot;A&quot; :| []),&quot;!.&quot;)
-}</span></span><span>
</span><span id="line-476"></span><span class="annot"><a href="Elara.Lexer.Utils.html#splitQualName"><span class="hs-identifier hs-type">splitQualName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span class="hs-special">)</span><span>
</span><span id="line-477"></span><span id="splitQualName"><span class="annot"><span class="annottext">splitQualName :: Text -&gt; (ModuleName, Text)
</span><a href="Elara.Lexer.Utils.html#splitQualName"><span class="hs-identifier hs-var hs-var">splitQualName</span></a></span></span><span> </span><span id="local-6989586621680084349"><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680084349"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-478"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680084350"><span class="annot"><span class="annottext">parts :: [Text]
</span><a href="#local-6989586621680084350"><span class="hs-identifier hs-var hs-var">parts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HasCallStack =&gt; Text -&gt; Text -&gt; [Text]
Text -&gt; Text -&gt; [Text]
</span><span class="hs-identifier hs-var">T.splitOn</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;.&quot;</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680084349"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-479"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[Text]
</span><a href="#local-6989586621680084350"><span class="hs-identifier hs-var">parts</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-480"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Text -&gt; (ModuleName, Text)
forall a t. (HasCallStack, IsText t) =&gt; t -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;Empty string&quot;</span></span><span>
</span><span id="line-481"></span><span>        </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;&quot;</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Text -&gt; (ModuleName, Text)
forall a t. (HasCallStack, IsText t) =&gt; t -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;Empty string&quot;</span></span><span>
</span><span id="line-482"></span><span>        </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Text
</span><span class="hs-identifier">_</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Text -&gt; (ModuleName, Text)
forall a t. (HasCallStack, IsText t) =&gt; t -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;No module name&quot;</span></span><span>
</span><span id="line-483"></span><span>        </span><span id="local-6989586621680084352"><span class="annot"><span class="annottext">[Text]
</span><a href="#local-6989586621680084352"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-484"></span><span>            </span><span class="hs-comment">-- we have to be careful here, we can't just take the 'init' because that will break operators that start with .</span><span>
</span><span id="line-485"></span><span>            </span><span class="hs-comment">-- &gt;&gt;&gt; [&quot;Prelude&quot;, &quot;&quot;, &quot;+&quot;] = (&quot;Prelude&quot;, &quot;.+&quot;)</span><span>
</span><span id="line-486"></span><span>            </span><span class="hs-comment">-- &gt;&gt;&gt; [&quot;Prelude&quot;, &quot;T&quot;] = (&quot;Prelude&quot;, &quot;T&quot;)</span><span>
</span><span id="line-487"></span><span>            </span><span class="hs-comment">-- &gt;&gt;&gt; [&quot;Prelude&quot;, &quot;T&quot;, &quot;&quot;] = (&quot;Prelude.T&quot;, &quot;.&quot;)</span><span>
</span><span id="line-488"></span><span>            </span><span class="hs-comment">-- &gt;&gt;&gt; [&quot;A&quot;, &quot;!&quot;, &quot;&quot;] = (&quot;A&quot;, &quot;!.&quot;)</span><span>
</span><span id="line-489"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680084353"><span class="annot"><span class="annottext">isAlphaNumeric :: Text -&gt; Bool
</span><a href="#local-6989586621680084353"><span class="hs-identifier hs-var hs-var">isAlphaNumeric</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Bool) -&gt; Text -&gt; Bool
</span><span class="hs-identifier hs-var">T.all</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680084355"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680084355"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Char -&gt; Bool
</span><span class="hs-identifier hs-var">isAlpha</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680084355"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Bool
</span><span class="hs-identifier hs-var">isDigit</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680084355"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-490"></span><span>                </span><span class="hs-special">(</span><span id="local-6989586621680084359"><span class="annot"><span class="annottext">[Text]
</span><a href="#local-6989586621680084359"><span class="hs-identifier hs-var">modPart</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680084360"><span class="annot"><span class="annottext">[Text]
</span><a href="#local-6989586621680084360"><span class="hs-identifier hs-var">namePart</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Text -&gt; Bool) -&gt; NonEmpty Text -&gt; ([Text], [Text])
forall a. (a -&gt; Bool) -&gt; NonEmpty a -&gt; ([a], [a])
</span><span class="hs-identifier hs-var">span</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Bool -&gt; Bool -&gt; Bool)
-&gt; (Text -&gt; Bool) -&gt; (Text -&gt; Bool) -&gt; Text -&gt; Bool
forall a b c.
(a -&gt; b -&gt; c) -&gt; (Text -&gt; a) -&gt; (Text -&gt; b) -&gt; Text -&gt; c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">(&amp;&amp;)</span></span><span> </span><span class="annot"><span class="annottext">Text -&gt; Bool
</span><a href="#local-6989586621680084353"><span class="hs-identifier hs-var">isAlphaNumeric</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Bool) -&gt; (Text -&gt; Bool) -&gt; Text -&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Text -&gt; Bool
</span><span class="hs-identifier hs-var">T.null</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Item (NonEmpty Text)] -&gt; NonEmpty Text
forall l. IsList l =&gt; [Item l] -&gt; l
</span><span class="hs-identifier hs-var">fromList</span></span><span> </span><span class="annot"><span class="annottext">[Text]
[Item (NonEmpty Text)]
</span><a href="#local-6989586621680084352"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-491"></span><span>             </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">[Text] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[Text]
</span><a href="#local-6989586621680084360"><span class="hs-identifier hs-var">namePart</span></a></span><span>
</span><span id="line-492"></span><span>                    </span><span class="hs-keyword">then</span><span> </span><span class="hs-comment">-- TODO: this isn't very efficient</span><span>
</span><span id="line-493"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NonEmpty Text -&gt; ModuleName
</span><a href="Elara.AST.Name.html#ModuleName"><span class="hs-identifier hs-var">ModuleName</span></a></span><span> </span><span class="annot"><span class="annottext">(NonEmpty Text -&gt; ModuleName) -&gt; NonEmpty Text -&gt; ModuleName
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Item (NonEmpty Text)] -&gt; NonEmpty Text
forall l. IsList l =&gt; [Item l] -&gt; l
</span><span class="hs-identifier hs-var">fromList</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NonEmpty (Item (NonEmpty Text)) -&gt; [Item (NonEmpty Text)]
forall (f :: * -&gt; *) a. IsNonEmpty f a [a] &quot;init&quot; =&gt; f a -&gt; [a]
</span><span class="hs-identifier hs-var">init</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Item (NonEmpty (Item (NonEmpty Text)))]
-&gt; NonEmpty (Item (NonEmpty Text))
forall l. IsList l =&gt; [Item l] -&gt; l
</span><span class="hs-identifier hs-var">fromList</span></span><span> </span><span class="annot"><span class="annottext">[Text]
[Item (NonEmpty (Item (NonEmpty Text)))]
</span><a href="#local-6989586621680084359"><span class="hs-identifier hs-var">modPart</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">NonEmpty Text -&gt; Text
forall (f :: * -&gt; *) a. IsNonEmpty f a a &quot;last&quot; =&gt; f a -&gt; a
</span><span class="hs-identifier hs-var">last</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Item (NonEmpty Text)] -&gt; NonEmpty Text
forall l. IsList l =&gt; [Item l] -&gt; l
</span><span class="hs-identifier hs-var">fromList</span></span><span> </span><span class="annot"><span class="annottext">[Text]
[Item (NonEmpty Text)]
</span><a href="#local-6989586621680084359"><span class="hs-identifier hs-var">modPart</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-494"></span><span>                    </span><span class="hs-keyword">else</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NonEmpty Text -&gt; ModuleName
</span><a href="Elara.AST.Name.html#ModuleName"><span class="hs-identifier hs-var">ModuleName</span></a></span><span> </span><span class="annot"><span class="annottext">(NonEmpty Text -&gt; ModuleName) -&gt; NonEmpty Text -&gt; ModuleName
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Item (NonEmpty Text)] -&gt; NonEmpty Text
forall l. IsList l =&gt; [Item l] -&gt; l
</span><span class="hs-identifier hs-var">fromList</span></span><span> </span><span class="annot"><span class="annottext">[Text]
[Item (NonEmpty Text)]
</span><a href="#local-6989586621680084359"><span class="hs-identifier hs-var">modPart</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Text -&gt; [Text] -&gt; Text
</span><span class="hs-identifier hs-var">T.intercalate</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;.&quot;</span></span><span> </span><span class="annot"><span class="annottext">[Text]
</span><a href="#local-6989586621680084360"><span class="hs-identifier hs-var">namePart</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-495"></span></pre></body></html>