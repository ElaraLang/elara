<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="annot"><span class="hs-comment">{- |
= Pattern Match Compilation (Maranget's Algorithm)

This module compiles high-level pattern matching
into low-level Core @match@ expressions which only contain a single branch at once.

== The Pattern Matrix
We treat the match expressions as a matrix.
Given (in pseudo-Elara):
@
match x, y with
    Just a, Right b -&gt; 1
    _, Left c -&gt; 2
@

The initial matrix is constructed as:
@
       Col 0      Col 1
Row 1: [ Just a ] [ Right b ] =&gt; Body 1
Row 2: [ _      ] [ Left c  ] =&gt; Body 2
@
with scrutinees: @[x, y]@

== The Algorithm Step
We look at **Column 0** (the head) to decide what to do with variable @x@.
1. We see a constructor @Just@. We must generate a @match x with ...@.
2. We create a branch for @Just@. Inside this branch, @x@ is unwrapped into @payload@.
   We transform the matrix for this branch (&quot;Specialization&quot;):
   - Row 1 matches @Just a@. The pattern @Just a@ becomes @a@.
   - Row 2 is a wildcard @_@. It matches @Just@ too! We expand @_@ into @wildcard_payload@.

   New Matrix for &quot;Just&quot; branch:
   @
          New Col    Old Col 1
   Row 1: [ a      ] [ Right b ]
   Row 2: [ _      ] [ Left c  ]
   @
   New Scrutinees: [payload, y]

3. We recurse until the matrix is empty.
-}</span></span><span>
</span><span id="line-44"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html"><span class="hs-identifier">Elara.ToCore.Match</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.ToCore.Match.html#buildMatrix1"><span class="hs-identifier">buildMatrix1</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier">compileMatrix</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-45"></span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map.Strict</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">M</span></span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Matrix</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Mat</span></span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Text</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">toLower</span></span><span class="hs-special">)</span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Text</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">T</span></span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Eff</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(:&gt;)</span></span><span class="hs-special">)</span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Generic.Types.html"><span class="hs-identifier">Elara.AST.Generic.Types</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">AST</span></span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Name.html"><span class="hs-identifier">Elara.AST.Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#NameLike"><span class="hs-identifier">NameLike</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Name.html#Qualified"><span class="hs-identifier">Qualified</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Name.html#TypeName"><span class="hs-identifier">TypeName</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier">VarName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-53"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Region.html"><span class="hs-identifier">Elara.AST.Region</span></a></span><span>
</span><span id="line-54"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Typed.html"><span class="hs-identifier">Elara.AST.Typed</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Typed</span></span><span>
</span><span id="line-55"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.VarRef.html"><span class="hs-identifier">Elara.AST.VarRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.VarRef.html#UnlocatedVarRef"><span class="hs-identifier">UnlocatedVarRef</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.VarRef.html#VarRef%27"><span class="hs-identifier">VarRef'</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Core.html"><span class="hs-identifier">Elara.Core</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Core</span></span><span>
</span><span id="line-57"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Core.Analysis.html"><span class="hs-identifier">Elara.Core.Analysis</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Core</span></span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Core.Generic.html"><span class="hs-identifier">Elara.Core.Generic</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">G</span></span><span>
</span><span id="line-59"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Core.Pretty.html"><span class="hs-identifier">Elara.Core.Pretty</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-60"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Data.Pretty.html"><span class="hs-identifier">Elara.Data.Pretty</span></a></span><span>
</span><span id="line-61"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Data.Unique.html"><span class="hs-identifier">Elara.Data.Unique</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier">Unique</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-62"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Logging.html"><span class="hs-identifier">Elara.Logging</span></a></span><span>
</span><span id="line-63"></span><span>
</span><span id="line-64"></span><span class="annot"><span class="hs-comment">-- | Normalized pattern representation for the matrix</span></span><span>
</span><span id="line-65"></span><span class="hs-keyword">data</span><span> </span><span id="NPat"><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-var">NPat</span></a></span></span><span>
</span><span id="line-66"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-comment">-- | wildcard pattern</span></span><span>
</span><span id="line-67"></span><span>      </span><span id="PWild"><span class="annot"><a href="Elara.ToCore.Match.html#PWild"><span class="hs-identifier hs-var">PWild</span></a></span></span><span>
</span><span id="line-68"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-comment">-- | variable pattern that behaves like a wildcard but binds to a name</span></span><span>
</span><span id="line-69"></span><span>      </span><span id="PVar"><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-var">PVar</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier hs-type">Unique</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier hs-type">VarName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-70"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-comment">-- | Literal pattern</span></span><span>
</span><span id="line-71"></span><span>      </span><span id="PLit"><span class="annot"><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span></span><span> </span><span class="annot"><a href="Elara.Core.html#Literal"><span class="hs-identifier hs-type">Core.Literal</span></a></span><span>
</span><span id="line-72"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-comment">-- | constructor with subpatterns</span></span><span>
</span><span id="line-73"></span><span>      </span><span id="PCon"><span class="annot"><a href="Elara.ToCore.Match.html#PCon"><span class="hs-identifier hs-var">PCon</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#Qualified"><span class="hs-identifier hs-type">Qualified</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-74"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680187554"><span id="local-6989586621680187571"><span id="local-6989586621680187575"><span class="annot"><span class="annottext">Int -&gt; NPat -&gt; ShowS
[NPat] -&gt; ShowS
NPat -&gt; String
(Int -&gt; NPat -&gt; ShowS)
-&gt; (NPat -&gt; String) -&gt; ([NPat] -&gt; ShowS) -&gt; Show NPat
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; NPat -&gt; ShowS
showsPrec :: Int -&gt; NPat -&gt; ShowS
$cshow :: NPat -&gt; String
show :: NPat -&gt; String
$cshowList :: [NPat] -&gt; ShowS
showList :: [NPat] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187582"><span id="local-6989586621680187598"><span class="annot"><span class="annottext">NPat -&gt; NPat -&gt; Bool
(NPat -&gt; NPat -&gt; Bool) -&gt; (NPat -&gt; NPat -&gt; Bool) -&gt; Eq NPat
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: NPat -&gt; NPat -&gt; Bool
== :: NPat -&gt; NPat -&gt; Bool
$c/= :: NPat -&gt; NPat -&gt; Bool
/= :: NPat -&gt; NPat -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187605"><span id="local-6989586621680187607"><span class="annot"><span class="annottext">(forall x. NPat -&gt; Rep NPat x)
-&gt; (forall x. Rep NPat x -&gt; NPat) -&gt; Generic NPat
forall x. Rep NPat x -&gt; NPat
forall x. NPat -&gt; Rep NPat x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. NPat -&gt; Rep NPat x
from :: forall x. NPat -&gt; Rep NPat x
$cto :: forall x. Rep NPat x -&gt; NPat
to :: forall x. Rep NPat x -&gt; NPat
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-75"></span><span>
</span><span id="line-76"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621680187613"><span class="annot"><a href="Elara.Data.Pretty.html#Pretty"><span class="hs-identifier hs-type">Pretty</span></a></span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span></span><span>
</span><span id="line-77"></span><span>
</span><span id="line-78"></span><span class="annot"><span class="hs-comment">{- | The Pattern Matrix, parametrized over the type of the RHS expressions.
Invariant: @nrows pmPats == length pmRhs == length pmBinds@
-}</span></span><span>
</span><span id="line-81"></span><span class="hs-keyword">data</span><span> </span><span id="PMatrix"><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-var">PMatrix</span></a></span></span><span> </span><span id="local-6989586621680187393"><span class="annot"><a href="#local-6989586621680187393"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="PMatrix"><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-var">PMatrix</span></a></span></span><span>
</span><span id="line-82"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="pmPats"><span class="annot"><span class="annottext">forall a. PMatrix a -&gt; Matrix NPat
</span><a href="Elara.ToCore.Match.html#pmPats"><span class="hs-identifier hs-var hs-var">pmPats</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Mat.Matrix</span></span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span>
</span><span id="line-83"></span><span>    </span><span class="annot"><span class="hs-comment">{- ^ The grid of patterns.
    Rows correspond to match alternatives, columns to scrutinees.
    -}</span></span><span>
</span><span id="line-86"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="pmRhs"><span class="annot"><span class="annottext">forall a. PMatrix a -&gt; [a]
</span><a href="Elara.ToCore.Match.html#pmRhs"><span class="hs-identifier hs-var hs-var">pmRhs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621680187393"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-87"></span><span>    </span><span class="annot"><span class="hs-comment">{- ^ The right hand side (body) associated with each row.
    when a row is fully matched (i.e. all the columns are cleared), we emit this expression.
    -}</span></span><span>
</span><span id="line-90"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="pmBinds"><span class="annot"><span class="annottext">forall a. PMatrix a -&gt; [[(Unique VarName, Var)]]
</span><a href="Elara.ToCore.Match.html#pmBinds"><span class="hs-identifier hs-var hs-var">pmBinds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier hs-type">Unique</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier hs-type">VarName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><span id="line-91"></span><span>    </span><span class="annot"><span class="hs-comment">{- ^ Accumulated variable bindings for each row.
    As we traverse the matrix we encounter 'PVar' patterns which bind variables.
    Rather than immediately emitting @let@ bindings, we accumulate them here.
    If row N ends up matching, we emit @'pmRhs' !! N@ wrapped in @let@ bindings for all @'pmBinds' !! N@.
    -}</span></span><span>
</span><span id="line-96"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-97"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680187685"><span id="local-6989586621680187694"><span id="local-6989586621680187698"><span class="annot"><span class="annottext">Int -&gt; PMatrix a -&gt; ShowS
[PMatrix a] -&gt; ShowS
PMatrix a -&gt; String
(Int -&gt; PMatrix a -&gt; ShowS)
-&gt; (PMatrix a -&gt; String)
-&gt; ([PMatrix a] -&gt; ShowS)
-&gt; Show (PMatrix a)
forall a. Show a =&gt; Int -&gt; PMatrix a -&gt; ShowS
forall a. Show a =&gt; [PMatrix a] -&gt; ShowS
forall a. Show a =&gt; PMatrix a -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: forall a. Show a =&gt; Int -&gt; PMatrix a -&gt; ShowS
showsPrec :: Int -&gt; PMatrix a -&gt; ShowS
$cshow :: forall a. Show a =&gt; PMatrix a -&gt; String
show :: PMatrix a -&gt; String
$cshowList :: forall a. Show a =&gt; [PMatrix a] -&gt; ShowS
showList :: [PMatrix a] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187708"><span id="local-6989586621680187716"><span class="annot"><span class="annottext">PMatrix a -&gt; PMatrix a -&gt; Bool
(PMatrix a -&gt; PMatrix a -&gt; Bool)
-&gt; (PMatrix a -&gt; PMatrix a -&gt; Bool) -&gt; Eq (PMatrix a)
forall a. Eq a =&gt; PMatrix a -&gt; PMatrix a -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: forall a. Eq a =&gt; PMatrix a -&gt; PMatrix a -&gt; Bool
== :: PMatrix a -&gt; PMatrix a -&gt; Bool
$c/= :: forall a. Eq a =&gt; PMatrix a -&gt; PMatrix a -&gt; Bool
/= :: PMatrix a -&gt; PMatrix a -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-98"></span><span>
</span><span id="line-99"></span><span class="annot"><span class="hs-comment">{- | A row view of the matrix used for convenient iteration.
Tuple contains:
The list of patterns in this row (corresponding to the current columns)
The RHS for this row
The accumulated bindings for this row
-}</span></span><span>
</span><span id="line-105"></span><span class="hs-keyword">type</span><span> </span><span id="RichRow"><span class="annot"><a href="Elara.ToCore.Match.html#RichRow"><span class="hs-identifier hs-var">RichRow</span></a></span></span><span> </span><span id="local-6989586621680187725"><span class="annot"><a href="#local-6989586621680187725"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621680187725"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier hs-type">Unique</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier hs-type">VarName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-106"></span><span>
</span><span id="line-107"></span><span class="annot"><span class="hs-comment">{- | Initialise a matrix from a list of match arms.
This matrix typically starts with a single column (the top-level pattern matches).
As we decompose constructors, the matrix will grow wider.
-}</span></span><span>
</span><span id="line-111"></span><span id="local-6989586621680187411"><span class="annot"><a href="Elara.ToCore.Match.html#buildMatrix1"><span class="hs-identifier hs-type">buildMatrix1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Typed.html#TypedPattern"><span class="hs-identifier hs-type">TypedPattern</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621680187411"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187411"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-112"></span><span id="buildMatrix1"><span class="annot"><span class="annottext">buildMatrix1 :: forall a. [(TypedPattern, a)] -&gt; PMatrix a
</span><a href="Elara.ToCore.Match.html#buildMatrix1"><span class="hs-identifier hs-var hs-var">buildMatrix1</span></a></span></span><span> </span><span id="local-6989586621680187729"><span class="annot"><span class="annottext">[(TypedPattern, a)]
</span><a href="#local-6989586621680187729"><span class="hs-identifier hs-var">branches</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-113"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187730"><span class="annot"><span class="annottext">pats :: Matrix NPat
</span><a href="#local-6989586621680187730"><span class="hs-identifier hs-var hs-var">pats</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; [NPat] -&gt; Matrix NPat
forall a. Int -&gt; Int -&gt; [a] -&gt; Matrix a
</span><span class="hs-identifier hs-var">Mat.fromList</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(TypedPattern, a)] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[(TypedPattern, a)]
</span><a href="#local-6989586621680187729"><span class="hs-identifier hs-var">branches</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((TypedPattern, a) -&gt; NPat) -&gt; [(TypedPattern, a)] -&gt; [NPat]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TypedPattern -&gt; NPat
</span><a href="Elara.ToCore.Match.html#toNPat"><span class="hs-identifier hs-var">toNPat</span></a></span><span> </span><span class="annot"><span class="annottext">(TypedPattern -&gt; NPat)
-&gt; ((TypedPattern, a) -&gt; TypedPattern) -&gt; (TypedPattern, a) -&gt; NPat
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(TypedPattern, a) -&gt; TypedPattern
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[(TypedPattern, a)]
</span><a href="#local-6989586621680187729"><span class="hs-identifier hs-var">branches</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-114"></span><span>        </span><span id="local-6989586621680187736"><span class="annot"><span class="annottext">rhs :: [a]
</span><a href="#local-6989586621680187736"><span class="hs-identifier hs-var hs-var">rhs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((TypedPattern, a) -&gt; a) -&gt; [(TypedPattern, a)] -&gt; [a]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(TypedPattern, a) -&gt; a
forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span> </span><span class="annot"><span class="annottext">[(TypedPattern, a)]
</span><a href="#local-6989586621680187729"><span class="hs-identifier hs-var">branches</span></a></span><span>
</span><span id="line-115"></span><span>        </span><span id="local-6989586621680187738"><span class="annot"><span class="annottext">binds :: [[(Unique VarName, Var)]]
</span><a href="#local-6989586621680187738"><span class="hs-identifier hs-var hs-var">binds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [(Unique VarName, Var)] -&gt; [[(Unique VarName, Var)]]
forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">replicate</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(TypedPattern, a)] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[(TypedPattern, a)]
</span><a href="#local-6989586621680187729"><span class="hs-identifier hs-var">branches</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-116"></span><span>     </span><span class="hs-keyword">in</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span class="hs-special">{</span><span class="annot"><span class="annottext">pmPats :: Matrix NPat
</span><a href="Elara.ToCore.Match.html#pmPats"><span class="hs-identifier hs-var">pmPats</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Matrix NPat
</span><a href="#local-6989586621680187730"><span class="hs-identifier hs-var">pats</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmRhs :: [a]
</span><a href="Elara.ToCore.Match.html#pmRhs"><span class="hs-identifier hs-var">pmRhs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621680187736"><span class="hs-identifier hs-var">rhs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmBinds :: [[(Unique VarName, Var)]]
</span><a href="Elara.ToCore.Match.html#pmBinds"><span class="hs-identifier hs-var">pmBinds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[(Unique VarName, Var)]]
</span><a href="#local-6989586621680187738"><span class="hs-identifier hs-var">binds</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-117"></span><span>
</span><span id="line-118"></span><span class="annot"><span class="hs-comment">-- | Convert a TypedPattern into our normalized NPat form.</span></span><span>
</span><span id="line-119"></span><span class="annot"><a href="Elara.ToCore.Match.html#toNPat"><span class="hs-identifier hs-type">toNPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.AST.Typed.html#TypedPattern"><span class="hs-identifier hs-type">TypedPattern</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span>
</span><span id="line-120"></span><span id="toNPat"><span class="annot"><span class="annottext">toNPat :: TypedPattern -&gt; NPat
</span><a href="Elara.ToCore.Match.html#toNPat"><span class="hs-identifier hs-var hs-var">toNPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Generic.Types.html#Pattern"><span class="hs-identifier hs-type">AST.Pattern</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680187742"><span class="annot"><span class="annottext">Pattern' Typed
</span><a href="#local-6989586621680187742"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187743"><span class="annot"><span class="annottext">Select PatternType Typed
</span><a href="#local-6989586621680187743"><span class="hs-identifier hs-var">_t</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pattern' Typed -&gt; NPat
</span><a href="#local-6989586621680187744"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pattern' Typed
</span><a href="#local-6989586621680187742"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-121"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-122"></span><span>    </span><span id="local-6989586621680187744"><span class="annot"><span class="annottext">go :: Pattern' Typed -&gt; NPat
</span><a href="#local-6989586621680187744"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-123"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#IntegerPattern"><span class="hs-identifier hs-type">AST.IntegerPattern</span></a></span><span> </span><span id="local-6989586621680187746"><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621680187746"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Integer -&gt; Literal
</span><a href="Elara.Core.html#Int"><span class="hs-identifier hs-var">Core.Int</span></a></span><span> </span><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621680187746"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-124"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#FloatPattern"><span class="hs-identifier hs-type">AST.FloatPattern</span></a></span><span> </span><span id="local-6989586621680187749"><span class="annot"><span class="annottext">Double
</span><a href="#local-6989586621680187749"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Double -&gt; Literal
</span><a href="Elara.Core.html#Double"><span class="hs-identifier hs-var">Core.Double</span></a></span><span> </span><span class="annot"><span class="annottext">Double
</span><a href="#local-6989586621680187749"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-125"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#StringPattern"><span class="hs-identifier hs-type">AST.StringPattern</span></a></span><span> </span><span id="local-6989586621680187752"><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680187752"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Text -&gt; Literal
</span><a href="Elara.Core.html#String"><span class="hs-identifier hs-var">Core.String</span></a></span><span> </span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680187752"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-126"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#CharPattern"><span class="hs-identifier hs-type">AST.CharPattern</span></a></span><span> </span><span id="local-6989586621680187755"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680187755"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char -&gt; Literal
</span><a href="Elara.Core.html#Char"><span class="hs-identifier hs-var">Core.Char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680187755"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-127"></span><span>        </span><span class="annot"><span class="annottext">Pattern' Typed
</span><a href="Elara.AST.Generic.Types.html#UnitPattern"><span class="hs-identifier hs-var">AST.UnitPattern</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span>
</span><span id="line-128"></span><span>        </span><span class="annot"><span class="annottext">Pattern' Typed
</span><a href="Elara.AST.Generic.Types.html#WildcardPattern"><span class="hs-identifier hs-var">AST.WildcardPattern</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="Elara.ToCore.Match.html#PWild"><span class="hs-identifier hs-var">PWild</span></a></span><span>
</span><span id="line-129"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#VarPattern"><span class="hs-identifier hs-type">AST.VarPattern</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680187761"><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680187761"><span class="hs-identifier hs-var">uvn</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Unique VarName -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-var">PVar</span></a></span><span> </span><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680187761"><span class="hs-identifier hs-var">uvn</span></a></span><span>
</span><span id="line-130"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#ConstructorPattern"><span class="hs-identifier hs-type">AST.ConstructorPattern</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680187763"><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680187763"><span class="hs-identifier hs-var">qn</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621680187764"><span class="annot"><span class="annottext">[TypedPattern]
</span><a href="#local-6989586621680187764"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-131"></span><span>            </span><span class="annot"><span class="annottext">Qualified TypeName -&gt; [NPat] -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PCon"><span class="hs-identifier hs-var">PCon</span></a></span><span> </span><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680187763"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(TypedPattern -&gt; NPat) -&gt; [TypedPattern] -&gt; [NPat]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TypedPattern -&gt; NPat
</span><a href="Elara.ToCore.Match.html#toNPat"><span class="hs-identifier hs-var">toNPat</span></a></span><span> </span><span class="annot"><span class="annottext">[TypedPattern]
</span><a href="#local-6989586621680187764"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-132"></span><span>
</span><span id="line-133"></span><span class="annot"><span class="hs-comment">-- | A function that resolves a constructor name to its DataCon.</span></span><span>
</span><span id="line-134"></span><span class="hs-keyword">type</span><span> </span><span id="ConResolver"><span class="annot"><a href="Elara.ToCore.Match.html#ConResolver"><span class="hs-identifier hs-var">ConResolver</span></a></span></span><span> </span><span id="local-6989586621680187765"><span class="annot"><a href="#local-6989586621680187765"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Elara.AST.Name.html#Qualified"><span class="hs-identifier hs-type">Qualified</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680187765"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#DataCon"><span class="hs-identifier hs-type">Core.DataCon</span></a></span><span>
</span><span id="line-135"></span><span>
</span><span id="line-136"></span><span class="annot"><span class="hs-comment">-- | A function that generates a fresh local variable given a base name and type.</span></span><span>
</span><span id="line-137"></span><span class="hs-keyword">type</span><span> </span><span id="FreshLocal"><span class="annot"><a href="Elara.ToCore.Match.html#FreshLocal"><span class="hs-identifier hs-var">FreshLocal</span></a></span></span><span> </span><span id="local-6989586621680187766"><span class="annot"><a href="#local-6989586621680187766"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">T.Text</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Core.html#Type"><span class="hs-identifier hs-type">Core.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680187766"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span>
</span><span id="line-138"></span><span>
</span><span id="line-139"></span><span class="annot"><span class="hs-comment">{- | Compile a pattern matrix to a Core expression.

Assumes the first column of the matrix corresponds to the first variable in the 'scruts' list.
This function is recursive:
1. If the matrix is empty (width 0), we are done, so we emit the RHS of the first valid row.
2. If we have patterns but no scrutinees, we emit a unit value (which indicates a non-exhaustive match).
3. Otherwise, we inspect the first column ('processHeadColumn') to decide how to branch, and recurse.
-}</span></span><span>
</span><span id="line-147"></span><span id="local-6989586621680187440"><span class="annot"><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-type">compileMatrix</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-148"></span><span>    </span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier hs-type">StructuredDebug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680187440"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-149"></span><span>    </span><span class="annot"><span class="hs-comment">-- | Function to resolve constructor names</span></span><span>
</span><span id="line-150"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#ConResolver"><span class="hs-identifier hs-type">ConResolver</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680187440"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-151"></span><span>    </span><span class="annot"><span class="hs-comment">-- | Function to generate fresh local variables</span></span><span>
</span><span id="line-152"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#FreshLocal"><span class="hs-identifier hs-type">FreshLocal</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680187440"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-153"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The scrutinee variables</span></span><span>
</span><span id="line-154"></span><span>    </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-155"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The pattern matrix</span></span><span>
</span><span id="line-156"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-157"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The compiled Core expression</span></span><span>
</span><span id="line-158"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680187440"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span></span><span>
</span><span id="line-159"></span><span id="compileMatrix"><span class="annot"><span class="annottext">compileMatrix :: forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-var hs-var">compileMatrix</span></a></span></span><span> </span><span id="local-6989586621680187782"><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680187782"><span class="hs-identifier hs-var">resolveCon</span></a></span></span><span> </span><span id="local-6989586621680187783"><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680187783"><span class="hs-identifier hs-var">fresh</span></a></span></span><span> </span><span id="local-6989586621680187784"><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680187784"><span class="hs-identifier hs-var">scruts</span></a></span></span><span> </span><span id="local-6989586621680187785"><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680187785"><span class="hs-identifier hs-var">pm</span></a></span></span><span>
</span><span id="line-160"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Matrix NPat -&gt; Int
forall a. Matrix a -&gt; Int
</span><span class="hs-identifier hs-var">Mat.ncols</span></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680187785"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmPats</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="hs-comment">-- base case: no more columns, so all patterns matched</span><span>
</span><span id="line-161"></span><span>        </span><span class="hs-glyph">=</span><span>
</span><span id="line-162"></span><span>        </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680187785"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680187785"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-comment">-- pick the first row that matches</span><span>
</span><span id="line-163"></span><span>            </span><span class="hs-special">(</span><span id="local-6989586621680187787"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680187787"><span class="hs-identifier hs-var">rhs0</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><span class="annottext">[CoreExpr]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187788"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680187788"><span class="hs-identifier hs-var">binds0</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><span class="annottext">[[(Unique VarName, Var)]]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(Unique VarName, Var)] -&gt; CoreExpr -&gt; CoreExpr
</span><a href="Elara.ToCore.Match.html#emitBinds"><span class="hs-identifier hs-var">emitBinds</span></a></span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680187788"><span class="hs-identifier hs-var">binds0</span></a></span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680187787"><span class="hs-identifier hs-var">rhs0</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-164"></span><span>            </span><span class="annot"><span class="annottext">([CoreExpr], [[(Unique VarName, Var)]])
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Literal -&gt; CoreExpr
forall b. Literal -&gt; Expr b
</span><a href="Elara.Core.html#Lit"><span class="hs-identifier hs-var">Core.Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- this implies the match is not exhaustive. should probably error?</span><span>
</span><span id="line-165"></span><span>            </span><span class="hs-comment">-- No scrutinees left (shouldn't happen if cols &gt; 0).</span><span>
</span><span id="line-166"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">[Var] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680187784"><span class="hs-identifier hs-var">scruts</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Literal -&gt; CoreExpr
forall b. Literal -&gt; Expr b
</span><a href="Elara.Core.html#Lit"><span class="hs-identifier hs-var">Core.Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-167"></span><span>    </span><span class="hs-comment">-- Recursively decompose the matrix based on Column 0.</span><span>
</span><span id="line-168"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#processHeadColumn"><span class="hs-identifier hs-var">processHeadColumn</span></a></span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680187782"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680187783"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680187784"><span class="hs-identifier hs-var">scruts</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680187785"><span class="hs-identifier hs-var">pm</span></a></span><span>
</span><span id="line-169"></span><span>
</span><span id="line-170"></span><span class="annot"><span class="hs-comment">{- | The core logic: Examine Column 0 and determine the branching strategy.
We extract Column 0 and split the matrix rows into groups:
1. Rows matching specific Constructors.
2. Rows matching specific Literals.
3. &quot;Default&quot; rows (Wildcards/Vars) that match everything.
-}</span></span><span>
</span><span id="line-176"></span><span id="local-6989586621680187792"><span class="annot"><a href="Elara.ToCore.Match.html#processHeadColumn"><span class="hs-identifier hs-type">processHeadColumn</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-177"></span><span>    </span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier hs-type">StructuredDebug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680187792"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-178"></span><span>    </span><span class="annot"><span class="hs-comment">-- | Function to resolve constructor names</span></span><span>
</span><span id="line-179"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#ConResolver"><span class="hs-identifier hs-type">ConResolver</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680187792"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-180"></span><span>    </span><span class="annot"><span class="hs-comment">-- | Function to generate fresh local variables</span></span><span>
</span><span id="line-181"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#FreshLocal"><span class="hs-identifier hs-type">FreshLocal</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680187792"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-182"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The scrutinee variables</span></span><span>
</span><span id="line-183"></span><span>    </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-184"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The pattern matrix</span></span><span>
</span><span id="line-185"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-186"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The compiled Core expression</span></span><span>
</span><span id="line-187"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680187792"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span></span><span>
</span><span id="line-188"></span><span id="processHeadColumn"><span class="annot"><span class="annottext">processHeadColumn :: forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#processHeadColumn"><span class="hs-identifier hs-var hs-var">processHeadColumn</span></a></span></span><span> </span><span id="local-6989586621680187808"><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680187808"><span class="hs-identifier hs-var">resolveCon</span></a></span></span><span> </span><span id="local-6989586621680187809"><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680187809"><span class="hs-identifier hs-var">fresh</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680187810"><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680187810"><span class="hs-identifier hs-var">s0</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621680187811"><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680187811"><span class="hs-identifier hs-var">restScruts</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621680187812"><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680187812"><span class="hs-identifier hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-189"></span><span>    </span><span class="hs-comment">-- Explode Matrix into RichRows for safe iteration without index partiality</span><span>
</span><span id="line-190"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187813"><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187813"><span class="hs-identifier hs-var hs-var">rows</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#RichRow"><span class="hs-identifier hs-type">RichRow</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[NPat]]
-&gt; [CoreExpr] -&gt; [[(Unique VarName, Var)]] -&gt; [RichRow CoreExpr]
forall a b c. [a] -&gt; [b] -&gt; [c] -&gt; [(a, b, c)]
</span><span class="hs-identifier hs-var">zip3</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Matrix NPat -&gt; [[NPat]]
forall a. Matrix a -&gt; [[a]]
</span><span class="hs-identifier hs-var">Mat.toLists</span></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680187812"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmPats</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680187812"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680187812"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-191"></span><span>
</span><span id="line-192"></span><span>    </span><span class="hs-comment">-- partition the rows based on the head pattern in each row</span><span>
</span><span id="line-193"></span><span>    </span><span class="hs-comment">-- conMap = mapping constructors to the rows that match them</span><span>
</span><span id="line-194"></span><span>    </span><span class="hs-comment">-- litMap = mapping literals to the rows that match them</span><span>
</span><span id="line-195"></span><span>    </span><span class="hs-comment">-- defaults = rows that are wildcards/vars at head</span><span>
</span><span id="line-196"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680187816"><span class="annot"><span class="annottext">Map (Qualified TypeName) [RichRow CoreExpr]
</span><a href="#local-6989586621680187816"><span class="hs-identifier hs-var">conMap</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187817"><span class="annot"><span class="annottext">Map Literal [RichRow CoreExpr]
</span><a href="#local-6989586621680187817"><span class="hs-identifier hs-var">litMap</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187818"><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187818"><span class="hs-identifier hs-var">defaults</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr]
-&gt; (Map (Qualified TypeName) [RichRow CoreExpr],
    Map Literal [RichRow CoreExpr], [RichRow CoreExpr])
forall a.
[RichRow a]
-&gt; (Map (Qualified TypeName) [RichRow a], Map Literal [RichRow a],
    [RichRow a])
</span><a href="Elara.ToCore.Match.html#partitionRows"><span class="hs-identifier hs-var">partitionRows</span></a></span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187813"><span class="hs-identifier hs-var">rows</span></a></span><span>
</span><span id="line-197"></span><span>
</span><span id="line-198"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [RichRow CoreExpr] -&gt; Bool
forall k a. Map k a -&gt; Bool
</span><span class="hs-identifier hs-var">M.null</span></span><span> </span><span class="annot"><span class="annottext">Map (Qualified TypeName) [RichRow CoreExpr]
</span><a href="#local-6989586621680187816"><span class="hs-identifier hs-var">conMap</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-199"></span><span>        </span><span class="hs-keyword">then</span><span> </span><span class="hs-comment">-- we have some constructor cases to compile, so we have to emit a match over s0</span><span>
</span><span id="line-200"></span><span>            </span><span class="annot"><span class="annottext">ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; Var
-&gt; [Var]
-&gt; Map (Qualified TypeName) [RichRow CoreExpr]
-&gt; [RichRow CoreExpr]
-&gt; Eff r CoreExpr
forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; Var
-&gt; [Var]
-&gt; Map (Qualified TypeName) [RichRow CoreExpr]
-&gt; [RichRow CoreExpr]
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#compileConstructorCases"><span class="hs-identifier hs-var">compileConstructorCases</span></a></span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680187808"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680187809"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680187810"><span class="hs-identifier hs-var">s0</span></a></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680187811"><span class="hs-identifier hs-var">restScruts</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Qualified TypeName) [RichRow CoreExpr]
</span><a href="#local-6989586621680187816"><span class="hs-identifier hs-var">conMap</span></a></span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187818"><span class="hs-identifier hs-var">defaults</span></a></span><span>
</span><span id="line-201"></span><span>        </span><span class="hs-keyword">else</span><span>
</span><span id="line-202"></span><span>            </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Literal [RichRow CoreExpr] -&gt; Bool
forall k a. Map k a -&gt; Bool
</span><span class="hs-identifier hs-var">M.null</span></span><span> </span><span class="annot"><span class="annottext">Map Literal [RichRow CoreExpr]
</span><a href="#local-6989586621680187817"><span class="hs-identifier hs-var">litMap</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-203"></span><span>                </span><span class="hs-keyword">then</span><span> </span><span class="hs-comment">-- we have some literal cases to compile, so we have to emit a match over s0</span><span>
</span><span id="line-204"></span><span>                    </span><span class="annot"><span class="annottext">ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; Var
-&gt; [Var]
-&gt; Map Literal [RichRow CoreExpr]
-&gt; [RichRow CoreExpr]
-&gt; Eff r CoreExpr
forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; Var
-&gt; [Var]
-&gt; Map Literal [RichRow CoreExpr]
-&gt; [RichRow CoreExpr]
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#compileLiteralCases"><span class="hs-identifier hs-var">compileLiteralCases</span></a></span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680187808"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680187809"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680187810"><span class="hs-identifier hs-var">s0</span></a></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680187811"><span class="hs-identifier hs-var">restScruts</span></a></span><span> </span><span class="annot"><span class="annottext">Map Literal [RichRow CoreExpr]
</span><a href="#local-6989586621680187817"><span class="hs-identifier hs-var">litMap</span></a></span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187818"><span class="hs-identifier hs-var">defaults</span></a></span><span>
</span><span id="line-205"></span><span>                </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-206"></span><span>                    </span><span class="hs-comment">-- the only remaining cases are defaults (wildcards/vars)</span><span>
</span><span id="line-207"></span><span>                    </span><span class="hs-comment">-- therefore we don't need any branching, and we can just &quot;consume&quot; s0</span><span>
</span><span id="line-208"></span><span>                    </span><span class="hs-comment">-- we effectively treat s0 as matched by all rows, and remove it from the scrutinee list</span><span>
</span><span id="line-209"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187824"><span class="annot"><span class="annottext">newRows :: [RichRow CoreExpr]
</span><a href="#local-6989586621680187824"><span class="hs-identifier hs-var hs-var">newRows</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(RichRow CoreExpr -&gt; RichRow CoreExpr)
-&gt; [RichRow CoreExpr] -&gt; [RichRow CoreExpr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Var -&gt; RichRow CoreExpr -&gt; RichRow CoreExpr
forall a. Int -&gt; Var -&gt; RichRow a -&gt; RichRow a
</span><a href="Elara.ToCore.Match.html#expandDefaultRow"><span class="hs-identifier hs-var">expandDefaultRow</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680187810"><span class="hs-identifier hs-var">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187818"><span class="hs-identifier hs-var">defaults</span></a></span><span>
</span><span id="line-210"></span><span>                    </span><span class="annot"><span class="annottext">ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-var">compileMatrix</span></a></span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680187808"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680187809"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680187811"><span class="hs-identifier hs-var">restScruts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[RichRow CoreExpr] -&gt; PMatrix CoreExpr
forall a. [RichRow a] -&gt; PMatrix a
</span><a href="Elara.ToCore.Match.html#rebuildMatrix"><span class="hs-identifier hs-var">rebuildMatrix</span></a></span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187824"><span class="hs-identifier hs-var">newRows</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-211"></span><span class="annot"><a href="Elara.ToCore.Match.html#processHeadColumn"><span class="hs-identifier hs-var">processHeadColumn</span></a></span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Text -&gt; Eff r CoreExpr
forall a t. (HasCallStack, IsText t) =&gt; t -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;processHeadColumn: No scrutinee available&quot;</span></span><span>
</span><span id="line-212"></span><span>
</span><span id="line-213"></span><span class="annot"><span class="hs-comment">{- | Compile a match on Constructors (e.g. @match x with { Just y -&gt; ... } @).

For every constructor @C@ that appears in the column:
1. Generate a @Case C@ branch.
2. Inside that branch, @x@ is unwrapped into fields @f1, f2...@.
3. Construct a new sub-matrix for this branch:
   - For rows matching @C f1 f2@, we replace @C f1 f2@ with @f1, f2@.
   - For default rows @_@, we expand @_@ into @_ _@ (one wild for each field).
4. Recurse on the sub-matrix with new scrutinees @[f1, f2, ...rest]@.
-}</span></span><span>
</span><span id="line-223"></span><span id="local-6989586621680187469"><span class="annot"><a href="Elara.ToCore.Match.html#compileConstructorCases"><span class="hs-identifier hs-type">compileConstructorCases</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-224"></span><span>    </span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier hs-type">StructuredDebug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680187469"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-225"></span><span>    </span><span class="annot"><span class="hs-comment">-- | Function to resolve constructor names</span></span><span>
</span><span id="line-226"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#ConResolver"><span class="hs-identifier hs-type">ConResolver</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680187469"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-227"></span><span>    </span><span class="annot"><span class="hs-comment">-- | Function to generate fresh local variables</span></span><span>
</span><span id="line-228"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#FreshLocal"><span class="hs-identifier hs-type">FreshLocal</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680187469"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-229"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The scrutinee variable for this column, e.g. @x@</span></span><span>
</span><span id="line-230"></span><span>    </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-231"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The remaining scrutinee variables that correspond to later columns</span></span><span>
</span><span id="line-232"></span><span>    </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-233"></span><span>    </span><span class="annot"><span class="hs-comment">-- | Map of constructor names to the rows that match them</span></span><span>
</span><span id="line-234"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">M.Map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#Qualified"><span class="hs-identifier hs-type">Qualified</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#RichRow"><span class="hs-identifier hs-type">RichRow</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-235"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The default rows (wildcards/vars)</span></span><span>
</span><span id="line-236"></span><span>    </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#RichRow"><span class="hs-identifier hs-type">RichRow</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-237"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680187469"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span></span><span>
</span><span id="line-238"></span><span id="compileConstructorCases"><span class="annot"><span class="annottext">compileConstructorCases :: forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; Var
-&gt; [Var]
-&gt; Map (Qualified TypeName) [RichRow CoreExpr]
-&gt; [RichRow CoreExpr]
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#compileConstructorCases"><span class="hs-identifier hs-var hs-var">compileConstructorCases</span></a></span></span><span> </span><span id="local-6989586621680187861"><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680187861"><span class="hs-identifier hs-var">resolveCon</span></a></span></span><span> </span><span id="local-6989586621680187862"><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680187862"><span class="hs-identifier hs-var">fresh</span></a></span></span><span> </span><span id="local-6989586621680187863"><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680187863"><span class="hs-identifier hs-var">s0</span></a></span></span><span> </span><span id="local-6989586621680187864"><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680187864"><span class="hs-identifier hs-var">restScruts</span></a></span></span><span> </span><span id="local-6989586621680187865"><span class="annot"><span class="annottext">Map (Qualified TypeName) [RichRow CoreExpr]
</span><a href="#local-6989586621680187865"><span class="hs-identifier hs-var">conMap</span></a></span></span><span> </span><span id="local-6989586621680187866"><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187866"><span class="hs-identifier hs-var">defaults</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-239"></span><span>    </span><span id="local-6989586621680187867"><span class="annot"><a href="#local-6989586621680187867"><span class="hs-identifier hs-var">conAlts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Qualified TypeName, [RichRow CoreExpr])]
-&gt; ((Qualified TypeName, [RichRow CoreExpr])
    -&gt; Eff r (AltCon, [Var], CoreExpr))
-&gt; Eff r [(AltCon, [Var], CoreExpr)]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m (t b)
</span><span class="hs-identifier hs-var">forM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [RichRow CoreExpr]
-&gt; [(Qualified TypeName, [RichRow CoreExpr])]
forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">M.toList</span></span><span> </span><span class="annot"><span class="annottext">Map (Qualified TypeName) [RichRow CoreExpr]
</span><a href="#local-6989586621680187865"><span class="hs-identifier hs-var">conMap</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(((Qualified TypeName, [RichRow CoreExpr])
  -&gt; Eff r (AltCon, [Var], CoreExpr))
 -&gt; Eff r [(AltCon, [Var], CoreExpr)])
-&gt; ((Qualified TypeName, [RichRow CoreExpr])
    -&gt; Eff r (AltCon, [Var], CoreExpr))
-&gt; Eff r [(AltCon, [Var], CoreExpr)]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680187870"><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680187870"><span class="hs-identifier hs-var">conName</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187871"><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187871"><span class="hs-identifier hs-var">matchedRows</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-240"></span><span>        </span><span id="local-6989586621680187872"><span class="annot"><a href="#local-6989586621680187872"><span class="hs-identifier hs-var">dc</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680187861"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680187870"><span class="hs-identifier hs-var">conName</span></a></span><span>
</span><span id="line-241"></span><span>
</span><span id="line-242"></span><span>        </span><span class="hs-comment">-- first we need to figure out the types of the constructor fields</span><span>
</span><span id="line-243"></span><span>        </span><span class="hs-comment">-- to determine the types of the fields being unwrapped</span><span>
</span><span id="line-244"></span><span>        </span><span class="hs-comment">-- as DataCon can be polymorphic, we have to perform type substitution based on the scrutinee type</span><span>
</span><span id="line-245"></span><span>
</span><span id="line-246"></span><span>        </span><span class="hs-comment">-- the type of the scrutinee variable</span><span>
</span><span id="line-247"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187873"><span class="annot"><a href="#local-6989586621680187873"><span class="hs-identifier hs-var hs-var">scrutType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Var -&gt; Type
</span><a href="Elara.Core.Analysis.html#varType"><span class="hs-identifier hs-var">Core.varType</span></a></span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680187863"><span class="hs-identifier hs-var">s0</span></a></span><span>
</span><span id="line-248"></span><span>        </span><span class="hs-comment">-- the arguments that the scrutinee's type constructor was applied to</span><span>
</span><span id="line-249"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187875"><span class="annot"><a href="#local-6989586621680187875"><span class="hs-identifier hs-var hs-var">scrutTypeArgs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Type]
</span><a href="Elara.Core.html#conTyArgs"><span class="hs-identifier hs-var">Core.conTyArgs</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621680187873"><span class="hs-identifier hs-var">scrutType</span></a></span><span>
</span><span id="line-250"></span><span>        </span><span class="hs-comment">-- then we split the DataCon type into its forall'd type variables and the core type</span><span>
</span><span id="line-251"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680187877"><span class="annot"><a href="#local-6989586621680187877"><span class="hs-identifier hs-var">dcTyVars</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187878"><span class="annot"><a href="#local-6989586621680187878"><span class="hs-identifier hs-var">dcTau</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Elara.Core.Analysis.html#splitForAlls"><span class="hs-identifier hs-type">Core.splitForAlls</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#dataConType"><span class="hs-identifier hs-var">Core.dataConType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187872"><span class="hs-identifier hs-type">dc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-252"></span><span>
</span><span id="line-253"></span><span>        </span><span class="hs-comment">-- now we create a substitution from the DataCon's type variables to the scrutinee's type arguments</span><span>
</span><span id="line-254"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187881"><span class="annot"><a href="#local-6989586621680187881"><span class="hs-identifier hs-var hs-var">subst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(TypeVariable, Type)] -&gt; Map TypeVariable Type
forall k a. Ord k =&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">M.fromList</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TypeVariable] -&gt; [Type] -&gt; [(TypeVariable, Type)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[TypeVariable]
</span><a href="#local-6989586621680187877"><span class="hs-identifier hs-var">dcTyVars</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621680187875"><span class="hs-identifier hs-var">scrutTypeArgs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-255"></span><span>        </span><span class="hs-comment">-- and apply that substitution to each argument type of the DataCon</span><span>
</span><span id="line-256"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187883"><span class="annot"><a href="#local-6989586621680187883"><span class="hs-identifier hs-var hs-var">dcArgTysRaw</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Type]
</span><a href="Elara.Core.html#functionTypeArgs"><span class="hs-identifier hs-var">Core.functionTypeArgs</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621680187878"><span class="hs-identifier hs-var">dcTau</span></a></span><span>
</span><span id="line-257"></span><span>        </span><span class="hs-comment">-- this gives us the real types of the constructor fields in this context</span><span>
</span><span id="line-258"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187885"><span class="annot"><a href="#local-6989586621680187885"><span class="hs-identifier hs-var hs-var">realArgTys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; [Type] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map TypeVariable Type -&gt; Type -&gt; Type
</span><a href="Elara.Core.Analysis.html#substType"><span class="hs-identifier hs-var">Core.substType</span></a></span><span> </span><span class="annot"><span class="annottext">Map TypeVariable Type
</span><a href="#local-6989586621680187881"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621680187883"><span class="hs-identifier hs-var">dcArgTysRaw</span></a></span><span>
</span><span id="line-259"></span><span>
</span><span id="line-260"></span><span>        </span><span class="hs-comment">-- now we can create a fresh local variable for each of the constructor fields</span><span>
</span><span id="line-261"></span><span>        </span><span id="local-6989586621680187887"><span class="annot"><a href="#local-6989586621680187887"><span class="hs-identifier hs-var">fieldVars</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">forM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">zip</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">..</span><span class="hs-special">]</span><span> </span><span class="annot"><a href="#local-6989586621680187885"><span class="hs-identifier hs-type">realArgTys</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-262"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187888"><span class="annot"><a href="#local-6989586621680187888"><span class="hs-identifier hs-var hs-var">namePrefix</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680187870"><span class="hs-identifier hs-var">conName</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-263"></span><span>                    </span><span class="annot"><a href="Elara.AST.Name.html#Qualified"><span class="hs-identifier hs-type">Qualified</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span> </span><span id="local-6989586621680187891"><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680187891"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ModuleName
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Text -&gt; Text
</span><span class="hs-identifier hs-var">toLower</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680187891"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Text -&gt; Text -&gt; Text
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;_field_&quot;</span></span><span>
</span><span id="line-264"></span><span>            </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680187892"><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621680187892"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187893"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621680187893"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680187862"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680187888"><span class="hs-identifier hs-var">namePrefix</span></a></span><span> </span><span class="annot"><span class="annottext">Text -&gt; Text -&gt; Text
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Integer -&gt; Text
forall b a. (Show a, IsString b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621680187892"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621680187893"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-265"></span><span>
</span><span id="line-266"></span><span>        </span><span class="hs-comment">-- build the new matrix for this constructor branch</span><span>
</span><span id="line-267"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187895"><span class="annot"><a href="#local-6989586621680187895"><span class="hs-identifier hs-var hs-var">expandedDefaults</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(RichRow CoreExpr -&gt; RichRow CoreExpr)
-&gt; [RichRow CoreExpr] -&gt; [RichRow CoreExpr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Var -&gt; RichRow CoreExpr -&gt; RichRow CoreExpr
forall a. Int -&gt; Var -&gt; RichRow a -&gt; RichRow a
</span><a href="Elara.ToCore.Match.html#expandDefaultRow"><span class="hs-identifier hs-var">expandDefaultRow</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Var] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680187887"><span class="hs-identifier hs-var">fieldVars</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680187863"><span class="hs-identifier hs-var">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187866"><span class="hs-identifier hs-var">defaults</span></a></span><span>
</span><span id="line-268"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187896"><span class="annot"><a href="#local-6989586621680187896"><span class="hs-identifier hs-var hs-var">allRows</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187871"><span class="hs-identifier hs-var">matchedRows</span></a></span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr] -&gt; [RichRow CoreExpr] -&gt; [RichRow CoreExpr]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187895"><span class="hs-identifier hs-var">expandedDefaults</span></a></span><span>
</span><span id="line-269"></span><span>
</span><span id="line-270"></span><span>        </span><span class="hs-comment">-- recurse on the new matrix with the new scrutinees (the constructor fields + the remaining scrutinees)</span><span>
</span><span id="line-271"></span><span>        </span><span id="local-6989586621680187897"><span class="annot"><a href="#local-6989586621680187897"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-type">compileMatrix</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187861"><span class="hs-identifier hs-type">resolveCon</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187862"><span class="hs-identifier hs-type">fresh</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680187887"><span class="hs-identifier hs-type">fieldVars</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680187864"><span class="hs-identifier hs-type">restScruts</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.ToCore.Match.html#rebuildMatrix"><span class="hs-identifier hs-type">rebuildMatrix</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187896"><span class="hs-identifier hs-type">allRows</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-272"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#DataAlt"><span class="hs-identifier hs-type">Core.DataAlt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187872"><span class="hs-identifier hs-type">dc</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621680187887"><span class="hs-identifier hs-type">fieldVars</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621680187897"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-273"></span><span>
</span><span id="line-274"></span><span>    </span><span id="local-6989586621680187899"><span class="annot"><a href="#local-6989586621680187899"><span class="hs-identifier hs-var">defAlt</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#compileDefaultBranch"><span class="hs-identifier hs-type">compileDefaultBranch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187861"><span class="hs-identifier hs-type">resolveCon</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187862"><span class="hs-identifier hs-type">fresh</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187863"><span class="hs-identifier hs-type">s0</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187864"><span class="hs-identifier hs-type">restScruts</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187866"><span class="hs-identifier hs-type">defaults</span></a></span><span>
</span><span id="line-275"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="Elara.Core.html#Match"><span class="hs-identifier hs-type">Core.Match</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187863"><span class="hs-identifier hs-type">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><a href="#local-6989586621680187863"><span class="hs-identifier hs-type">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680187867"><span class="hs-identifier hs-type">conAlts</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">++</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">maybeToList</span></span><span> </span><span class="annot"><a href="#local-6989586621680187899"><span class="hs-identifier hs-type">defAlt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-276"></span><span>
</span><span id="line-277"></span><span class="annot"><span class="hs-comment">-- | Compile a match on Literals (e.g. @match x with { 1 -&gt; ... } @).</span></span><span>
</span><span id="line-278"></span><span id="local-6989586621680187470"><span class="annot"><a href="Elara.ToCore.Match.html#compileLiteralCases"><span class="hs-identifier hs-type">compileLiteralCases</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-279"></span><span>    </span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier hs-type">StructuredDebug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680187470"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-280"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#ConResolver"><span class="hs-identifier hs-type">ConResolver</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680187470"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-281"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#FreshLocal"><span class="hs-identifier hs-type">FreshLocal</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680187470"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-282"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The scrutinee variable for this column, e.g. @x@</span></span><span>
</span><span id="line-283"></span><span>    </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-284"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The remaining scrutinee variables that correspond to later columns</span></span><span>
</span><span id="line-285"></span><span>    </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-286"></span><span>    </span><span class="annot"><span class="hs-comment">-- | Map of literals to the rows that match them</span></span><span>
</span><span id="line-287"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">M.Map</span></span><span> </span><span class="annot"><a href="Elara.Core.html#Literal"><span class="hs-identifier hs-type">Core.Literal</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#RichRow"><span class="hs-identifier hs-type">RichRow</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-288"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The default rows (wildcards/vars)</span></span><span>
</span><span id="line-289"></span><span>    </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#RichRow"><span class="hs-identifier hs-type">RichRow</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-290"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680187470"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span></span><span>
</span><span id="line-291"></span><span id="compileLiteralCases"><span class="annot"><span class="annottext">compileLiteralCases :: forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; Var
-&gt; [Var]
-&gt; Map Literal [RichRow CoreExpr]
-&gt; [RichRow CoreExpr]
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#compileLiteralCases"><span class="hs-identifier hs-var hs-var">compileLiteralCases</span></a></span></span><span> </span><span id="local-6989586621680187915"><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680187915"><span class="hs-identifier hs-var">resolveCon</span></a></span></span><span> </span><span id="local-6989586621680187916"><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680187916"><span class="hs-identifier hs-var">fresh</span></a></span></span><span> </span><span id="local-6989586621680187917"><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680187917"><span class="hs-identifier hs-var">s0</span></a></span></span><span> </span><span id="local-6989586621680187918"><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680187918"><span class="hs-identifier hs-var">restScruts</span></a></span></span><span> </span><span id="local-6989586621680187919"><span class="annot"><span class="annottext">Map Literal [RichRow CoreExpr]
</span><a href="#local-6989586621680187919"><span class="hs-identifier hs-var">litMap</span></a></span></span><span> </span><span id="local-6989586621680187920"><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187920"><span class="hs-identifier hs-var">defaults</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-292"></span><span>    </span><span id="local-6989586621680187921"><span class="annot"><a href="#local-6989586621680187921"><span class="hs-identifier hs-var">litAlts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Literal, [RichRow CoreExpr])]
-&gt; ((Literal, [RichRow CoreExpr])
    -&gt; Eff r (AltCon, [Var], CoreExpr))
-&gt; Eff r [(AltCon, [Var], CoreExpr)]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m (t b)
</span><span class="hs-identifier hs-var">forM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Literal [RichRow CoreExpr] -&gt; [(Literal, [RichRow CoreExpr])]
forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">M.toList</span></span><span> </span><span class="annot"><span class="annottext">Map Literal [RichRow CoreExpr]
</span><a href="#local-6989586621680187919"><span class="hs-identifier hs-var">litMap</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(((Literal, [RichRow CoreExpr]) -&gt; Eff r (AltCon, [Var], CoreExpr))
 -&gt; Eff r [(AltCon, [Var], CoreExpr)])
-&gt; ((Literal, [RichRow CoreExpr])
    -&gt; Eff r (AltCon, [Var], CoreExpr))
-&gt; Eff r [(AltCon, [Var], CoreExpr)]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680187922"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621680187922"><span class="hs-identifier hs-var">lit</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187923"><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187923"><span class="hs-identifier hs-var">matchedRows</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-293"></span><span>        </span><span class="hs-comment">-- literals have no fields to unwrap, so we just build the new matrix directly</span><span>
</span><span id="line-294"></span><span>        </span><span class="hs-comment">-- Matched rows have head column removed.</span><span>
</span><span id="line-295"></span><span>        </span><span class="hs-comment">-- Default rows need head column removed (arity 0 expansion).</span><span>
</span><span id="line-296"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187924"><span class="annot"><span class="annottext">expandedDefaults :: [RichRow CoreExpr]
</span><a href="#local-6989586621680187924"><span class="hs-identifier hs-var hs-var hs-var">expandedDefaults</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(RichRow CoreExpr -&gt; RichRow CoreExpr)
-&gt; [RichRow CoreExpr] -&gt; [RichRow CoreExpr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Var -&gt; RichRow CoreExpr -&gt; RichRow CoreExpr
forall a. Int -&gt; Var -&gt; RichRow a -&gt; RichRow a
</span><a href="Elara.ToCore.Match.html#expandDefaultRow"><span class="hs-identifier hs-var">expandDefaultRow</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680187917"><span class="hs-identifier hs-var">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187920"><span class="hs-identifier hs-var">defaults</span></a></span><span>
</span><span id="line-297"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187925"><span class="annot"><span class="annottext">allRows :: [RichRow CoreExpr]
</span><a href="#local-6989586621680187925"><span class="hs-identifier hs-var hs-var hs-var">allRows</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187923"><span class="hs-identifier hs-var">matchedRows</span></a></span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr] -&gt; [RichRow CoreExpr] -&gt; [RichRow CoreExpr]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187924"><span class="hs-identifier hs-var">expandedDefaults</span></a></span><span>
</span><span id="line-298"></span><span>
</span><span id="line-299"></span><span>        </span><span id="local-6989586621680187926"><span class="annot"><a href="#local-6989586621680187926"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-var">compileMatrix</span></a></span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680187915"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680187916"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680187918"><span class="hs-identifier hs-var">restScruts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[RichRow CoreExpr] -&gt; PMatrix CoreExpr
forall a. [RichRow a] -&gt; PMatrix a
</span><a href="Elara.ToCore.Match.html#rebuildMatrix"><span class="hs-identifier hs-var">rebuildMatrix</span></a></span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187925"><span class="hs-identifier hs-var">allRows</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-300"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#LitAlt"><span class="hs-identifier hs-type">Core.LitAlt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187922"><span class="hs-identifier hs-type">lit</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621680187926"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-301"></span><span>
</span><span id="line-302"></span><span>    </span><span id="local-6989586621680187928"><span class="annot"><a href="#local-6989586621680187928"><span class="hs-identifier hs-var">defAlt</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#compileDefaultBranch"><span class="hs-identifier hs-type">compileDefaultBranch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187915"><span class="hs-identifier hs-type">resolveCon</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187916"><span class="hs-identifier hs-type">fresh</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187917"><span class="hs-identifier hs-type">s0</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187918"><span class="hs-identifier hs-type">restScruts</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187920"><span class="hs-identifier hs-type">defaults</span></a></span><span>
</span><span id="line-303"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="Elara.Core.html#Match"><span class="hs-identifier hs-type">Core.Match</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187917"><span class="hs-identifier hs-type">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><a href="#local-6989586621680187917"><span class="hs-identifier hs-type">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680187921"><span class="hs-identifier hs-type">litAlts</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">++</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">maybeToList</span></span><span> </span><span class="annot"><a href="#local-6989586621680187928"><span class="hs-identifier hs-type">defAlt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-304"></span><span>
</span><span id="line-305"></span><span class="annot"><span class="hs-comment">{- | Compile the default branch for a @Match@ expression.
This handles rows that didn't match any specific Constructor/Literal in the other branches,
and generates a 'Core.DEFAULT' branch.
If there are no default rows, we return 'Nothing'.
-}</span></span><span>
</span><span id="line-310"></span><span id="local-6989586621680187504"><span class="annot"><a href="Elara.ToCore.Match.html#compileDefaultBranch"><span class="hs-identifier hs-type">compileDefaultBranch</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-311"></span><span>    </span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier hs-type">StructuredDebug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680187504"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-312"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#ConResolver"><span class="hs-identifier hs-type">ConResolver</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680187504"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-313"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#FreshLocal"><span class="hs-identifier hs-type">FreshLocal</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680187504"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-314"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The scrutinee variable for this column, e.g. @x@</span></span><span>
</span><span id="line-315"></span><span>    </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-316"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The remaining scrutinee variables that correspond to later columns</span></span><span>
</span><span id="line-317"></span><span>    </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-318"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The default rows (wildcards/vars)</span></span><span>
</span><span id="line-319"></span><span>    </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#RichRow"><span class="hs-identifier hs-type">RichRow</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-320"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680187504"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreAlt"><span class="hs-identifier hs-type">Core.CoreAlt</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-321"></span><span id="compileDefaultBranch"><span class="annot"><span class="annottext">compileDefaultBranch :: forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; Var
-&gt; [Var]
-&gt; [RichRow CoreExpr]
-&gt; Eff r (Maybe (AltCon, [Var], CoreExpr))
</span><a href="Elara.ToCore.Match.html#compileDefaultBranch"><span class="hs-identifier hs-var hs-var">compileDefaultBranch</span></a></span></span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Var
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (AltCon, [Var], CoreExpr)
-&gt; Eff r (Maybe (AltCon, [Var], CoreExpr))
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe (AltCon, [Var], CoreExpr)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-322"></span><span class="annot"><a href="Elara.ToCore.Match.html#compileDefaultBranch"><span class="hs-identifier hs-var">compileDefaultBranch</span></a></span><span> </span><span id="local-6989586621680187936"><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680187936"><span class="hs-identifier hs-var">resolveCon</span></a></span></span><span> </span><span id="local-6989586621680187937"><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680187937"><span class="hs-identifier hs-var">fresh</span></a></span></span><span> </span><span id="local-6989586621680187938"><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680187938"><span class="hs-identifier hs-var">s0</span></a></span></span><span> </span><span id="local-6989586621680187939"><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680187939"><span class="hs-identifier hs-var">restScruts</span></a></span></span><span> </span><span id="local-6989586621680187940"><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187940"><span class="hs-identifier hs-var">defaults</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-323"></span><span>    </span><span class="hs-comment">-- Strip the default pattern from head</span><span>
</span><span id="line-324"></span><span>    </span><span class="hs-comment">-- If it was a PVar, record the binding to s0.</span><span>
</span><span id="line-325"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187941"><span class="annot"><span class="annottext">newRows :: [RichRow CoreExpr]
</span><a href="#local-6989586621680187941"><span class="hs-identifier hs-var hs-var hs-var">newRows</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(RichRow CoreExpr -&gt; RichRow CoreExpr)
-&gt; [RichRow CoreExpr] -&gt; [RichRow CoreExpr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Var -&gt; RichRow CoreExpr -&gt; RichRow CoreExpr
forall a. Int -&gt; Var -&gt; RichRow a -&gt; RichRow a
</span><a href="Elara.ToCore.Match.html#expandDefaultRow"><span class="hs-identifier hs-var">expandDefaultRow</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680187938"><span class="hs-identifier hs-var">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187940"><span class="hs-identifier hs-var">defaults</span></a></span><span>
</span><span id="line-326"></span><span>    </span><span id="local-6989586621680187942"><span class="annot"><a href="#local-6989586621680187942"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-var">compileMatrix</span></a></span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680187936"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680187937"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680187939"><span class="hs-identifier hs-var">restScruts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[RichRow CoreExpr] -&gt; PMatrix CoreExpr
forall a. [RichRow a] -&gt; PMatrix a
</span><a href="Elara.ToCore.Match.html#rebuildMatrix"><span class="hs-identifier hs-var">rebuildMatrix</span></a></span><span> </span><span class="annot"><span class="annottext">[RichRow CoreExpr]
</span><a href="#local-6989586621680187941"><span class="hs-identifier hs-var">newRows</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-327"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#DEFAULT"><span class="hs-identifier hs-type">Core.DEFAULT</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621680187942"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-328"></span><span>
</span><span id="line-329"></span><span class="annot"><span class="hs-comment">-- | Converts a list of 'RichRows' back into the 'PMatrix' structure required for recursion</span></span><span>
</span><span id="line-330"></span><span id="local-6989586621680187472"><span class="annot"><a href="Elara.ToCore.Match.html#rebuildMatrix"><span class="hs-identifier hs-type">rebuildMatrix</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#RichRow"><span class="hs-identifier hs-type">RichRow</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187472"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187472"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-331"></span><span id="rebuildMatrix"><span class="annot"><span class="annottext">rebuildMatrix :: forall a. [RichRow a] -&gt; PMatrix a
</span><a href="Elara.ToCore.Match.html#rebuildMatrix"><span class="hs-identifier hs-var hs-var">rebuildMatrix</span></a></span></span><span> </span><span id="local-6989586621680187943"><span class="annot"><span class="annottext">[RichRow a]
</span><a href="#local-6989586621680187943"><span class="hs-identifier hs-var">rows</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-332"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680187944"><span class="annot"><span class="annottext">[[NPat]]
</span><a href="#local-6989586621680187944"><span class="hs-identifier hs-var">pats</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187945"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621680187945"><span class="hs-identifier hs-var">rhs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187946"><span class="annot"><span class="annottext">[[(Unique VarName, Var)]]
</span><a href="#local-6989586621680187946"><span class="hs-identifier hs-var">binds</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[RichRow a] -&gt; ([[NPat]], [a], [[(Unique VarName, Var)]])
forall a b c. [(a, b, c)] -&gt; ([a], [b], [c])
</span><span class="hs-identifier hs-var">unzip3</span></span><span> </span><span class="annot"><span class="annottext">[RichRow a]
</span><a href="#local-6989586621680187943"><span class="hs-identifier hs-var">rows</span></a></span><span>
</span><span id="line-333"></span><span>     </span><span class="hs-keyword">in</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span>
</span><span id="line-334"></span><span>            </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pmPats :: Matrix NPat
</span><a href="Elara.ToCore.Match.html#pmPats"><span class="hs-identifier hs-var">pmPats</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[NPat]] -&gt; Matrix NPat
forall a. [[a]] -&gt; Matrix a
</span><span class="hs-identifier hs-var">Mat.fromLists</span></span><span> </span><span class="annot"><span class="annottext">[[NPat]]
</span><a href="#local-6989586621680187944"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-335"></span><span>            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmRhs :: [a]
</span><a href="Elara.ToCore.Match.html#pmRhs"><span class="hs-identifier hs-var">pmRhs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621680187945"><span class="hs-identifier hs-var">rhs</span></a></span><span>
</span><span id="line-336"></span><span>            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmBinds :: [[(Unique VarName, Var)]]
</span><a href="Elara.ToCore.Match.html#pmBinds"><span class="hs-identifier hs-var">pmBinds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[(Unique VarName, Var)]]
</span><a href="#local-6989586621680187946"><span class="hs-identifier hs-var">binds</span></a></span><span>
</span><span id="line-337"></span><span>            </span><span class="hs-special">}</span><span>
</span><span id="line-338"></span><span>
</span><span id="line-339"></span><span class="annot"><span class="hs-comment">-- | Partition a list of 'RichRow's into constructor cases, literal cases, and default cases.</span></span><span>
</span><span id="line-340"></span><span id="local-6989586621680187466"><span class="annot"><a href="Elara.ToCore.Match.html#partitionRows"><span class="hs-identifier hs-type">partitionRows</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-341"></span><span>    </span><span class="annot"><span class="hs-comment">-- | Input rows</span></span><span>
</span><span id="line-342"></span><span>    </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#RichRow"><span class="hs-identifier hs-type">RichRow</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187466"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-343"></span><span>    </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier hs-type">M.Map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#Qualified"><span class="hs-identifier hs-type">Qualified</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#RichRow"><span class="hs-identifier hs-type">RichRow</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187466"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-344"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- \^ Constructor cases</span><span>
</span><span id="line-345"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">M.Map</span></span><span> </span><span class="annot"><a href="Elara.Core.html#Literal"><span class="hs-identifier hs-type">Core.Literal</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#RichRow"><span class="hs-identifier hs-type">RichRow</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187466"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-346"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- \^ Literal cases</span><span>
</span><span id="line-347"></span><span>      </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#RichRow"><span class="hs-identifier hs-type">RichRow</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187466"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-348"></span><span>    </span><span class="hs-special">)</span></span><span>
</span><span id="line-349"></span><span class="hs-comment">-- \^ Default cases</span><span>
</span><span id="line-350"></span><span>
</span><span id="line-351"></span><span id="partitionRows"><span class="annot"><span class="annottext">partitionRows :: forall a.
[RichRow a]
-&gt; (Map (Qualified TypeName) [RichRow a], Map Literal [RichRow a],
    [RichRow a])
</span><a href="Elara.ToCore.Match.html#partitionRows"><span class="hs-identifier hs-var hs-var">partitionRows</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(RichRow a
 -&gt; (Map (Qualified TypeName) [RichRow a], Map Literal [RichRow a],
     [RichRow a])
 -&gt; (Map (Qualified TypeName) [RichRow a], Map Literal [RichRow a],
     [RichRow a]))
-&gt; (Map (Qualified TypeName) [RichRow a], Map Literal [RichRow a],
    [RichRow a])
-&gt; [RichRow a]
-&gt; (Map (Qualified TypeName) [RichRow a], Map Literal [RichRow a],
    [RichRow a])
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">RichRow a
-&gt; (Map (Qualified TypeName) [RichRow a], Map Literal [RichRow a],
    [RichRow a])
-&gt; (Map (Qualified TypeName) [RichRow a], Map Literal [RichRow a],
    [RichRow a])
forall {b} {c}.
([NPat], b, c)
-&gt; (Map (Qualified TypeName) [([NPat], b, c)],
    Map Literal [([NPat], b, c)], [([NPat], b, c)])
-&gt; (Map (Qualified TypeName) [([NPat], b, c)],
    Map Literal [([NPat], b, c)], [([NPat], b, c)])
</span><a href="#local-6989586621680187951"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [RichRow a]
forall k a. Map k a
</span><span class="hs-identifier hs-var">M.empty</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Literal [RichRow a]
forall k a. Map k a
</span><span class="hs-identifier hs-var">M.empty</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-352"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-353"></span><span>    </span><span id="local-6989586621680187951"><span class="annot"><span class="annottext">go :: ([NPat], b, c)
-&gt; (Map (Qualified TypeName) [([NPat], b, c)],
    Map Literal [([NPat], b, c)], [([NPat], b, c)])
-&gt; (Map (Qualified TypeName) [([NPat], b, c)],
    Map Literal [([NPat], b, c)], [([NPat], b, c)])
</span><a href="#local-6989586621680187951"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621680187962"><span class="annot"><span class="annottext">row :: ([NPat], b, c)
</span><a href="#local-6989586621680187962"><span class="hs-identifier hs-var">row</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span id="local-6989586621680187963"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680187963"><span class="hs-identifier hs-var">pats</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187964"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621680187964"><span class="hs-identifier hs-var">rhs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187965"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621680187965"><span class="hs-identifier hs-var">binds</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680187966"><span class="annot"><span class="annottext">Map (Qualified TypeName) [([NPat], b, c)]
</span><a href="#local-6989586621680187966"><span class="hs-identifier hs-var">cons</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187967"><span class="annot"><span class="annottext">Map Literal [([NPat], b, c)]
</span><a href="#local-6989586621680187967"><span class="hs-identifier hs-var">lits</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187968"><span class="annot"><span class="annottext">[([NPat], b, c)]
</span><a href="#local-6989586621680187968"><span class="hs-identifier hs-var">defs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-354"></span><span>        </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680187963"><span class="hs-identifier hs-var">pats</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-355"></span><span>            </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [([NPat], b, c)]
</span><a href="#local-6989586621680187966"><span class="hs-identifier hs-var">cons</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Literal [([NPat], b, c)]
</span><a href="#local-6989586621680187967"><span class="hs-identifier hs-var">lits</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[([NPat], b, c)]
</span><a href="#local-6989586621680187968"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Should be unreachable if cols &gt; 0</span><span>
</span><span id="line-356"></span><span>            </span><span class="hs-special">(</span><span id="local-6989586621680187969"><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680187969"><span class="hs-identifier hs-var">headPattern</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621680187970"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680187970"><span class="hs-identifier hs-var">remainingPatterns</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680187969"><span class="hs-identifier hs-var">headPattern</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-357"></span><span>                </span><span class="annot"><a href="Elara.ToCore.Match.html#PCon"><span class="hs-identifier hs-type">PCon</span></a></span><span> </span><span id="local-6989586621680187971"><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680187971"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621680187972"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680187972"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-358"></span><span>                    </span><span class="hs-comment">-- constructor pattern</span><span>
</span><span id="line-359"></span><span>                    </span><span class="hs-comment">-- expand the subpatterns into the row</span><span>
</span><span id="line-360"></span><span>                    </span><span class="hs-comment">-- the new column 'PCon' gets replaced by its subpatterns 'args'</span><span>
</span><span id="line-361"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187973"><span class="annot"><span class="annottext">newRow :: ([NPat], b, c)
</span><a href="#local-6989586621680187973"><span class="hs-identifier hs-var hs-var">newRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680187972"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="annot"><span class="annottext">[NPat] -&gt; [NPat] -&gt; [NPat]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680187970"><span class="hs-identifier hs-var">remainingPatterns</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621680187964"><span class="hs-identifier hs-var">rhs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621680187965"><span class="hs-identifier hs-var">binds</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-362"></span><span>                     </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">([([NPat], b, c)] -&gt; [([NPat], b, c)] -&gt; [([NPat], b, c)])
-&gt; Qualified TypeName
-&gt; [([NPat], b, c)]
-&gt; Map (Qualified TypeName) [([NPat], b, c)]
-&gt; Map (Qualified TypeName) [([NPat], b, c)]
forall k a. Ord k =&gt; (a -&gt; a -&gt; a) -&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">M.insertWith</span></span><span> </span><span class="annot"><span class="annottext">[([NPat], b, c)] -&gt; [([NPat], b, c)] -&gt; [([NPat], b, c)]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">(&lt;&gt;)</span></span><span> </span><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680187971"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">([NPat], b, c)
</span><a href="#local-6989586621680187973"><span class="hs-identifier hs-var">newRow</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Map (Qualified TypeName) [([NPat], b, c)]
</span><a href="#local-6989586621680187966"><span class="hs-identifier hs-var">cons</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Literal [([NPat], b, c)]
</span><a href="#local-6989586621680187967"><span class="hs-identifier hs-var">lits</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[([NPat], b, c)]
</span><a href="#local-6989586621680187968"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-363"></span><span>                </span><span class="annot"><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-type">PLit</span></a></span><span> </span><span id="local-6989586621680187975"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621680187975"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-364"></span><span>                    </span><span class="hs-comment">-- literal pattern</span><span>
</span><span id="line-365"></span><span>                    </span><span class="hs-comment">-- strip the literal</span><span>
</span><span id="line-366"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187976"><span class="annot"><span class="annottext">newRow :: ([NPat], b, c)
</span><a href="#local-6989586621680187976"><span class="hs-identifier hs-var hs-var">newRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680187970"><span class="hs-identifier hs-var">remainingPatterns</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621680187964"><span class="hs-identifier hs-var">rhs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621680187965"><span class="hs-identifier hs-var">binds</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-367"></span><span>                     </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [([NPat], b, c)]
</span><a href="#local-6989586621680187966"><span class="hs-identifier hs-var">cons</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">([([NPat], b, c)] -&gt; [([NPat], b, c)] -&gt; [([NPat], b, c)])
-&gt; Literal
-&gt; [([NPat], b, c)]
-&gt; Map Literal [([NPat], b, c)]
-&gt; Map Literal [([NPat], b, c)]
forall k a. Ord k =&gt; (a -&gt; a -&gt; a) -&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">M.insertWith</span></span><span> </span><span class="annot"><span class="annottext">[([NPat], b, c)] -&gt; [([NPat], b, c)] -&gt; [([NPat], b, c)]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">(&lt;&gt;)</span></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621680187975"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">([NPat], b, c)
</span><a href="#local-6989586621680187976"><span class="hs-identifier hs-var">newRow</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Map Literal [([NPat], b, c)]
</span><a href="#local-6989586621680187967"><span class="hs-identifier hs-var">lits</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[([NPat], b, c)]
</span><a href="#local-6989586621680187968"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-368"></span><span>                </span><span class="annot"><span class="annottext">NPat
</span><a href="Elara.ToCore.Match.html#PWild"><span class="hs-identifier hs-var">PWild</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [([NPat], b, c)]
</span><a href="#local-6989586621680187966"><span class="hs-identifier hs-var">cons</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Literal [([NPat], b, c)]
</span><a href="#local-6989586621680187967"><span class="hs-identifier hs-var">lits</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">([NPat], b, c)
</span><a href="#local-6989586621680187962"><span class="hs-identifier hs-var">row</span></a></span><span> </span><span class="annot"><span class="annottext">([NPat], b, c) -&gt; [([NPat], b, c)] -&gt; [([NPat], b, c)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[([NPat], b, c)]
</span><a href="#local-6989586621680187968"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- keep the row as-is so that the default branch can expand it later</span><span>
</span><span id="line-369"></span><span>                </span><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-type">PVar</span></a></span><span> </span><span class="annot"><span class="annottext">Unique VarName
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [([NPat], b, c)]
</span><a href="#local-6989586621680187966"><span class="hs-identifier hs-var">cons</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Literal [([NPat], b, c)]
</span><a href="#local-6989586621680187967"><span class="hs-identifier hs-var">lits</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">([NPat], b, c)
</span><a href="#local-6989586621680187962"><span class="hs-identifier hs-var">row</span></a></span><span> </span><span class="annot"><span class="annottext">([NPat], b, c) -&gt; [([NPat], b, c)] -&gt; [([NPat], b, c)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[([NPat], b, c)]
</span><a href="#local-6989586621680187968"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-370"></span><span>
</span><span id="line-371"></span><span class="annot"><span class="hs-comment">{- | Takes a Default row and adapts it to match a Constructor branch.

1. Records the binding if the head was 'PVar' (binds @x = s0@).
2. Expands the head into @n@ wildcards to match the arity of the constructor.
   e.g. if matching 'Just' (arity 1), `_` becomes `_` (matching the payload).
   e.g. if matching 'Either' (arity 2), `_` becomes `_ _`.
-}</span></span><span>
</span><span id="line-378"></span><span id="local-6989586621680187471"><span class="annot"><a href="Elara.ToCore.Match.html#expandDefaultRow"><span class="hs-identifier hs-type">expandDefaultRow</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-379"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-380"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The scrutinee variable being matched against</span></span><span>
</span><span id="line-381"></span><span>    </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-382"></span><span>    </span><span class="annot"><span class="hs-comment">-- | The input row</span></span><span>
</span><span id="line-383"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#RichRow"><span class="hs-identifier hs-type">RichRow</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187471"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-384"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#RichRow"><span class="hs-identifier hs-type">RichRow</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680187471"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-385"></span><span id="expandDefaultRow"><span class="annot"><span class="annottext">expandDefaultRow :: forall a. Int -&gt; Var -&gt; RichRow a -&gt; RichRow a
</span><a href="Elara.ToCore.Match.html#expandDefaultRow"><span class="hs-identifier hs-var hs-var">expandDefaultRow</span></a></span></span><span> </span><span id="local-6989586621680187978"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680187978"><span class="hs-identifier hs-var">numFields</span></a></span></span><span> </span><span id="local-6989586621680187979"><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680187979"><span class="hs-identifier hs-var">s0</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680187980"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680187980"><span class="hs-identifier hs-var">pats</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187981"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680187981"><span class="hs-identifier hs-var">rhs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680187982"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680187982"><span class="hs-identifier hs-var">binds</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-386"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680187980"><span class="hs-identifier hs-var">pats</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-387"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680187981"><span class="hs-identifier hs-var">rhs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680187982"><span class="hs-identifier hs-var">binds</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-388"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621680187983"><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680187983"><span class="hs-identifier hs-var">headPat</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621680187984"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680187984"><span class="hs-identifier hs-var">tailPats</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-389"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187985"><span class="annot"><span class="annottext">newHead :: [NPat]
</span><a href="#local-6989586621680187985"><span class="hs-identifier hs-var hs-var">newHead</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; NPat -&gt; [NPat]
forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">replicate</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680187978"><span class="hs-identifier hs-var">numFields</span></a></span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="Elara.ToCore.Match.html#PWild"><span class="hs-identifier hs-var">PWild</span></a></span><span>
</span><span id="line-390"></span><span>                </span><span id="local-6989586621680187986"><span class="annot"><span class="annottext">newBinds :: [(Unique VarName, Var)]
</span><a href="#local-6989586621680187986"><span class="hs-identifier hs-var hs-var">newBinds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680187983"><span class="hs-identifier hs-var">headPat</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-391"></span><span>                    </span><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-type">PVar</span></a></span><span> </span><span id="local-6989586621680187987"><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680187987"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680187987"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680187979"><span class="hs-identifier hs-var">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Unique VarName, Var)
-&gt; [(Unique VarName, Var)] -&gt; [(Unique VarName, Var)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680187982"><span class="hs-identifier hs-var">binds</span></a></span><span>
</span><span id="line-392"></span><span>                    </span><span class="annot"><span class="annottext">NPat
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680187982"><span class="hs-identifier hs-var">binds</span></a></span><span>
</span><span id="line-393"></span><span>             </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680187985"><span class="hs-identifier hs-var">newHead</span></a></span><span> </span><span class="annot"><span class="annottext">[NPat] -&gt; [NPat] -&gt; [NPat]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680187984"><span class="hs-identifier hs-var">tailPats</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680187981"><span class="hs-identifier hs-var">rhs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680187986"><span class="hs-identifier hs-var">newBinds</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-394"></span><span>
</span><span id="line-395"></span><span class="annot"><span class="hs-comment">{- | Emit let-bindings around a Core expression.
Bindings are emitted in reverse order (first in list is innermost let).
-}</span></span><span>
</span><span id="line-398"></span><span class="annot"><a href="Elara.ToCore.Match.html#emitBinds"><span class="hs-identifier hs-type">emitBinds</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-399"></span><span>    </span><span class="annot"><span class="hs-comment">-- | bindings to emit</span></span><span>
</span><span id="line-400"></span><span>    </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier hs-type">Unique</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier hs-type">VarName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-401"></span><span>    </span><span class="annot"><span class="hs-comment">-- | body expression</span></span><span>
</span><span id="line-402"></span><span>    </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-403"></span><span>    </span><span class="annot"><span class="hs-comment">-- | resulting expression with lets</span></span><span>
</span><span id="line-404"></span><span>    </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span>
</span><span id="line-405"></span><span id="emitBinds"><span class="annot"><span class="annottext">emitBinds :: [(Unique VarName, Var)] -&gt; CoreExpr -&gt; CoreExpr
</span><a href="Elara.ToCore.Match.html#emitBinds"><span class="hs-identifier hs-var hs-var">emitBinds</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span id="local-6989586621680187991"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680187991"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680187991"><span class="hs-identifier hs-var">body</span></a></span><span>
</span><span id="line-406"></span><span class="annot"><a href="Elara.ToCore.Match.html#emitBinds"><span class="hs-identifier hs-var">emitBinds</span></a></span><span> </span><span id="local-6989586621680187992"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680187992"><span class="hs-identifier hs-var">bs</span></a></span></span><span> </span><span id="local-6989586621680187993"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680187993"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-407"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680187998"><span class="annot"><span class="annottext">mkLet :: ((Unique a, Var), CoreExpr) -&gt; CoreExpr
</span><a href="#local-6989586621680187998"><span class="hs-identifier hs-var hs-var">mkLet</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span id="local-6989586621680187999"><span class="annot"><span class="annottext">Unique a
</span><a href="#local-6989586621680187999"><span class="hs-identifier hs-var">u</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680188000"><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680188000"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span id="local-6989586621680188001"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680188001"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-408"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680188002"><span class="annot"><span class="annottext">uqText :: Unique Text
</span><a href="#local-6989586621680188002"><span class="hs-identifier hs-var hs-var">uqText</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Text) -&gt; Unique a -&gt; Unique Text
forall a b. (a -&gt; b) -&gt; Unique a -&gt; Unique b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Text
forall name. NameLike name =&gt; name -&gt; Text
</span><a href="Elara.AST.Name.html#nameText"><span class="hs-identifier hs-var">nameText</span></a></span><span> </span><span class="annot"><span class="annottext">Unique a
</span><a href="#local-6989586621680187999"><span class="hs-identifier hs-var">u</span></a></span><span>
</span><span id="line-409"></span><span>                </span><span id="local-6989586621680188004"><span class="annot"><span class="annottext">varRef :: UnlocatedVarRef Text
</span><a href="#local-6989586621680188004"><span class="hs-identifier hs-var hs-var">varRef</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VarRefImpl UnlocatedVarRefKind (Unique Text)
-&gt; UnlocatedVarRef Text
forall (c :: VarRefKind) n. VarRefImpl c (Unique n) -&gt; VarRef' c n
</span><a href="Elara.AST.VarRef.html#Local"><span class="hs-identifier hs-var">Local</span></a></span><span> </span><span class="annot"><span class="annottext">Unique Text
VarRefImpl UnlocatedVarRefKind (Unique Text)
</span><a href="#local-6989586621680188002"><span class="hs-identifier hs-var">uqText</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.AST.VarRef.html#UnlocatedVarRef"><span class="hs-identifier hs-type">UnlocatedVarRef</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">T.Text</span></span><span>
</span><span id="line-410"></span><span>                </span><span id="local-6989586621680188006"><span class="annot"><span class="annottext">binder :: Var
</span><a href="#local-6989586621680188006"><span class="hs-identifier hs-var hs-var">binder</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">UnlocatedVarRef Text -&gt; Type -&gt; Maybe DataCon -&gt; Var
</span><a href="Elara.Core.html#Id"><span class="hs-identifier hs-var">Core.Id</span></a></span><span> </span><span class="annot"><span class="annottext">UnlocatedVarRef Text
</span><a href="#local-6989586621680188004"><span class="hs-identifier hs-var">varRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Var -&gt; Type
</span><a href="Elara.Core.Analysis.html#varType"><span class="hs-identifier hs-var">Core.varType</span></a></span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680188000"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe DataCon
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-411"></span><span>             </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Bind Var -&gt; CoreExpr -&gt; CoreExpr
forall b. Bind b -&gt; Expr b -&gt; Expr b
</span><a href="Elara.Core.html#Let"><span class="hs-identifier hs-var">Core.Let</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Var, CoreExpr) -&gt; Bind Var
forall b (expr :: * -&gt; *). (b, expr b) -&gt; Bind b expr
</span><a href="Elara.Core.Generic.html#NonRecursive"><span class="hs-identifier hs-var">G.NonRecursive</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680188006"><span class="hs-identifier hs-var">binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Var -&gt; CoreExpr
forall b. b -&gt; Expr b
</span><a href="Elara.Core.html#Var"><span class="hs-identifier hs-var">Core.Var</span></a></span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680188000"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680188001"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-412"></span><span>     </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">((Unique VarName, Var) -&gt; CoreExpr -&gt; CoreExpr)
-&gt; CoreExpr -&gt; [(Unique VarName, Var)] -&gt; CoreExpr
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(((Unique VarName, Var), CoreExpr) -&gt; CoreExpr)
-&gt; (Unique VarName, Var) -&gt; CoreExpr -&gt; CoreExpr
forall a b c. ((a, b) -&gt; c) -&gt; a -&gt; b -&gt; c
</span><span class="hs-identifier hs-var">curry</span></span><span> </span><span class="annot"><span class="annottext">((Unique VarName, Var), CoreExpr) -&gt; CoreExpr
forall {a}. NameLike a =&gt; ((Unique a, Var), CoreExpr) -&gt; CoreExpr
</span><a href="#local-6989586621680187998"><span class="hs-identifier hs-var">mkLet</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680187993"><span class="hs-identifier hs-var">body</span></a></span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680187992"><span class="hs-identifier hs-var">bs</span></a></span><span>
</span><span id="line-413"></span></pre></body></html>