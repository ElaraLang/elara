<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="annot"><span class="hs-comment">{- |
Maranget-style pattern match compilation using a compact pattern matrix.

This module normalises surface patterns into 'NPat' and compiles a matrix
of such patterns into Core case expressions. We store the rectangular grid
of patterns in a 'Data.Matrix.Matrix', while per-row metadata (RHS payloads
and accumulated variable bindings) are kept in parallel lists aligned by
row index.

Key points:
- We always discriminate on column 0 (the head scrutinee) and recursively
  refine the matrix.
- Variable patterns behave as wildcards for decision making, but we record
  their binds and emit them as nested non-recursive Core lets at leaves.
- Constructor alternatives extend the scrutinee list with freshly bound
  field variables and push their argument patterns into the matrix.
-}</span></span><span>
</span><span id="line-20"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html"><span class="hs-identifier">Elara.ToCore.Match</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-21"></span><span>
</span><span id="line-22"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map.Strict</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">M</span></span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Matrix</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Mat</span></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Text</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">T</span></span><span>
</span><span id="line-25"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Eff</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(:&gt;)</span></span><span class="hs-special">)</span><span>
</span><span id="line-26"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Generic.Types.html"><span class="hs-identifier">Elara.AST.Generic.Types</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">AST</span></span><span>
</span><span id="line-27"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Name.html"><span class="hs-identifier">Elara.AST.Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#ModuleName"><span class="hs-identifier">ModuleName</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Name.html#NameLike"><span class="hs-identifier">NameLike</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Name.html#Qualified"><span class="hs-identifier">Qualified</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Name.html#TypeName"><span class="hs-identifier">TypeName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier">VarName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-28"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Region.html"><span class="hs-identifier">Elara.AST.Region</span></a></span><span>
</span><span id="line-29"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Typed.html"><span class="hs-identifier">Elara.AST.Typed</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Typed</span></span><span>
</span><span id="line-30"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.VarRef.html"><span class="hs-identifier">Elara.AST.VarRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.VarRef.html#UnlocatedVarRef"><span class="hs-identifier">UnlocatedVarRef</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.VarRef.html#VarRef%27"><span class="hs-identifier">VarRef'</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Core.html"><span class="hs-identifier">Elara.Core</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Core</span></span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Core.Analysis.html"><span class="hs-identifier">Elara.Core.Analysis</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Core</span></span><span>
</span><span id="line-33"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Core.Generic.html"><span class="hs-identifier">Elara.Core.Generic</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">G</span></span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Core.Pretty.html"><span class="hs-identifier">Elara.Core.Pretty</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Data.Pretty.html"><span class="hs-identifier">Elara.Data.Pretty</span></a></span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Data.Unique.html"><span class="hs-identifier">Elara.Data.Unique</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier">Unique</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Logging.html"><span class="hs-identifier">Elara.Logging</span></a></span><span>
</span><span id="line-38"></span><span>
</span><span id="line-39"></span><span class="hs-comment">{- Our initial step in compiling pattern matching is to construct a pattern matrix
of the patterns used in a match
For example, consider the following code:
@
f l = match l with
    (Nil, _) -&gt; x
    (_, Nil) -&gt; y
    (Cons x xs, Cons y ys) -&gt; z
@

The ultimate goal with this desugaring process is to turn all pattern matching into simple matches upon either:
- A single value
- A constructor with its values bound as variables

For example, the above code would be desugared into something like:
@
f l = match l with
    (x, y) -&gt; match x with
        Nil -&gt; x
        _ -&gt; match y with
            Nil -&gt; y
            _ -&gt; z
@

however this is difficult to do in a single pass.

Basic pattern-matrix construction

We define a small normalized pattern language (NPat) that abstracts over the
surface TypedPattern forms but keeps exactly the information a matrix needs:

- Wildcards/variables as default-able cases (we record var names for later binds)
- Literals as equality-discriminated heads
- Constructors with their subpatterns (still in NPat form). We keep the
  constructor as a qualified Text (no DataCon resolution here) to avoid
  coupling and cycles; resolution can happen later when building Core.

For now we build a single-column matrix since `match` in the current AST
matches one scrutinee. Product (tuple/record) expansion can be layered on later
by transforming the first column.
-}</span><span>
</span><span id="line-80"></span><span>
</span><span id="line-81"></span><span class="annot"><span class="hs-comment">-- | Normalized pattern</span></span><span>
</span><span id="line-82"></span><span class="hs-keyword">data</span><span> </span><span id="NPat"><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-var">NPat</span></a></span></span><span>
</span><span id="line-83"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="PWild"><span class="annot"><a href="Elara.ToCore.Match.html#PWild"><span class="hs-identifier hs-var">PWild</span></a></span></span><span>
</span><span id="line-84"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PVar"><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-var">PVar</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier hs-type">Unique</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier hs-type">VarName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- variable bind; treated like wildcard for the decision tree</span><span>
</span><span id="line-85"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PLit"><span class="annot"><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span></span><span> </span><span class="annot"><a href="Elara.Core.html#Literal"><span class="hs-identifier hs-type">Core.Literal</span></a></span><span> </span><span class="hs-comment">-- literal match</span><span>
</span><span id="line-86"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PCon"><span class="annot"><a href="Elara.ToCore.Match.html#PCon"><span class="hs-identifier hs-var">PCon</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#Qualified"><span class="hs-identifier hs-type">Qualified</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- constructor with subpatterns</span><span>
</span><span id="line-87"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680036432"><span id="local-6989586621680036449"><span id="local-6989586621680036453"><span class="annot"><span class="annottext">Int -&gt; NPat -&gt; ShowS
[NPat] -&gt; ShowS
NPat -&gt; String
(Int -&gt; NPat -&gt; ShowS)
-&gt; (NPat -&gt; String) -&gt; ([NPat] -&gt; ShowS) -&gt; Show NPat
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; NPat -&gt; ShowS
showsPrec :: Int -&gt; NPat -&gt; ShowS
$cshow :: NPat -&gt; String
show :: NPat -&gt; String
$cshowList :: [NPat] -&gt; ShowS
showList :: [NPat] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036460"><span id="local-6989586621680036476"><span class="annot"><span class="annottext">NPat -&gt; NPat -&gt; Bool
(NPat -&gt; NPat -&gt; Bool) -&gt; (NPat -&gt; NPat -&gt; Bool) -&gt; Eq NPat
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: NPat -&gt; NPat -&gt; Bool
== :: NPat -&gt; NPat -&gt; Bool
$c/= :: NPat -&gt; NPat -&gt; Bool
/= :: NPat -&gt; NPat -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036483"><span id="local-6989586621680036485"><span class="annot"><span class="annottext">(forall x. NPat -&gt; Rep NPat x)
-&gt; (forall x. Rep NPat x -&gt; NPat) -&gt; Generic NPat
forall x. Rep NPat x -&gt; NPat
forall x. NPat -&gt; Rep NPat x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. NPat -&gt; Rep NPat x
from :: forall x. NPat -&gt; Rep NPat x
$cto :: forall x. Rep NPat x -&gt; NPat
to :: forall x. Rep NPat x -&gt; NPat
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-88"></span><span>
</span><span id="line-89"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621680036491"><span class="annot"><a href="Elara.Data.Pretty.html#Pretty"><span class="hs-identifier hs-type">Pretty</span></a></span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span></span><span>
</span><span id="line-90"></span><span>
</span><span id="line-91"></span><span class="annot"><span class="hs-comment">{- | Pattern matrix backed by 'Data.Matrix'. Invariant:
 nrows pmPats == length pmRhs == length pmBinds
-}</span></span><span>
</span><span id="line-94"></span><span class="hs-keyword">data</span><span> </span><span id="PMatrix"><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-var">PMatrix</span></a></span></span><span> </span><span id="local-6989586621680036277"><span class="annot"><a href="#local-6989586621680036277"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="PMatrix"><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-var">PMatrix</span></a></span></span><span>
</span><span id="line-95"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="pmPats"><span class="annot"><span class="annottext">forall a. PMatrix a -&gt; Matrix NPat
</span><a href="Elara.ToCore.Match.html#pmPats"><span class="hs-identifier hs-var hs-var">pmPats</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Mat.Matrix</span></span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span>
</span><span id="line-96"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="pmRhs"><span class="annot"><span class="annottext">forall a. PMatrix a -&gt; [a]
</span><a href="Elara.ToCore.Match.html#pmRhs"><span class="hs-identifier hs-var hs-var">pmRhs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621680036277"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-97"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="pmBinds"><span class="annot"><span class="annottext">forall a. PMatrix a -&gt; [[(Unique VarName, Var)]]
</span><a href="Elara.ToCore.Match.html#pmBinds"><span class="hs-identifier hs-var hs-var">pmBinds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier hs-type">Unique</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier hs-type">VarName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><span id="line-98"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-99"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680036563"><span id="local-6989586621680036572"><span id="local-6989586621680036576"><span class="annot"><span class="annottext">Int -&gt; PMatrix a -&gt; ShowS
[PMatrix a] -&gt; ShowS
PMatrix a -&gt; String
(Int -&gt; PMatrix a -&gt; ShowS)
-&gt; (PMatrix a -&gt; String)
-&gt; ([PMatrix a] -&gt; ShowS)
-&gt; Show (PMatrix a)
forall a. Show a =&gt; Int -&gt; PMatrix a -&gt; ShowS
forall a. Show a =&gt; [PMatrix a] -&gt; ShowS
forall a. Show a =&gt; PMatrix a -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: forall a. Show a =&gt; Int -&gt; PMatrix a -&gt; ShowS
showsPrec :: Int -&gt; PMatrix a -&gt; ShowS
$cshow :: forall a. Show a =&gt; PMatrix a -&gt; String
show :: PMatrix a -&gt; String
$cshowList :: forall a. Show a =&gt; [PMatrix a] -&gt; ShowS
showList :: [PMatrix a] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036586"><span id="local-6989586621680036594"><span class="annot"><span class="annottext">PMatrix a -&gt; PMatrix a -&gt; Bool
(PMatrix a -&gt; PMatrix a -&gt; Bool)
-&gt; (PMatrix a -&gt; PMatrix a -&gt; Bool) -&gt; Eq (PMatrix a)
forall a. Eq a =&gt; PMatrix a -&gt; PMatrix a -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: forall a. Eq a =&gt; PMatrix a -&gt; PMatrix a -&gt; Bool
== :: PMatrix a -&gt; PMatrix a -&gt; Bool
$c/= :: forall a. Eq a =&gt; PMatrix a -&gt; PMatrix a -&gt; Bool
/= :: PMatrix a -&gt; PMatrix a -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-100"></span><span>
</span><span id="line-101"></span><span class="annot"><span class="hs-comment">{- | Build a single-column pattern matrix from branches (pattern, rhs).
The RHS is left polymorphic so callers can carry either TypedExpr or CoreExpr.
-}</span></span><span>
</span><span id="line-104"></span><span id="local-6989586621680036295"><span class="annot"><a href="Elara.ToCore.Match.html#buildMatrix1"><span class="hs-identifier hs-type">buildMatrix1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Typed.html#TypedPattern"><span class="hs-identifier hs-type">TypedPattern</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621680036295"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036295"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-105"></span><span id="buildMatrix1"><span class="annot"><span class="annottext">buildMatrix1 :: forall a. [(TypedPattern, a)] -&gt; PMatrix a
</span><a href="Elara.ToCore.Match.html#buildMatrix1"><span class="hs-identifier hs-var hs-var">buildMatrix1</span></a></span></span><span> </span><span id="local-6989586621680036607"><span class="annot"><span class="annottext">[(TypedPattern, a)]
</span><a href="#local-6989586621680036607"><span class="hs-identifier hs-var">branches</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-106"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036608"><span class="annot"><span class="annottext">pats :: Matrix NPat
</span><a href="#local-6989586621680036608"><span class="hs-identifier hs-var hs-var">pats</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; [NPat] -&gt; Matrix NPat
forall a. Int -&gt; Int -&gt; [a] -&gt; Matrix a
</span><span class="hs-identifier hs-var">Mat.fromList</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(TypedPattern, a)] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[(TypedPattern, a)]
</span><a href="#local-6989586621680036607"><span class="hs-identifier hs-var">branches</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((TypedPattern, a) -&gt; NPat) -&gt; [(TypedPattern, a)] -&gt; [NPat]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TypedPattern -&gt; NPat
</span><a href="Elara.ToCore.Match.html#toNPat"><span class="hs-identifier hs-var">toNPat</span></a></span><span> </span><span class="annot"><span class="annottext">(TypedPattern -&gt; NPat)
-&gt; ((TypedPattern, a) -&gt; TypedPattern) -&gt; (TypedPattern, a) -&gt; NPat
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(TypedPattern, a) -&gt; TypedPattern
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[(TypedPattern, a)]
</span><a href="#local-6989586621680036607"><span class="hs-identifier hs-var">branches</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-107"></span><span>        </span><span id="local-6989586621680036614"><span class="annot"><span class="annottext">rhs :: [a]
</span><a href="#local-6989586621680036614"><span class="hs-identifier hs-var hs-var">rhs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((TypedPattern, a) -&gt; a) -&gt; [(TypedPattern, a)] -&gt; [a]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(TypedPattern, a) -&gt; a
forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span> </span><span class="annot"><span class="annottext">[(TypedPattern, a)]
</span><a href="#local-6989586621680036607"><span class="hs-identifier hs-var">branches</span></a></span><span>
</span><span id="line-108"></span><span>        </span><span id="local-6989586621680036616"><span class="annot"><span class="annottext">binds :: [[(Unique VarName, Var)]]
</span><a href="#local-6989586621680036616"><span class="hs-identifier hs-var hs-var">binds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [(Unique VarName, Var)] -&gt; [[(Unique VarName, Var)]]
forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">replicate</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(TypedPattern, a)] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[(TypedPattern, a)]
</span><a href="#local-6989586621680036607"><span class="hs-identifier hs-var">branches</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-109"></span><span>     </span><span class="hs-keyword">in</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span class="hs-special">{</span><span class="annot"><span class="annottext">pmPats :: Matrix NPat
</span><a href="Elara.ToCore.Match.html#pmPats"><span class="hs-identifier hs-var">pmPats</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Matrix NPat
</span><a href="#local-6989586621680036608"><span class="hs-identifier hs-var">pats</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmRhs :: [a]
</span><a href="Elara.ToCore.Match.html#pmRhs"><span class="hs-identifier hs-var">pmRhs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621680036614"><span class="hs-identifier hs-var">rhs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmBinds :: [[(Unique VarName, Var)]]
</span><a href="Elara.ToCore.Match.html#pmBinds"><span class="hs-identifier hs-var">pmBinds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[(Unique VarName, Var)]]
</span><a href="#local-6989586621680036616"><span class="hs-identifier hs-var">binds</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-110"></span><span>
</span><span id="line-111"></span><span class="annot"><span class="hs-comment">-- | Convert a TypedPattern into our normalized NPat form.</span></span><span>
</span><span id="line-112"></span><span class="annot"><a href="Elara.ToCore.Match.html#toNPat"><span class="hs-identifier hs-type">toNPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.AST.Typed.html#TypedPattern"><span class="hs-identifier hs-type">TypedPattern</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span>
</span><span id="line-113"></span><span id="toNPat"><span class="annot"><span class="annottext">toNPat :: TypedPattern -&gt; NPat
</span><a href="Elara.ToCore.Match.html#toNPat"><span class="hs-identifier hs-var hs-var">toNPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Generic.Types.html#Pattern"><span class="hs-identifier hs-type">AST.Pattern</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680036620"><span class="annot"><span class="annottext">Pattern' 'Typed
</span><a href="#local-6989586621680036620"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036621"><span class="annot"><span class="annottext">Select &quot;PatternType&quot; 'Typed
</span><a href="#local-6989586621680036621"><span class="hs-identifier hs-var">_t</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pattern' 'Typed -&gt; NPat
</span><a href="#local-6989586621680036622"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pattern' 'Typed
</span><a href="#local-6989586621680036620"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-114"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-115"></span><span>    </span><span id="local-6989586621680036622"><span class="annot"><span class="annottext">go :: Pattern' 'Typed -&gt; NPat
</span><a href="#local-6989586621680036622"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-116"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#IntegerPattern"><span class="hs-identifier hs-type">AST.IntegerPattern</span></a></span><span> </span><span id="local-6989586621680036624"><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621680036624"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Integer -&gt; Literal
</span><a href="Elara.Core.html#Int"><span class="hs-identifier hs-var">Core.Int</span></a></span><span> </span><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621680036624"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-117"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#FloatPattern"><span class="hs-identifier hs-type">AST.FloatPattern</span></a></span><span> </span><span id="local-6989586621680036627"><span class="annot"><span class="annottext">Double
</span><a href="#local-6989586621680036627"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Double -&gt; Literal
</span><a href="Elara.Core.html#Double"><span class="hs-identifier hs-var">Core.Double</span></a></span><span> </span><span class="annot"><span class="annottext">Double
</span><a href="#local-6989586621680036627"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-118"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#StringPattern"><span class="hs-identifier hs-type">AST.StringPattern</span></a></span><span> </span><span id="local-6989586621680036630"><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680036630"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Text -&gt; Literal
</span><a href="Elara.Core.html#String"><span class="hs-identifier hs-var">Core.String</span></a></span><span> </span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680036630"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-119"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#CharPattern"><span class="hs-identifier hs-type">AST.CharPattern</span></a></span><span> </span><span id="local-6989586621680036633"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680036633"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char -&gt; Literal
</span><a href="Elara.Core.html#Char"><span class="hs-identifier hs-var">Core.Char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680036633"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-120"></span><span>        </span><span class="annot"><span class="annottext">Pattern' 'Typed
</span><a href="Elara.AST.Generic.Types.html#UnitPattern"><span class="hs-identifier hs-var">AST.UnitPattern</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span>
</span><span id="line-121"></span><span>        </span><span class="annot"><span class="annottext">Pattern' 'Typed
</span><a href="Elara.AST.Generic.Types.html#WildcardPattern"><span class="hs-identifier hs-var">AST.WildcardPattern</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="Elara.ToCore.Match.html#PWild"><span class="hs-identifier hs-var">PWild</span></a></span><span>
</span><span id="line-122"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#VarPattern"><span class="hs-identifier hs-type">AST.VarPattern</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680036639"><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680036639"><span class="hs-identifier hs-var">uvn</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Unique VarName -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-var">PVar</span></a></span><span> </span><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680036639"><span class="hs-identifier hs-var">uvn</span></a></span><span>
</span><span id="line-123"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#ConstructorPattern"><span class="hs-identifier hs-type">AST.ConstructorPattern</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680036641"><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680036641"><span class="hs-identifier hs-var">qn</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621680036642"><span class="annot"><span class="annottext">[TypedPattern]
</span><a href="#local-6989586621680036642"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-124"></span><span>            </span><span class="annot"><span class="annottext">Qualified TypeName -&gt; [NPat] -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PCon"><span class="hs-identifier hs-var">PCon</span></a></span><span> </span><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680036641"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(TypedPattern -&gt; NPat) -&gt; [TypedPattern] -&gt; [NPat]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TypedPattern -&gt; NPat
</span><a href="Elara.ToCore.Match.html#toNPat"><span class="hs-identifier hs-var">toNPat</span></a></span><span> </span><span class="annot"><span class="annottext">[TypedPattern]
</span><a href="#local-6989586621680036642"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-125"></span><span>
</span><span id="line-126"></span><span class="hs-comment">-- No explicit partition/drop helpers are needed with the matrix-based layout.</span><span>
</span><span id="line-127"></span><span>
</span><span id="line-128"></span><span class="hs-comment">{-
  Minimal compiler from a PMatrix to Core.
  - Single scrutinee to start; after matching a constructor with n fields we
    extend the scrutinee list with the freshly-bound field variables before the
    remaining columns. We always discriminate on column 0.
  - Variable patterns are currently treated as wildcards; binding them to user
    names can be layered in later by threading a bind-env per row and emitting
    Let at leaves.
-}</span><span>
</span><span id="line-137"></span><span>
</span><span id="line-138"></span><span class="hs-keyword">type</span><span> </span><span id="ConResolver"><span class="annot"><a href="Elara.ToCore.Match.html#ConResolver"><span class="hs-identifier hs-var">ConResolver</span></a></span></span><span> </span><span id="local-6989586621680036643"><span class="annot"><a href="#local-6989586621680036643"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Elara.AST.Name.html#Qualified"><span class="hs-identifier hs-type">Qualified</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680036643"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#DataCon"><span class="hs-identifier hs-type">Core.DataCon</span></a></span><span>
</span><span id="line-139"></span><span>
</span><span id="line-140"></span><span class="hs-keyword">type</span><span> </span><span id="FreshLocal"><span class="annot"><a href="Elara.ToCore.Match.html#FreshLocal"><span class="hs-identifier hs-var">FreshLocal</span></a></span></span><span> </span><span id="local-6989586621680036644"><span class="annot"><a href="#local-6989586621680036644"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">T.Text</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Core.html#Type"><span class="hs-identifier hs-type">Core.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680036644"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span>
</span><span id="line-141"></span><span>
</span><span id="line-142"></span><span class="annot"><span class="hs-comment">{- | Compile a pattern matrix to a Core expression. Assumes the first column
corresponds to the head scrutinee in the provided list of variables.
-}</span></span><span>
</span><span id="line-145"></span><span id="local-6989586621680036321"><span class="annot"><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-type">compileMatrix</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier hs-type">StructuredDebug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680036321"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#ConResolver"><span class="hs-identifier hs-type">ConResolver</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680036321"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#FreshLocal"><span class="hs-identifier hs-type">FreshLocal</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680036321"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680036321"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span></span><span>
</span><span id="line-146"></span><span id="compileMatrix"><span class="annot"><span class="annottext">compileMatrix :: forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-var hs-var">compileMatrix</span></a></span></span><span> </span><span id="local-6989586621680036658"><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680036658"><span class="hs-identifier hs-var">resolveCon</span></a></span></span><span> </span><span id="local-6989586621680036659"><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680036659"><span class="hs-identifier hs-var">fresh</span></a></span></span><span> </span><span id="local-6989586621680036660"><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680036660"><span class="hs-identifier hs-var">scruts</span></a></span></span><span> </span><span id="local-6989586621680036661"><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036661"><span class="hs-identifier hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-147"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Matrix NPat -&gt; Int
forall a. Matrix a -&gt; Int
</span><span class="hs-identifier hs-var">Mat.ncols</span></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036661"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmPats</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-148"></span><span>        </span><span class="hs-keyword">then</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036661"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036661"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-149"></span><span>            </span><span class="hs-special">(</span><span id="local-6989586621680036663"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036663"><span class="hs-identifier hs-var">rhs0</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><span class="annottext">[CoreExpr]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036664"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036664"><span class="hs-identifier hs-var">binds0</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><span class="annottext">[[(Unique VarName, Var)]]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(Unique VarName, Var)] -&gt; CoreExpr -&gt; CoreExpr
</span><a href="Elara.ToCore.Match.html#emitBinds"><span class="hs-identifier hs-var">emitBinds</span></a></span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036664"><span class="hs-identifier hs-var">binds0</span></a></span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036663"><span class="hs-identifier hs-var">rhs0</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-150"></span><span>            </span><span class="annot"><span class="annottext">([CoreExpr], [[(Unique VarName, Var)]])
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Literal -&gt; CoreExpr
forall b. Literal -&gt; Expr b
</span><a href="Elara.Core.html#Lit"><span class="hs-identifier hs-var">Core.Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-151"></span><span>        </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#stepOnColumn0"><span class="hs-identifier hs-var">stepOnColumn0</span></a></span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680036658"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680036659"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680036660"><span class="hs-identifier hs-var">scruts</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036661"><span class="hs-identifier hs-var">pm</span></a></span><span>
</span><span id="line-152"></span><span>
</span><span id="line-153"></span><span id="local-6989586621680036668"><span class="annot"><a href="Elara.ToCore.Match.html#stepOnColumn0"><span class="hs-identifier hs-type">stepOnColumn0</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier hs-type">StructuredDebug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680036668"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#ConResolver"><span class="hs-identifier hs-type">ConResolver</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680036668"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#FreshLocal"><span class="hs-identifier hs-type">FreshLocal</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680036668"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680036668"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span></span><span>
</span><span id="line-154"></span><span id="stepOnColumn0"><span class="annot"><span class="annottext">stepOnColumn0 :: forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#stepOnColumn0"><span class="hs-identifier hs-var hs-var">stepOnColumn0</span></a></span></span><span> </span><span id="local-6989586621680036811"><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680036811"><span class="hs-identifier hs-var">resolveCon</span></a></span></span><span> </span><span id="local-6989586621680036812"><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680036812"><span class="hs-identifier hs-var">fresh</span></a></span></span><span> </span><span id="local-6989586621680036813"><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680036813"><span class="hs-identifier hs-var">scruts</span></a></span></span><span> </span><span id="local-6989586621680036814"><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-155"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680036813"><span class="hs-identifier hs-var">scruts</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-156"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-157"></span><span>            </span><span class="hs-comment">-- No scrutinee left. If matrix is solved, emit first row; else Unit.</span><span>
</span><span id="line-158"></span><span>            </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Matrix NPat -&gt; Int
forall a. Matrix a -&gt; Int
</span><span class="hs-identifier hs-var">Mat.ncols</span></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmPats</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-159"></span><span>                </span><span class="hs-keyword">then</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-160"></span><span>                    </span><span class="hs-special">(</span><span id="local-6989586621680036815"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036815"><span class="hs-identifier hs-var">rhs0</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><span class="annottext">[CoreExpr]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036816"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036816"><span class="hs-identifier hs-var">binds0</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><span class="annottext">[[(Unique VarName, Var)]]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(Unique VarName, Var)] -&gt; CoreExpr -&gt; CoreExpr
</span><a href="Elara.ToCore.Match.html#emitBinds"><span class="hs-identifier hs-var">emitBinds</span></a></span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036816"><span class="hs-identifier hs-var">binds0</span></a></span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036815"><span class="hs-identifier hs-var">rhs0</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-161"></span><span>                    </span><span class="annot"><span class="annottext">([CoreExpr], [[(Unique VarName, Var)]])
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Literal -&gt; CoreExpr
forall b. Literal -&gt; Expr b
</span><a href="Elara.Core.html#Lit"><span class="hs-identifier hs-var">Core.Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-162"></span><span>                </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Literal -&gt; CoreExpr
forall b. Literal -&gt; Expr b
</span><a href="Elara.Core.html#Lit"><span class="hs-identifier hs-var">Core.Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-163"></span><span>        </span><span id="local-6989586621680036817"><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680036817"><span class="hs-identifier hs-var">s0</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621680036818"><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680036818"><span class="hs-identifier hs-var">restScruts</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-164"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036819"><span class="annot"><span class="annottext">rows :: Int
</span><a href="#local-6989586621680036819"><span class="hs-identifier hs-var hs-var">rows</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Matrix NPat -&gt; Int
forall a. Matrix a -&gt; Int
</span><span class="hs-identifier hs-var">Mat.nrows</span></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmPats</span><span>
</span><span id="line-165"></span><span>                </span><span id="local-6989586621680036821"><span class="annot"><span class="annottext">cols :: Int
</span><a href="#local-6989586621680036821"><span class="hs-identifier hs-var hs-var">cols</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Matrix NPat -&gt; Int
forall a. Matrix a -&gt; Int
</span><span class="hs-identifier hs-var">Mat.ncols</span></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmPats</span><span>
</span><span id="line-166"></span><span>                </span><span id="local-6989586621680036822"><span class="annot"><span class="annottext">rowInfo :: Int -&gt; Maybe (NPat, [NPat])
</span><a href="#local-6989586621680036822"><span class="hs-identifier hs-var hs-var">rowInfo</span></a></span></span><span> </span><span id="local-6989586621680036823"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036823"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-167"></span><span>                    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036821"><span class="hs-identifier hs-var">cols</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-168"></span><span>                        </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Maybe (NPat, [NPat])
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-169"></span><span>                        </span><span class="hs-keyword">else</span><span>
</span><span id="line-170"></span><span>                            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036824"><span class="annot"><span class="annottext">p0 :: NPat
</span><a href="#local-6989586621680036824"><span class="hs-identifier hs-var hs-var">p0</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Matrix NPat -&gt; NPat
forall a. Int -&gt; Int -&gt; Matrix a -&gt; a
</span><span class="hs-identifier hs-var">Mat.getElem</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036823"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmPats</span><span>
</span><span id="line-171"></span><span>                                </span><span id="local-6989586621680036826"><span class="annot"><span class="annottext">ps :: [NPat]
</span><a href="#local-6989586621680036826"><span class="hs-identifier hs-var hs-var">ps</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Matrix NPat -&gt; NPat
forall a. Int -&gt; Int -&gt; Matrix a -&gt; a
</span><span class="hs-identifier hs-var">Mat.getElem</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036823"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036827"><span class="hs-identifier hs-var">j</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmPats</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621680036827"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036827"><span class="hs-identifier hs-var">j</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="hs-glyph">..</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036821"><span class="hs-identifier hs-var">cols</span></a></span><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><span id="line-172"></span><span>                             </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">(NPat, [NPat]) -&gt; Maybe (NPat, [NPat])
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036824"><span class="hs-identifier hs-var">p0</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036826"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-173"></span><span>                </span><span class="annot"><a href="#local-6989586621680036828"><span class="hs-identifier hs-type">foldPart</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-174"></span><span>                    </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-175"></span><span>                    </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#Qualified"><span class="hs-identifier hs-type">Qualified</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-176"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><a href="Elara.Core.html#Literal"><span class="hs-identifier hs-type">Core.Literal</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-177"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-178"></span><span>                    </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-179"></span><span>                    </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#Qualified"><span class="hs-identifier hs-type">Qualified</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-180"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><a href="Elara.Core.html#Literal"><span class="hs-identifier hs-type">Core.Literal</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-181"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-182"></span><span>                    </span><span class="hs-special">)</span><span>
</span><span id="line-183"></span><span>                </span><span id="local-6989586621680036828"><span class="annot"><span class="annottext">foldPart :: Int
-&gt; (Map (Qualified TypeName) [(Int, [NPat], [NPat])],
    Map Literal [(Int, [NPat])], [(Int, NPat, [NPat])])
-&gt; (Map (Qualified TypeName) [(Int, [NPat], [NPat])],
    Map Literal [(Int, [NPat])], [(Int, NPat, [NPat])])
</span><a href="#local-6989586621680036828"><span class="hs-identifier hs-var hs-var">foldPart</span></a></span></span><span> </span><span id="local-6989586621680036829"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036829"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680036830"><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680036830"><span class="hs-identifier hs-var">consM</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036831"><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680036831"><span class="hs-identifier hs-var">litM</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036832"><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680036832"><span class="hs-identifier hs-var">defs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-184"></span><span>                    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Maybe (NPat, [NPat])
</span><a href="#local-6989586621680036822"><span class="hs-identifier hs-var">rowInfo</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036829"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-185"></span><span>                        </span><span class="annot"><span class="annottext">Maybe (NPat, [NPat])
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680036830"><span class="hs-identifier hs-var">consM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680036831"><span class="hs-identifier hs-var">litM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680036832"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-186"></span><span>                        </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680036833"><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036833"><span class="hs-identifier hs-var">p0</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036834"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036834"><span class="hs-identifier hs-var">ps</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036833"><span class="hs-identifier hs-var">p0</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-187"></span><span>                            </span><span class="annot"><a href="Elara.ToCore.Match.html#PCon"><span class="hs-identifier hs-type">PCon</span></a></span><span> </span><span id="local-6989586621680036835"><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680036835"><span class="hs-identifier hs-var">qn</span></a></span></span><span> </span><span id="local-6989586621680036836"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036836"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-188"></span><span>                                </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036837"><span class="annot"><span class="annottext">entry :: (Int, [NPat], [NPat])
</span><a href="#local-6989586621680036837"><span class="hs-identifier hs-var hs-var">entry</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036829"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036836"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036834"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-189"></span><span>                                 </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">([(Int, [NPat], [NPat])]
 -&gt; [(Int, [NPat], [NPat])] -&gt; [(Int, [NPat], [NPat])])
-&gt; Qualified TypeName
-&gt; [(Int, [NPat], [NPat])]
-&gt; Map (Qualified TypeName) [(Int, [NPat], [NPat])]
-&gt; Map (Qualified TypeName) [(Int, [NPat], [NPat])]
forall k a. Ord k =&gt; (a -&gt; a -&gt; a) -&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">M.insertWith</span></span><span> </span><span class="annot"><span class="annottext">[(Int, [NPat], [NPat])]
-&gt; [(Int, [NPat], [NPat])] -&gt; [(Int, [NPat], [NPat])]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">(++)</span></span><span> </span><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680036835"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">(Int, [NPat], [NPat])
</span><a href="#local-6989586621680036837"><span class="hs-identifier hs-var">entry</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680036830"><span class="hs-identifier hs-var">consM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680036831"><span class="hs-identifier hs-var">litM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680036832"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-190"></span><span>                            </span><span class="annot"><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-type">PLit</span></a></span><span> </span><span id="local-6989586621680036839"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621680036839"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-191"></span><span>                                </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036840"><span class="annot"><span class="annottext">entry :: (Int, [NPat])
</span><a href="#local-6989586621680036840"><span class="hs-identifier hs-var hs-var">entry</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036829"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036834"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-192"></span><span>                                 </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680036830"><span class="hs-identifier hs-var">consM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">([(Int, [NPat])] -&gt; [(Int, [NPat])] -&gt; [(Int, [NPat])])
-&gt; Literal
-&gt; [(Int, [NPat])]
-&gt; Map Literal [(Int, [NPat])]
-&gt; Map Literal [(Int, [NPat])]
forall k a. Ord k =&gt; (a -&gt; a -&gt; a) -&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">M.insertWith</span></span><span> </span><span class="annot"><span class="annottext">[(Int, [NPat])] -&gt; [(Int, [NPat])] -&gt; [(Int, [NPat])]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">(++)</span></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621680036839"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">(Int, [NPat])
</span><a href="#local-6989586621680036840"><span class="hs-identifier hs-var">entry</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680036831"><span class="hs-identifier hs-var">litM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680036832"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-193"></span><span>                            </span><span class="annot"><span class="annottext">NPat
</span><a href="Elara.ToCore.Match.html#PWild"><span class="hs-identifier hs-var">PWild</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680036830"><span class="hs-identifier hs-var">consM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680036831"><span class="hs-identifier hs-var">litM</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036829"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036833"><span class="hs-identifier hs-var">p0</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036834"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Int, NPat, [NPat])
-&gt; [(Int, NPat, [NPat])] -&gt; [(Int, NPat, [NPat])]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680036832"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-194"></span><span>                            </span><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-type">PVar</span></a></span><span> </span><span class="annot"><span class="annottext">Unique VarName
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680036830"><span class="hs-identifier hs-var">consM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680036831"><span class="hs-identifier hs-var">litM</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036829"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036833"><span class="hs-identifier hs-var">p0</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036834"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Int, NPat, [NPat])
-&gt; [(Int, NPat, [NPat])] -&gt; [(Int, NPat, [NPat])]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680036832"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-195"></span><span>                </span><span class="hs-special">(</span><span id="local-6989586621680036841"><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680036841"><span class="hs-identifier hs-var">consM</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036842"><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680036842"><span class="hs-identifier hs-var">litM</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036843"><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680036843"><span class="hs-identifier hs-var">defs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Int
 -&gt; (Map (Qualified TypeName) [(Int, [NPat], [NPat])],
     Map Literal [(Int, [NPat])], [(Int, NPat, [NPat])])
 -&gt; (Map (Qualified TypeName) [(Int, [NPat], [NPat])],
     Map Literal [(Int, [NPat])], [(Int, NPat, [NPat])]))
-&gt; (Map (Qualified TypeName) [(Int, [NPat], [NPat])],
    Map Literal [(Int, [NPat])], [(Int, NPat, [NPat])])
-&gt; [Int]
-&gt; (Map (Qualified TypeName) [(Int, [NPat], [NPat])],
    Map Literal [(Int, [NPat])], [(Int, NPat, [NPat])])
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">Int
-&gt; (Map (Qualified TypeName) [(Int, [NPat], [NPat])],
    Map Literal [(Int, [NPat])], [(Int, NPat, [NPat])])
-&gt; (Map (Qualified TypeName) [(Int, [NPat], [NPat])],
    Map Literal [(Int, [NPat])], [(Int, NPat, [NPat])])
</span><a href="#local-6989586621680036828"><span class="hs-identifier hs-var">foldPart</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
forall k a. Map k a
</span><span class="hs-identifier hs-var">M.empty</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
forall k a. Map k a
</span><span class="hs-identifier hs-var">M.empty</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="hs-glyph">..</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036819"><span class="hs-identifier hs-var">rows</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-196"></span><span>
</span><span id="line-197"></span><span>            </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])] -&gt; Bool
forall k a. Map k a -&gt; Bool
</span><span class="hs-identifier hs-var">M.null</span></span><span> </span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680036841"><span class="hs-identifier hs-var">consM</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-198"></span><span>                </span><span class="hs-keyword">then</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-199"></span><span>                    </span><span id="local-6989586621680036848"><span class="annot"><a href="#local-6989586621680036848"><span class="hs-identifier hs-var">conAlts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Qualified TypeName, [(Int, [NPat], [NPat])])]
-&gt; ((Qualified TypeName, [(Int, [NPat], [NPat])])
    -&gt; Eff r (AltCon, [Var], CoreExpr))
-&gt; Eff r [(AltCon, [Var], CoreExpr)]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m (t b)
</span><span class="hs-identifier hs-var">forM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
-&gt; [(Qualified TypeName, [(Int, [NPat], [NPat])])]
forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">M.toList</span></span><span> </span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680036841"><span class="hs-identifier hs-var">consM</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(((Qualified TypeName, [(Int, [NPat], [NPat])])
  -&gt; Eff r (AltCon, [Var], CoreExpr))
 -&gt; Eff r [(AltCon, [Var], CoreExpr)])
-&gt; ((Qualified TypeName, [(Int, [NPat], [NPat])])
    -&gt; Eff r (AltCon, [Var], CoreExpr))
-&gt; Eff r [(AltCon, [Var], CoreExpr)]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680036851"><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680036851"><span class="hs-identifier hs-var">qn</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036852"><span class="annot"><span class="annottext">[(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680036852"><span class="hs-identifier hs-var">matched</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-200"></span><span>                        </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Eff r ()
forall (r :: [Effect]).
(HasCallStack, StructuredDebug :&gt; r) =&gt;
Doc AnsiStyle -&gt; Eff r ()
</span><a href="Elara.Logging.html#debug"><span class="hs-identifier hs-var">debug</span></a></span><span> </span><span class="annot"><span class="annottext">(Doc AnsiStyle -&gt; Eff r ()) -&gt; Doc AnsiStyle -&gt; Eff r ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;Compiling constructor alt for: &quot;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Qualified TypeName, [(Int, [NPat], [NPat])]) -&gt; Doc AnsiStyle
forall a. Pretty a =&gt; a -&gt; Doc AnsiStyle
</span><a href="Elara.Data.Pretty.html#pretty"><span class="hs-identifier hs-var">pretty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680036851"><span class="hs-identifier hs-var">qn</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680036852"><span class="hs-identifier hs-var">matched</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-201"></span><span>                        </span><span id="local-6989586621680036855"><span class="annot"><a href="#local-6989586621680036855"><span class="hs-identifier hs-var">dc</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680036811"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680036851"><span class="hs-identifier hs-var">qn</span></a></span><span>
</span><span id="line-202"></span><span>                        </span><span class="annot"><a href="Elara.Logging.html#debug"><span class="hs-identifier hs-type">debug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-string">&quot;dc: &quot;</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;&gt;</span></span><span> </span><span class="annot"><a href="Elara.Data.Pretty.html#pretty"><span class="hs-identifier hs-type">pretty</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036855"><span class="hs-identifier hs-type">dc</span></a></span><span>
</span><span id="line-203"></span><span>                        </span><span class="annot"><a href="Elara.Logging.html#debug"><span class="hs-identifier hs-type">debug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-string">&quot;varType: &quot;</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;&gt;</span></span><span> </span><span class="annot"><a href="Elara.Data.Pretty.html#pretty"><span class="hs-identifier hs-type">pretty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.Analysis.html#varType"><span class="hs-identifier hs-type">Core.varType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036817"><span class="hs-identifier hs-type">s0</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-204"></span><span>                        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036858"><span class="annot"><a href="#local-6989586621680036858"><span class="hs-identifier hs-var hs-var">argTys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Type]
</span><a href="Elara.Core.html#conTyArgs"><span class="hs-identifier hs-var">Core.conTyArgs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Var -&gt; Type
</span><a href="Elara.Core.Analysis.html#varType"><span class="hs-identifier hs-var">Core.varType</span></a></span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680036817"><span class="hs-identifier hs-var">s0</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-205"></span><span>                        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036860"><span class="annot"><a href="#local-6989586621680036860"><span class="hs-identifier hs-var hs-var">dcArgTys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Type]
</span><a href="Elara.Core.html#functionTypeArgs"><span class="hs-identifier hs-var">Core.functionTypeArgs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DataCon -&gt; Type
</span><a href="Elara.Core.html#dataConType"><span class="hs-identifier hs-var">Core.dataConType</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621680036855"><span class="hs-identifier hs-var">dc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-206"></span><span>
</span><span id="line-207"></span><span>                        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036863"><span class="annot"><a href="#local-6989586621680036863"><span class="hs-identifier hs-var hs-var">realArgTys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-208"></span><span>                                </span><span class="hs-comment">-- we construct the &quot;real&quot; binders as</span><span>
</span><span id="line-209"></span><span>                                </span><span class="annot"><span class="annottext">Int -&gt; [Type] -&gt; [Type]
forall a. Int -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">take</span></span><span>
</span><span id="line-210"></span><span>                                    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621680036860"><span class="hs-identifier hs-var">dcArgTys</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- no more than the amount the constructor has</span><span>
</span><span id="line-211"></span><span>                                    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621680036858"><span class="hs-identifier hs-var">argTys</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; [Type]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; [Type] -&gt; [Type]
forall a. Int -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">drop</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621680036858"><span class="hs-identifier hs-var">argTys</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621680036860"><span class="hs-identifier hs-var">dcArgTys</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- then the provided ones from the varType, plus any extras from the constructor to make up the exact length of the constructor</span><span>
</span><span id="line-212"></span><span>                        </span><span class="annot"><a href="Elara.Logging.html#debug"><span class="hs-identifier hs-type">debug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-string">&quot;argTys: &quot;</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;&gt;</span></span><span> </span><span class="annot"><a href="Elara.Data.Pretty.html#pretty"><span class="hs-identifier hs-type">pretty</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036858"><span class="hs-identifier hs-type">argTys</span></a></span><span>
</span><span id="line-213"></span><span>                        </span><span class="annot"><a href="Elara.Logging.html#debug"><span class="hs-identifier hs-type">debug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-string">&quot;realArgTys: &quot;</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;&gt;</span></span><span> </span><span class="annot"><a href="Elara.Data.Pretty.html#pretty"><span class="hs-identifier hs-type">pretty</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036863"><span class="hs-identifier hs-type">realArgTys</span></a></span><span>
</span><span id="line-214"></span><span>                        </span><span id="local-6989586621680036866"><span class="annot"><a href="#local-6989586621680036866"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">forM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">zip</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">..</span><span class="hs-special">]</span><span> </span><span class="annot"><a href="#local-6989586621680036863"><span class="hs-identifier hs-type">realArgTys</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680036867"><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621680036867"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036868"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621680036868"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680036812"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;p&quot;</span></span><span> </span><span class="annot"><span class="annottext">Text -&gt; Text -&gt; Text
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Integer -&gt; Text
forall b a. (Show a, IsString b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621680036867"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621680036868"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-215"></span><span>                        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036869"><span class="annot"><a href="#local-6989586621680036869"><span class="hs-identifier hs-var hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Var] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680036866"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-216"></span><span>                            </span><span id="local-6989586621680036870"><span class="annot"><a href="#local-6989586621680036870"><span class="hs-identifier hs-var hs-var">transformMatched</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680036871"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036871"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036872"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036872"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036873"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036873"><span class="hs-identifier hs-var">tailPs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-217"></span><span>                                </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680036874"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036874"><span class="hs-identifier hs-var">args'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036875"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036875"><span class="hs-identifier hs-var">addBinds</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Var] -&gt; [NPat] -&gt; ([NPat], [(Unique VarName, Var)])
</span><a href="#local-6989586621680036876"><span class="hs-identifier hs-var">bindImmediate</span></a></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680036866"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036872"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-218"></span><span>                                    </span><span id="local-6989586621680036877"><span class="annot"><span class="annottext">newRow :: [NPat]
</span><a href="#local-6989586621680036877"><span class="hs-identifier hs-var hs-var">newRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036874"><span class="hs-identifier hs-var">args'</span></a></span><span> </span><span class="annot"><span class="annottext">[NPat] -&gt; [NPat] -&gt; [NPat]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036873"><span class="hs-identifier hs-var">tailPs</span></a></span><span>
</span><span id="line-219"></span><span>                                    </span><span id="local-6989586621680036878"><span class="annot"><span class="annottext">rhsRow :: CoreExpr
</span><a href="#local-6989586621680036878"><span class="hs-identifier hs-var hs-var">rhsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [CoreExpr] -&gt; CoreExpr
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036871"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span>
</span><span id="line-220"></span><span>                                    </span><span id="local-6989586621680036880"><span class="annot"><span class="annottext">bindsRow :: [(Unique VarName, Var)]
</span><a href="#local-6989586621680036880"><span class="hs-identifier hs-var hs-var">bindsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036875"><span class="hs-identifier hs-var">addBinds</span></a></span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
-&gt; [(Unique VarName, Var)] -&gt; [(Unique VarName, Var)]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036871"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-221"></span><span>                                 </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036877"><span class="hs-identifier hs-var">newRow</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036878"><span class="hs-identifier hs-var">rhsRow</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036880"><span class="hs-identifier hs-var">bindsRow</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-222"></span><span>                            </span><span id="local-6989586621680036881"><span class="annot"><a href="#local-6989586621680036881"><span class="hs-identifier hs-var hs-var">transformDefault</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680036882"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036882"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036883"><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036883"><span class="hs-identifier hs-var">headPat</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036884"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036884"><span class="hs-identifier hs-var">tailPs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-223"></span><span>                                </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036885"><span class="annot"><span class="annottext">pad :: [NPat]
</span><a href="#local-6989586621680036885"><span class="hs-identifier hs-var hs-var">pad</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; NPat -&gt; [NPat]
forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">replicate</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036869"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="Elara.ToCore.Match.html#PWild"><span class="hs-identifier hs-var">PWild</span></a></span><span>
</span><span id="line-224"></span><span>                                    </span><span id="local-6989586621680036886"><span class="annot"><span class="annottext">newRow :: [NPat]
</span><a href="#local-6989586621680036886"><span class="hs-identifier hs-var hs-var">newRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036885"><span class="hs-identifier hs-var">pad</span></a></span><span> </span><span class="annot"><span class="annottext">[NPat] -&gt; [NPat] -&gt; [NPat]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036884"><span class="hs-identifier hs-var">tailPs</span></a></span><span>
</span><span id="line-225"></span><span>                                    </span><span id="local-6989586621680036887"><span class="annot"><span class="annottext">rhsRow :: CoreExpr
</span><a href="#local-6989586621680036887"><span class="hs-identifier hs-var hs-var">rhsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [CoreExpr] -&gt; CoreExpr
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036882"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span>
</span><span id="line-226"></span><span>                                    </span><span id="local-6989586621680036888"><span class="annot"><span class="annottext">bindsRow :: [(Unique VarName, Var)]
</span><a href="#local-6989586621680036888"><span class="hs-identifier hs-var hs-var">bindsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036883"><span class="hs-identifier hs-var">headPat</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-227"></span><span>                                        </span><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-type">PVar</span></a></span><span> </span><span id="local-6989586621680036889"><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680036889"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680036889"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680036817"><span class="hs-identifier hs-var">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Unique VarName, Var)
-&gt; [(Unique VarName, Var)] -&gt; [(Unique VarName, Var)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036882"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-228"></span><span>                                        </span><span class="annot"><span class="annottext">NPat
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036882"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-229"></span><span>                                 </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036886"><span class="hs-identifier hs-var">newRow</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036887"><span class="hs-identifier hs-var">rhsRow</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036888"><span class="hs-identifier hs-var">bindsRow</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-230"></span><span>                            </span><span id="local-6989586621680036890"><span class="annot"><a href="#local-6989586621680036890"><span class="hs-identifier hs-var hs-var">rowsForAlt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((Int, [NPat], [NPat])
 -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)]))
-&gt; [(Int, [NPat], [NPat])]
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(Int, [NPat], [NPat])
-&gt; ([NPat], CoreExpr, [(Unique VarName, Var)])
</span><a href="#local-6989586621680036870"><span class="hs-identifier hs-var">transformMatched</span></a></span><span> </span><span class="annot"><span class="annottext">[(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680036852"><span class="hs-identifier hs-var">matched</span></a></span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">((Int, NPat, [NPat])
 -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)]))
-&gt; [(Int, NPat, [NPat])]
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(Int, NPat, [NPat]) -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)])
</span><a href="#local-6989586621680036881"><span class="hs-identifier hs-var">transformDefault</span></a></span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680036843"><span class="hs-identifier hs-var">defs</span></a></span><span>
</span><span id="line-231"></span><span>                        </span><span id="local-6989586621680036891"><span class="annot"><a href="#local-6989586621680036891"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-232"></span><span>                            </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="hs-identifier hs-type">null</span></span><span> </span><span class="annot"><a href="#local-6989586621680036890"><span class="hs-identifier hs-type">rowsForAlt</span></a></span><span>
</span><span id="line-233"></span><span>                                </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#Lit"><span class="hs-identifier hs-type">Core.Lit</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-type">Core.Unit</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-234"></span><span>                                </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-235"></span><span>                                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036893"><span class="annot"><a href="#local-6989586621680036893"><span class="hs-identifier hs-var hs-var">newPats</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[NPat]] -&gt; Matrix NPat
forall a. [[a]] -&gt; Matrix a
</span><span class="hs-identifier hs-var">Mat.fromLists</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)]) -&gt; [NPat])
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; [[NPat]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680036895"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036895"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036895"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036890"><span class="hs-identifier hs-var">rowsForAlt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-236"></span><span>                                        </span><span id="local-6989586621680036896"><span class="annot"><a href="#local-6989586621680036896"><span class="hs-identifier hs-var hs-var">newRhs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)]) -&gt; CoreExpr)
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; [CoreExpr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036897"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036897"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036897"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036890"><span class="hs-identifier hs-var">rowsForAlt</span></a></span><span>
</span><span id="line-237"></span><span>                                        </span><span id="local-6989586621680036898"><span class="annot"><a href="#local-6989586621680036898"><span class="hs-identifier hs-var hs-var">newBs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)])
 -&gt; [(Unique VarName, Var)])
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
-&gt; [[(Unique VarName, Var)]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036899"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036899"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036899"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036890"><span class="hs-identifier hs-var">rowsForAlt</span></a></span><span>
</span><span id="line-238"></span><span>                                    </span><span class="annot"><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-type">compileMatrix</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036811"><span class="hs-identifier hs-type">resolveCon</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036812"><span class="hs-identifier hs-type">fresh</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680036866"><span class="hs-identifier hs-type">xs</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">++</span></span><span> </span><span class="annot"><a href="#local-6989586621680036818"><span class="hs-identifier hs-type">restScruts</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.ToCore.Match.html#pmPats"><span class="hs-identifier hs-var">pmPats</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680036893"><span class="hs-identifier hs-type">newPats</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#pmRhs"><span class="hs-identifier hs-var">pmRhs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680036896"><span class="hs-identifier hs-type">newRhs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#pmBinds"><span class="hs-identifier hs-var">pmBinds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680036898"><span class="hs-identifier hs-type">newBs</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-239"></span><span>                        </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#DataAlt"><span class="hs-identifier hs-type">Core.DataAlt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036855"><span class="hs-identifier hs-type">dc</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621680036866"><span class="hs-identifier hs-type">xs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621680036891"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-240"></span><span>                    </span><span id="local-6989586621680036901"><span class="annot"><a href="#local-6989586621680036901"><span class="hs-identifier hs-var">defAlt</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#compileDefault"><span class="hs-identifier hs-type">compileDefault</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036811"><span class="hs-identifier hs-type">resolveCon</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036812"><span class="hs-identifier hs-type">fresh</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036817"><span class="hs-identifier hs-type">s0</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036818"><span class="hs-identifier hs-type">restScruts</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036814"><span class="hs-identifier hs-type">pm</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036843"><span class="hs-identifier hs-type">defs</span></a></span><span>
</span><span id="line-241"></span><span>                    </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="Elara.Core.html#Match"><span class="hs-identifier hs-type">Core.Match</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036817"><span class="hs-identifier hs-type">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><a href="#local-6989586621680036817"><span class="hs-identifier hs-type">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680036848"><span class="hs-identifier hs-type">conAlts</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">++</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">maybeToList</span></span><span> </span><span class="annot"><a href="#local-6989586621680036901"><span class="hs-identifier hs-type">defAlt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-242"></span><span>                </span><span class="hs-keyword">else</span><span>
</span><span id="line-243"></span><span>                    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])] -&gt; Bool
forall k a. Map k a -&gt; Bool
</span><span class="hs-identifier hs-var">M.null</span></span><span> </span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680036842"><span class="hs-identifier hs-var">litM</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-244"></span><span>                        </span><span class="hs-keyword">then</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-245"></span><span>                            </span><span id="local-6989586621680036906"><span class="annot"><a href="#local-6989586621680036906"><span class="hs-identifier hs-var">litAlts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Literal, [(Int, [NPat])])]
-&gt; ((Literal, [(Int, [NPat])]) -&gt; Eff r (AltCon, [Var], CoreExpr))
-&gt; Eff r [(AltCon, [Var], CoreExpr)]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m (t b)
</span><span class="hs-identifier hs-var">forM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])] -&gt; [(Literal, [(Int, [NPat])])]
forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">M.toList</span></span><span> </span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680036842"><span class="hs-identifier hs-var">litM</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(((Literal, [(Int, [NPat])]) -&gt; Eff r (AltCon, [Var], CoreExpr))
 -&gt; Eff r [(AltCon, [Var], CoreExpr)])
-&gt; ((Literal, [(Int, [NPat])]) -&gt; Eff r (AltCon, [Var], CoreExpr))
-&gt; Eff r [(AltCon, [Var], CoreExpr)]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680036907"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621680036907"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036908"><span class="annot"><span class="annottext">[(Int, [NPat])]
</span><a href="#local-6989586621680036908"><span class="hs-identifier hs-var">matched</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-246"></span><span>                                </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036909"><span class="annot"><span class="annottext">transformMatched :: (Int, [NPat]) -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)])
</span><a href="#local-6989586621680036909"><span class="hs-identifier hs-var hs-var hs-var">transformMatched</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680036910"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036910"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036911"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036911"><span class="hs-identifier hs-var">tailPs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-247"></span><span>                                        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036912"><span class="annot"><span class="annottext">rhsRow :: CoreExpr
</span><a href="#local-6989586621680036912"><span class="hs-identifier hs-var hs-var">rhsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [CoreExpr] -&gt; CoreExpr
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036910"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span>
</span><span id="line-248"></span><span>                                            </span><span id="local-6989586621680036913"><span class="annot"><span class="annottext">bindsRow :: [(Unique VarName, Var)]
</span><a href="#local-6989586621680036913"><span class="hs-identifier hs-var hs-var">bindsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036910"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-249"></span><span>                                         </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036911"><span class="hs-identifier hs-var">tailPs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036912"><span class="hs-identifier hs-var">rhsRow</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036913"><span class="hs-identifier hs-var">bindsRow</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-250"></span><span>                                    </span><span id="local-6989586621680036914"><span class="annot"><span class="annottext">transformDefault :: (Int, NPat, [NPat]) -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)])
</span><a href="#local-6989586621680036914"><span class="hs-identifier hs-var hs-var hs-var">transformDefault</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680036915"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036915"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036916"><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036916"><span class="hs-identifier hs-var">headPat</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036917"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036917"><span class="hs-identifier hs-var">tailPs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-251"></span><span>                                        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036918"><span class="annot"><span class="annottext">rhsRow :: CoreExpr
</span><a href="#local-6989586621680036918"><span class="hs-identifier hs-var hs-var">rhsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [CoreExpr] -&gt; CoreExpr
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036915"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span>
</span><span id="line-252"></span><span>                                            </span><span id="local-6989586621680036919"><span class="annot"><span class="annottext">bindsRow :: [(Unique VarName, Var)]
</span><a href="#local-6989586621680036919"><span class="hs-identifier hs-var hs-var">bindsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036916"><span class="hs-identifier hs-var">headPat</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-253"></span><span>                                                </span><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-type">PVar</span></a></span><span> </span><span id="local-6989586621680036920"><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680036920"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680036920"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680036817"><span class="hs-identifier hs-var">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Unique VarName, Var)
-&gt; [(Unique VarName, Var)] -&gt; [(Unique VarName, Var)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036915"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-254"></span><span>                                                </span><span class="annot"><span class="annottext">NPat
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036915"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-255"></span><span>                                         </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036917"><span class="hs-identifier hs-var">tailPs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036918"><span class="hs-identifier hs-var">rhsRow</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036919"><span class="hs-identifier hs-var">bindsRow</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-256"></span><span>                                    </span><span id="local-6989586621680036921"><span class="annot"><span class="annottext">rowsForAlt :: [([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036921"><span class="hs-identifier hs-var hs-var hs-var">rowsForAlt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((Int, [NPat]) -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)]))
-&gt; [(Int, [NPat])] -&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(Int, [NPat]) -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)])
</span><a href="#local-6989586621680036909"><span class="hs-identifier hs-var">transformMatched</span></a></span><span> </span><span class="annot"><span class="annottext">[(Int, [NPat])]
</span><a href="#local-6989586621680036908"><span class="hs-identifier hs-var">matched</span></a></span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">((Int, NPat, [NPat])
 -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)]))
-&gt; [(Int, NPat, [NPat])]
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(Int, NPat, [NPat]) -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)])
</span><a href="#local-6989586621680036914"><span class="hs-identifier hs-var">transformDefault</span></a></span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680036843"><span class="hs-identifier hs-var">defs</span></a></span><span>
</span><span id="line-257"></span><span>                                </span><span id="local-6989586621680036922"><span class="annot"><a href="#local-6989586621680036922"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-258"></span><span>                                    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036921"><span class="hs-identifier hs-var">rowsForAlt</span></a></span><span>
</span><span id="line-259"></span><span>                                        </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Literal -&gt; CoreExpr
forall b. Literal -&gt; Expr b
</span><a href="Elara.Core.html#Lit"><span class="hs-identifier hs-var">Core.Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-260"></span><span>                                        </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-261"></span><span>                                            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036923"><span class="annot"><span class="annottext">newPats :: Matrix NPat
</span><a href="#local-6989586621680036923"><span class="hs-identifier hs-var hs-var">newPats</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[NPat]] -&gt; Matrix NPat
forall a. [[a]] -&gt; Matrix a
</span><span class="hs-identifier hs-var">Mat.fromLists</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)]) -&gt; [NPat])
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; [[NPat]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680036924"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036924"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036924"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036921"><span class="hs-identifier hs-var">rowsForAlt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-262"></span><span>                                                </span><span id="local-6989586621680036925"><span class="annot"><span class="annottext">newRhs :: [CoreExpr]
</span><a href="#local-6989586621680036925"><span class="hs-identifier hs-var hs-var">newRhs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)]) -&gt; CoreExpr)
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; [CoreExpr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036926"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036926"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036926"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036921"><span class="hs-identifier hs-var">rowsForAlt</span></a></span><span>
</span><span id="line-263"></span><span>                                                </span><span id="local-6989586621680036927"><span class="annot"><span class="annottext">newBs :: [[(Unique VarName, Var)]]
</span><a href="#local-6989586621680036927"><span class="hs-identifier hs-var hs-var">newBs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)])
 -&gt; [(Unique VarName, Var)])
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
-&gt; [[(Unique VarName, Var)]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036928"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036928"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036928"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036921"><span class="hs-identifier hs-var">rowsForAlt</span></a></span><span>
</span><span id="line-264"></span><span>                                            </span><span class="annot"><span class="annottext">ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-var">compileMatrix</span></a></span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680036811"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680036812"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680036818"><span class="hs-identifier hs-var">restScruts</span></a></span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span class="hs-special">{</span><span class="annot"><span class="annottext">pmPats :: Matrix NPat
</span><a href="Elara.ToCore.Match.html#pmPats"><span class="hs-identifier hs-var">pmPats</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Matrix NPat
</span><a href="#local-6989586621680036923"><span class="hs-identifier hs-var">newPats</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmRhs :: [CoreExpr]
</span><a href="Elara.ToCore.Match.html#pmRhs"><span class="hs-identifier hs-var">pmRhs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[CoreExpr]
</span><a href="#local-6989586621680036925"><span class="hs-identifier hs-var">newRhs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmBinds :: [[(Unique VarName, Var)]]
</span><a href="Elara.ToCore.Match.html#pmBinds"><span class="hs-identifier hs-var">pmBinds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[(Unique VarName, Var)]]
</span><a href="#local-6989586621680036927"><span class="hs-identifier hs-var">newBs</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-265"></span><span>                                </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#LitAlt"><span class="hs-identifier hs-type">Core.LitAlt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036907"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621680036922"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-266"></span><span>                            </span><span id="local-6989586621680036930"><span class="annot"><a href="#local-6989586621680036930"><span class="hs-identifier hs-var">defAlt</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#compileDefault"><span class="hs-identifier hs-type">compileDefault</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036811"><span class="hs-identifier hs-type">resolveCon</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036812"><span class="hs-identifier hs-type">fresh</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036817"><span class="hs-identifier hs-type">s0</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036818"><span class="hs-identifier hs-type">restScruts</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036814"><span class="hs-identifier hs-type">pm</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036843"><span class="hs-identifier hs-type">defs</span></a></span><span>
</span><span id="line-267"></span><span>                            </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="Elara.Core.html#Match"><span class="hs-identifier hs-type">Core.Match</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680036817"><span class="hs-identifier hs-type">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><a href="#local-6989586621680036817"><span class="hs-identifier hs-type">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680036906"><span class="hs-identifier hs-type">litAlts</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">++</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">maybeToList</span></span><span> </span><span class="annot"><a href="#local-6989586621680036930"><span class="hs-identifier hs-type">defAlt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-268"></span><span>                        </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-269"></span><span>                            </span><span class="hs-comment">-- Only defaults (wild/var). Drop head and continue.</span><span>
</span><span id="line-270"></span><span>                            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036931"><span class="annot"><span class="annottext">transformDefault :: (Int, NPat, [NPat]) -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)])
</span><a href="#local-6989586621680036931"><span class="hs-identifier hs-var hs-var">transformDefault</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680036932"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036932"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036933"><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036933"><span class="hs-identifier hs-var">headPat</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036934"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036934"><span class="hs-identifier hs-var">tailPs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-271"></span><span>                                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036935"><span class="annot"><span class="annottext">rhsRow :: CoreExpr
</span><a href="#local-6989586621680036935"><span class="hs-identifier hs-var hs-var">rhsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [CoreExpr] -&gt; CoreExpr
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036932"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span>
</span><span id="line-272"></span><span>                                        </span><span id="local-6989586621680036936"><span class="annot"><span class="annottext">bindsRow :: [(Unique VarName, Var)]
</span><a href="#local-6989586621680036936"><span class="hs-identifier hs-var hs-var">bindsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036933"><span class="hs-identifier hs-var">headPat</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-273"></span><span>                                            </span><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-type">PVar</span></a></span><span> </span><span id="local-6989586621680036937"><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680036937"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680036937"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680036817"><span class="hs-identifier hs-var">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Unique VarName, Var)
-&gt; [(Unique VarName, Var)] -&gt; [(Unique VarName, Var)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036932"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-274"></span><span>                                            </span><span class="annot"><span class="annottext">NPat
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036932"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036814"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-275"></span><span>                                     </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036934"><span class="hs-identifier hs-var">tailPs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036935"><span class="hs-identifier hs-var">rhsRow</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036936"><span class="hs-identifier hs-var">bindsRow</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-276"></span><span>                                </span><span id="local-6989586621680036938"><span class="annot"><span class="annottext">rowsOnlyDef :: [([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036938"><span class="hs-identifier hs-var hs-var">rowsOnlyDef</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((Int, NPat, [NPat])
 -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)]))
-&gt; [(Int, NPat, [NPat])]
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(Int, NPat, [NPat]) -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)])
</span><a href="#local-6989586621680036931"><span class="hs-identifier hs-var">transformDefault</span></a></span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680036843"><span class="hs-identifier hs-var">defs</span></a></span><span>
</span><span id="line-277"></span><span>                            </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036938"><span class="hs-identifier hs-var">rowsOnlyDef</span></a></span><span>
</span><span id="line-278"></span><span>                                </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Literal -&gt; CoreExpr
forall b. Literal -&gt; Expr b
</span><a href="Elara.Core.html#Lit"><span class="hs-identifier hs-var">Core.Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-279"></span><span>                                </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-280"></span><span>                                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036939"><span class="annot"><span class="annottext">newPats :: Matrix NPat
</span><a href="#local-6989586621680036939"><span class="hs-identifier hs-var hs-var">newPats</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[NPat]] -&gt; Matrix NPat
forall a. [[a]] -&gt; Matrix a
</span><span class="hs-identifier hs-var">Mat.fromLists</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)]) -&gt; [NPat])
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; [[NPat]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680036940"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036940"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036940"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036938"><span class="hs-identifier hs-var">rowsOnlyDef</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-281"></span><span>                                        </span><span id="local-6989586621680036941"><span class="annot"><span class="annottext">newRhs :: [CoreExpr]
</span><a href="#local-6989586621680036941"><span class="hs-identifier hs-var hs-var">newRhs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)]) -&gt; CoreExpr)
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; [CoreExpr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036942"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036942"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036942"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036938"><span class="hs-identifier hs-var">rowsOnlyDef</span></a></span><span>
</span><span id="line-282"></span><span>                                        </span><span id="local-6989586621680036943"><span class="annot"><span class="annottext">newBs :: [[(Unique VarName, Var)]]
</span><a href="#local-6989586621680036943"><span class="hs-identifier hs-var hs-var">newBs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)])
 -&gt; [(Unique VarName, Var)])
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
-&gt; [[(Unique VarName, Var)]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036944"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036944"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036944"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036938"><span class="hs-identifier hs-var">rowsOnlyDef</span></a></span><span>
</span><span id="line-283"></span><span>                                    </span><span class="annot"><span class="annottext">ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-var">compileMatrix</span></a></span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680036811"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680036812"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680036818"><span class="hs-identifier hs-var">restScruts</span></a></span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span class="hs-special">{</span><span class="annot"><span class="annottext">pmPats :: Matrix NPat
</span><a href="Elara.ToCore.Match.html#pmPats"><span class="hs-identifier hs-var">pmPats</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Matrix NPat
</span><a href="#local-6989586621680036939"><span class="hs-identifier hs-var">newPats</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmRhs :: [CoreExpr]
</span><a href="Elara.ToCore.Match.html#pmRhs"><span class="hs-identifier hs-var">pmRhs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[CoreExpr]
</span><a href="#local-6989586621680036941"><span class="hs-identifier hs-var">newRhs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmBinds :: [[(Unique VarName, Var)]]
</span><a href="Elara.ToCore.Match.html#pmBinds"><span class="hs-identifier hs-var">pmBinds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[(Unique VarName, Var)]]
</span><a href="#local-6989586621680036943"><span class="hs-identifier hs-var">newBs</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-284"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-285"></span><span>    </span><span class="hs-comment">-- Bind immediate constructor-argument PVars to the provided xs.</span><span>
</span><span id="line-286"></span><span>    </span><span class="annot"><a href="#local-6989586621680036876"><span class="hs-identifier hs-type">bindImmediate</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier hs-type">Unique</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier hs-type">VarName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-287"></span><span>    </span><span id="local-6989586621680036876"><span class="annot"><span class="annottext">bindImmediate :: [Var] -&gt; [NPat] -&gt; ([NPat], [(Unique VarName, Var)])
</span><a href="#local-6989586621680036876"><span class="hs-identifier hs-var hs-var">bindImmediate</span></a></span></span><span> </span><span id="local-6989586621680036945"><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680036945"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621680036946"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036946"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-288"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036947"><span class="annot"><span class="annottext">step :: (b, NPat) -&gt; (NPat, Maybe (Unique VarName, b))
</span><a href="#local-6989586621680036947"><span class="hs-identifier hs-var hs-var">step</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680036948"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621680036948"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036949"><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036949"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036949"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-289"></span><span>                </span><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-type">PVar</span></a></span><span> </span><span id="local-6989586621680036950"><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680036950"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NPat
</span><a href="Elara.ToCore.Match.html#PWild"><span class="hs-identifier hs-var">PWild</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(Unique VarName, b) -&gt; Maybe (Unique VarName, b)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680036950"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621680036948"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-290"></span><span>                </span><span id="local-6989586621680036951"><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036951"><span class="hs-identifier hs-var">other</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036951"><span class="hs-identifier hs-var">other</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Maybe (Unique VarName, b)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-291"></span><span>            </span><span class="hs-special">(</span><span id="local-6989586621680036952"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036952"><span class="hs-identifier hs-var">args'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036953"><span class="annot"><span class="annottext">[Maybe (Unique VarName, Var)]
</span><a href="#local-6989586621680036953"><span class="hs-identifier hs-var">newBinds</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(NPat, Maybe (Unique VarName, Var))]
-&gt; ([NPat], [Maybe (Unique VarName, Var)])
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Var -&gt; NPat -&gt; (NPat, Maybe (Unique VarName, Var)))
-&gt; [Var] -&gt; [NPat] -&gt; [(NPat, Maybe (Unique VarName, Var))]
forall a b c. (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
</span><span class="hs-identifier hs-var">zipWith</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((Var, NPat) -&gt; (NPat, Maybe (Unique VarName, Var)))
-&gt; Var -&gt; NPat -&gt; (NPat, Maybe (Unique VarName, Var))
forall a b c. ((a, b) -&gt; c) -&gt; a -&gt; b -&gt; c
</span><span class="hs-identifier hs-var">curry</span></span><span> </span><span class="annot"><span class="annottext">(Var, NPat) -&gt; (NPat, Maybe (Unique VarName, Var))
forall {b}. (b, NPat) -&gt; (NPat, Maybe (Unique VarName, b))
</span><a href="#local-6989586621680036947"><span class="hs-identifier hs-var">step</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680036945"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036946"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-292"></span><span>         </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036952"><span class="hs-identifier hs-var">args'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Maybe (Unique VarName, Var)] -&gt; [(Unique VarName, Var)]
forall a. [Maybe a] -&gt; [a]
</span><span class="hs-identifier hs-var">catMaybes</span></span><span> </span><span class="annot"><span class="annottext">[Maybe (Unique VarName, Var)]
</span><a href="#local-6989586621680036953"><span class="hs-identifier hs-var">newBinds</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-293"></span><span>
</span><span id="line-294"></span><span class="annot"><span class="hs-comment">{- | Build a DEFAULT alternative when default rows exist.
 'defs' contains triples of (rowIndex, headPat, tailPatterns)
-}</span></span><span>
</span><span id="line-297"></span><span id="local-6989586621680036385"><span class="annot"><a href="Elara.ToCore.Match.html#compileDefault"><span class="hs-identifier hs-type">compileDefault</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-298"></span><span>    </span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier hs-type">StructuredDebug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680036385"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-299"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#ConResolver"><span class="hs-identifier hs-type">ConResolver</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680036385"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-300"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#FreshLocal"><span class="hs-identifier hs-type">FreshLocal</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680036385"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-301"></span><span>    </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-302"></span><span>    </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-303"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-304"></span><span>    </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-305"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680036385"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreAlt"><span class="hs-identifier hs-type">Core.CoreAlt</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-306"></span><span id="compileDefault"><span class="annot"><span class="annottext">compileDefault :: forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; Var
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; [(Int, NPat, [NPat])]
-&gt; Eff r (Maybe (AltCon, [Var], CoreExpr))
</span><a href="Elara.ToCore.Match.html#compileDefault"><span class="hs-identifier hs-var hs-var">compileDefault</span></a></span></span><span> </span><span id="local-6989586621680036970"><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680036970"><span class="hs-identifier hs-var">resolveCon</span></a></span></span><span> </span><span id="local-6989586621680036971"><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680036971"><span class="hs-identifier hs-var">fresh</span></a></span></span><span> </span><span id="local-6989586621680036972"><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680036972"><span class="hs-identifier hs-var">s0</span></a></span></span><span> </span><span id="local-6989586621680036973"><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680036973"><span class="hs-identifier hs-var">restScruts</span></a></span></span><span> </span><span id="local-6989586621680036974"><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036974"><span class="hs-identifier hs-var">pm</span></a></span></span><span> </span><span id="local-6989586621680036975"><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680036975"><span class="hs-identifier hs-var">defs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-307"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680036975"><span class="hs-identifier hs-var">defs</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-308"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (AltCon, [Var], CoreExpr)
-&gt; Eff r (Maybe (AltCon, [Var], CoreExpr))
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe (AltCon, [Var], CoreExpr)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-309"></span><span>        </span><span id="local-6989586621680036976"><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680036976"><span class="hs-identifier hs-var">ds</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-310"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680036977"><span class="annot"><span class="annottext">rows' :: [([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036977"><span class="hs-identifier hs-var hs-var hs-var">rows'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-311"></span><span>                    </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036978"><span class="hs-identifier hs-var">tailPs</span></a></span><span>
</span><span id="line-312"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [CoreExpr] -&gt; CoreExpr
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036979"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036974"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span>
</span><span id="line-313"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036980"><span class="hs-identifier hs-var">headPat</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-314"></span><span>                            </span><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-type">PVar</span></a></span><span> </span><span id="local-6989586621680036981"><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680036981"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680036981"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680036972"><span class="hs-identifier hs-var">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Unique VarName, Var)
-&gt; [(Unique VarName, Var)] -&gt; [(Unique VarName, Var)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036979"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036974"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-315"></span><span>                            </span><span class="annot"><span class="annottext">NPat
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036979"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680036974"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-316"></span><span>                      </span><span class="hs-special">)</span><span>
</span><span id="line-317"></span><span>                    </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680036979"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680036979"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036980"><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680036980"><span class="hs-identifier hs-var">headPat</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036978"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036978"><span class="hs-identifier hs-var">tailPs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680036976"><span class="hs-identifier hs-var">ds</span></a></span><span>
</span><span id="line-318"></span><span>                    </span><span class="hs-special">]</span><span>
</span><span id="line-319"></span><span>                </span><span id="local-6989586621680036982"><span class="annot"><span class="annottext">newPats :: Matrix NPat
</span><a href="#local-6989586621680036982"><span class="hs-identifier hs-var hs-var hs-var">newPats</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[NPat]] -&gt; Matrix NPat
forall a. [[a]] -&gt; Matrix a
</span><span class="hs-identifier hs-var">Mat.fromLists</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)]) -&gt; [NPat])
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; [[NPat]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680036983"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036983"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680036983"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036977"><span class="hs-identifier hs-var">rows'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-320"></span><span>                </span><span id="local-6989586621680036984"><span class="annot"><span class="annottext">newRhs :: [CoreExpr]
</span><a href="#local-6989586621680036984"><span class="hs-identifier hs-var hs-var hs-var">newRhs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)]) -&gt; CoreExpr)
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; [CoreExpr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036985"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036985"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036985"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036977"><span class="hs-identifier hs-var">rows'</span></a></span><span>
</span><span id="line-321"></span><span>                </span><span id="local-6989586621680036986"><span class="annot"><span class="annottext">newBs :: [[(Unique VarName, Var)]]
</span><a href="#local-6989586621680036986"><span class="hs-identifier hs-var hs-var hs-var">newBs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)])
 -&gt; [(Unique VarName, Var)])
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
-&gt; [[(Unique VarName, Var)]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680036987"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036987"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036987"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680036977"><span class="hs-identifier hs-var">rows'</span></a></span><span>
</span><span id="line-322"></span><span>            </span><span id="local-6989586621680036988"><span class="annot"><a href="#local-6989586621680036988"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-323"></span><span>                </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Matrix NPat -&gt; Int
forall a. Matrix a -&gt; Int
</span><span class="hs-identifier hs-var">Mat.nrows</span></span><span> </span><span class="annot"><span class="annottext">Matrix NPat
</span><a href="#local-6989586621680036982"><span class="hs-identifier hs-var">newPats</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-324"></span><span>                    </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Literal -&gt; CoreExpr
forall b. Literal -&gt; Expr b
</span><a href="Elara.Core.html#Lit"><span class="hs-identifier hs-var">Core.Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-325"></span><span>                    </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-var">compileMatrix</span></a></span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680036970"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680036971"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680036973"><span class="hs-identifier hs-var">restScruts</span></a></span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span class="hs-special">{</span><span class="annot"><span class="annottext">pmPats :: Matrix NPat
</span><a href="Elara.ToCore.Match.html#pmPats"><span class="hs-identifier hs-var">pmPats</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Matrix NPat
</span><a href="#local-6989586621680036982"><span class="hs-identifier hs-var">newPats</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmRhs :: [CoreExpr]
</span><a href="Elara.ToCore.Match.html#pmRhs"><span class="hs-identifier hs-var">pmRhs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[CoreExpr]
</span><a href="#local-6989586621680036984"><span class="hs-identifier hs-var">newRhs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmBinds :: [[(Unique VarName, Var)]]
</span><a href="Elara.ToCore.Match.html#pmBinds"><span class="hs-identifier hs-var">pmBinds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[(Unique VarName, Var)]]
</span><a href="#local-6989586621680036986"><span class="hs-identifier hs-var">newBs</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-326"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#DEFAULT"><span class="hs-identifier hs-type">Core.DEFAULT</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621680036988"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-327"></span><span>
</span><span id="line-328"></span><span class="hs-comment">-- Emit nested non-recursive lets for collected variable bindings.</span><span>
</span><span id="line-329"></span><span class="annot"><a href="Elara.ToCore.Match.html#emitBinds"><span class="hs-identifier hs-type">emitBinds</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier hs-type">Unique</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier hs-type">VarName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span>
</span><span id="line-330"></span><span id="emitBinds"><span class="annot"><span class="annottext">emitBinds :: [(Unique VarName, Var)] -&gt; CoreExpr -&gt; CoreExpr
</span><a href="Elara.ToCore.Match.html#emitBinds"><span class="hs-identifier hs-var hs-var">emitBinds</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span id="local-6989586621680036995"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036995"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036995"><span class="hs-identifier hs-var">body</span></a></span><span>
</span><span id="line-331"></span><span class="annot"><a href="Elara.ToCore.Match.html#emitBinds"><span class="hs-identifier hs-var">emitBinds</span></a></span><span> </span><span id="local-6989586621680036996"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036996"><span class="hs-identifier hs-var">bs</span></a></span></span><span> </span><span id="local-6989586621680036997"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036997"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-332"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span class="annot"><a href="#local-6989586621680036998"><span class="hs-identifier hs-type">mkBinder</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier hs-type">Unique</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier hs-type">VarName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span>
</span><span id="line-333"></span><span>        </span><span id="local-6989586621680036998"><span class="annot"><span class="annottext">mkBinder :: (Unique VarName, Var) -&gt; Maybe Var
</span><a href="#local-6989586621680036998"><span class="hs-identifier hs-var hs-var">mkBinder</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680036999"><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680036999"><span class="hs-identifier hs-var">u</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680037000"><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680037000"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680037000"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-334"></span><span>            </span><span class="annot"><a href="Elara.Core.html#Id"><span class="hs-identifier hs-type">Core.Id</span></a></span><span> </span><span class="annot"><span class="annottext">UnlocatedVarRef Text
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680037002"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621680037002"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe DataCon
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-335"></span><span>                </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680037003"><span class="annot"><span class="annottext">uqText :: Unique Text
</span><a href="#local-6989586621680037003"><span class="hs-identifier hs-var hs-var">uqText</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(VarName -&gt; Text) -&gt; Unique VarName -&gt; Unique Text
forall a b. (a -&gt; b) -&gt; Unique a -&gt; Unique b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">VarName -&gt; Text
forall name. NameLike name =&gt; name -&gt; Text
</span><a href="Elara.AST.Name.html#nameText"><span class="hs-identifier hs-var">nameText</span></a></span><span> </span><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680036999"><span class="hs-identifier hs-var">u</span></a></span><span>
</span><span id="line-336"></span><span>                    </span><span class="annot"><a href="#local-6989586621680037005"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.AST.VarRef.html#UnlocatedVarRef"><span class="hs-identifier hs-type">UnlocatedVarRef</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span>
</span><span id="line-337"></span><span>                    </span><span id="local-6989586621680037005"><span class="annot"><span class="annottext">b :: UnlocatedVarRef Text
</span><a href="#local-6989586621680037005"><span class="hs-identifier hs-var hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VarRefImpl UnlocatedVarRefKind (Unique Text)
-&gt; UnlocatedVarRef Text
forall (c :: VarRefKind) n. VarRefImpl c (Unique n) -&gt; VarRef' c n
</span><a href="Elara.AST.VarRef.html#Local"><span class="hs-identifier hs-var">Local</span></a></span><span> </span><span class="annot"><span class="annottext">Unique Text
VarRefImpl UnlocatedVarRefKind (Unique Text)
</span><a href="#local-6989586621680037003"><span class="hs-identifier hs-var">uqText</span></a></span><span>
</span><span id="line-338"></span><span>                 </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Var -&gt; Maybe Var
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">UnlocatedVarRef Text -&gt; Type -&gt; Maybe DataCon -&gt; Var
</span><a href="Elara.Core.html#Id"><span class="hs-identifier hs-var">Core.Id</span></a></span><span> </span><span class="annot"><span class="annottext">UnlocatedVarRef Text
</span><a href="#local-6989586621680037005"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621680037002"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe DataCon
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-339"></span><span>            </span><span class="annot"><a href="Elara.Core.html#TyVar"><span class="hs-identifier hs-type">Core.TyVar</span></a></span><span> </span><span class="annot"><span class="annottext">TypeVariable
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Var
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-340"></span><span>        </span><span id="local-6989586621680037008"><span class="annot"><span class="annottext">mkLet :: (b, b) -&gt; Expr b -&gt; Expr b
</span><a href="#local-6989586621680037008"><span class="hs-identifier hs-var hs-var">mkLet</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680037009"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621680037009"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680037010"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621680037010"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bind b -&gt; Expr b -&gt; Expr b
forall b. Bind b -&gt; Expr b -&gt; Expr b
</span><a href="Elara.Core.html#Let"><span class="hs-identifier hs-var">Core.Let</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(b, Expr b) -&gt; Bind b
forall b (expr :: * -&gt; *). (b, expr b) -&gt; Bind b expr
</span><a href="Elara.Core.Generic.html#NonRecursive"><span class="hs-identifier hs-var">G.NonRecursive</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621680037009"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; Expr b
forall b. b -&gt; Expr b
</span><a href="Elara.Core.html#Var"><span class="hs-identifier hs-var">Core.Var</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621680037010"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-341"></span><span>        </span><span id="local-6989586621680037013"><span class="annot"><span class="annottext">pairs :: [(Var, Var)]
</span><a href="#local-6989586621680037013"><span class="hs-identifier hs-var hs-var">pairs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680037014"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680037015"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621680037016"><span class="annot"><span class="annottext">(Unique VarName, Var)
</span><a href="#local-6989586621680037016"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680036996"><span class="hs-identifier hs-var">bs</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Unique VarName
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680037015"><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680037015"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Unique VarName, Var)
</span><a href="#local-6989586621680037016"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621680037014"><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680037014"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">(Unique VarName, Var) -&gt; Maybe Var
</span><a href="#local-6989586621680036998"><span class="hs-identifier hs-var">mkBinder</span></a></span><span> </span><span class="annot"><span class="annottext">(Unique VarName, Var)
</span><a href="#local-6989586621680037016"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><span id="line-342"></span><span>     </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">((Var, Var) -&gt; CoreExpr -&gt; CoreExpr)
-&gt; CoreExpr -&gt; [(Var, Var)] -&gt; CoreExpr
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">(Var, Var) -&gt; CoreExpr -&gt; CoreExpr
forall {b}. (b, b) -&gt; Expr b -&gt; Expr b
</span><a href="#local-6989586621680037008"><span class="hs-identifier hs-var">mkLet</span></a></span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680036997"><span class="hs-identifier hs-var">body</span></a></span><span> </span><span class="annot"><span class="annottext">[(Var, Var)]
</span><a href="#local-6989586621680037013"><span class="hs-identifier hs-var">pairs</span></a></span><span>
</span><span id="line-343"></span><span>
</span><span id="line-344"></span><span class="hs-comment">-- 1-based indexing helper aligned with Data.Matrix row indices.</span><span>
</span><span id="line-345"></span><span id="local-6989586621680036382"><span class="annot"><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-type">at1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621680036382"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680036382"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-346"></span><span id="at1"><span class="annot"><span class="annottext">at1 :: forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var hs-var">at1</span></a></span></span><span> </span><span id="local-6989586621680037026"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680037026"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621680037027"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621680037027"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [a] -&gt; [a]
forall a. Int -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">drop</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680037026"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621680037027"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-347"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621680037028"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680037028"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680037028"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-348"></span><span>    </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Text -&gt; a
forall a t. (HasCallStack, IsText t) =&gt; t -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;PMatrix row index out of bounds&quot;</span></span><span>
</span><span id="line-349"></span><span>
</span><span id="line-350"></span><span id="coreConstructorTypeArgs"><span class="annot"><span class="annottext">coreConstructorTypeArgs :: Type -&gt; [a]
</span><a href="Elara.ToCore.Match.html#coreConstructorTypeArgs"><span class="hs-identifier hs-var hs-var">coreConstructorTypeArgs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-351"></span><span>    </span><span class="annot"><a href="Elara.Core.html#ConTy"><span class="hs-identifier hs-type">Core.ConTy</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#TyCon"><span class="hs-identifier hs-type">Core.TyCon</span></a></span><span> </span><span id="local-6989586621680037033"><span class="annot"><span class="annottext">Qualified Text
</span><a href="#local-6989586621680037033"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#TyADT"><span class="hs-identifier hs-type">Core.TyADT</span></a></span><span> </span><span id="local-6989586621680037035"><span class="annot"><span class="annottext">[Qualified Text]
</span><a href="#local-6989586621680037035"><span class="hs-identifier hs-var">adts</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-352"></span><span>    </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-353"></span></pre></body></html>