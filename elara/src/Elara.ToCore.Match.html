<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="annot"><span class="hs-comment">{- |
Maranget-style pattern match compilation using a compact pattern matrix.

This module normalises surface patterns into 'NPat' and compiles a matrix
of such patterns into Core case expressions. We store the rectangular grid
of patterns in a 'Data.Matrix.Matrix', while per-row metadata (RHS payloads
and accumulated variable bindings) are kept in parallel lists aligned by
row index.

Key points:
- We always discriminate on column 0 (the head scrutinee) and recursively
  refine the matrix.
- Variable patterns behave as wildcards for decision making, but we record
  their binds and emit them as nested non-recursive Core lets at leaves.
- Constructor alternatives extend the scrutinee list with freshly bound
  field variables and push their argument patterns into the matrix.
-}</span></span><span>
</span><span id="line-20"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html"><span class="hs-identifier">Elara.ToCore.Match</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-21"></span><span>
</span><span id="line-22"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map.Strict</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">M</span></span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Matrix</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Mat</span></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Text</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">T</span></span><span>
</span><span id="line-25"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Eff</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(:&gt;)</span></span><span class="hs-special">)</span><span>
</span><span id="line-26"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Generic.Types.html"><span class="hs-identifier">Elara.AST.Generic.Types</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">AST</span></span><span>
</span><span id="line-27"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Name.html"><span class="hs-identifier">Elara.AST.Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#ModuleName"><span class="hs-identifier">ModuleName</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Name.html#NameLike"><span class="hs-identifier">NameLike</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Name.html#Qualified"><span class="hs-identifier">Qualified</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Name.html#TypeName"><span class="hs-identifier">TypeName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier">VarName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-28"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Region.html"><span class="hs-identifier">Elara.AST.Region</span></a></span><span>
</span><span id="line-29"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Typed.html"><span class="hs-identifier">Elara.AST.Typed</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Typed</span></span><span>
</span><span id="line-30"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.VarRef.html"><span class="hs-identifier">Elara.AST.VarRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.VarRef.html#UnlocatedVarRef"><span class="hs-identifier">UnlocatedVarRef</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.VarRef.html#VarRef%27"><span class="hs-identifier">VarRef'</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Core.html"><span class="hs-identifier">Elara.Core</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Core</span></span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Core.Analysis.html"><span class="hs-identifier">Elara.Core.Analysis</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Core</span></span><span>
</span><span id="line-33"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Core.Generic.html"><span class="hs-identifier">Elara.Core.Generic</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">G</span></span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Core.Pretty.html"><span class="hs-identifier">Elara.Core.Pretty</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Data.Pretty.html"><span class="hs-identifier">Elara.Data.Pretty</span></a></span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Data.Unique.html"><span class="hs-identifier">Elara.Data.Unique</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier">Unique</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Logging.html"><span class="hs-identifier">Elara.Logging</span></a></span><span>
</span><span id="line-38"></span><span>
</span><span id="line-39"></span><span class="hs-comment">{- Our initial step in compiling pattern matching is to construct a pattern matrix
of the patterns used in a match
For example, consider the following code:
@
f l = match l with
    (Nil, _) -&gt; x
    (_, Nil) -&gt; y
    (Cons x xs, Cons y ys) -&gt; z
@

The ultimate goal with this desugaring process is to turn all pattern matching into simple matches upon either:
- A single value
- A constructor with its values bound as variables

For example, the above code would be desugared into something like:
@
f l = match l with
    (x, y) -&gt; match x with
        Nil -&gt; x
        _ -&gt; match y with
            Nil -&gt; y
            _ -&gt; z
@

however this is difficult to do in a single pass.

Basic pattern-matrix construction

We define a small normalized pattern language (NPat) that abstracts over the
surface TypedPattern forms but keeps exactly the information a matrix needs:

- Wildcards/variables as default-able cases (we record var names for later binds)
- Literals as equality-discriminated heads
- Constructors with their subpatterns (still in NPat form). We keep the
  constructor as a qualified Text (no DataCon resolution here) to avoid
  coupling and cycles; resolution can happen later when building Core.

For now we build a single-column matrix since `match` in the current AST
matches one scrutinee. Product (tuple/record) expansion can be layered on later
by transforming the first column.
-}</span><span>
</span><span id="line-80"></span><span>
</span><span id="line-81"></span><span class="annot"><span class="hs-comment">-- | Normalized pattern</span></span><span>
</span><span id="line-82"></span><span class="hs-keyword">data</span><span> </span><span id="NPat"><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-var">NPat</span></a></span></span><span>
</span><span id="line-83"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="PWild"><span class="annot"><a href="Elara.ToCore.Match.html#PWild"><span class="hs-identifier hs-var">PWild</span></a></span></span><span>
</span><span id="line-84"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PVar"><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-var">PVar</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier hs-type">Unique</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier hs-type">VarName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- variable bind; treated like wildcard for the decision tree</span><span>
</span><span id="line-85"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PLit"><span class="annot"><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span></span><span> </span><span class="annot"><a href="Elara.Core.html#Literal"><span class="hs-identifier hs-type">Core.Literal</span></a></span><span> </span><span class="hs-comment">-- literal match</span><span>
</span><span id="line-86"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PCon"><span class="annot"><a href="Elara.ToCore.Match.html#PCon"><span class="hs-identifier hs-var">PCon</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#Qualified"><span class="hs-identifier hs-type">Qualified</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- constructor with subpatterns</span><span>
</span><span id="line-87"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680031904"><span id="local-6989586621680031921"><span id="local-6989586621680031925"><span class="annot"><span class="annottext">Int -&gt; NPat -&gt; ShowS
[NPat] -&gt; ShowS
NPat -&gt; String
(Int -&gt; NPat -&gt; ShowS)
-&gt; (NPat -&gt; String) -&gt; ([NPat] -&gt; ShowS) -&gt; Show NPat
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; NPat -&gt; ShowS
showsPrec :: Int -&gt; NPat -&gt; ShowS
$cshow :: NPat -&gt; String
show :: NPat -&gt; String
$cshowList :: [NPat] -&gt; ShowS
showList :: [NPat] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680031932"><span id="local-6989586621680031948"><span class="annot"><span class="annottext">NPat -&gt; NPat -&gt; Bool
(NPat -&gt; NPat -&gt; Bool) -&gt; (NPat -&gt; NPat -&gt; Bool) -&gt; Eq NPat
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: NPat -&gt; NPat -&gt; Bool
== :: NPat -&gt; NPat -&gt; Bool
$c/= :: NPat -&gt; NPat -&gt; Bool
/= :: NPat -&gt; NPat -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680031955"><span id="local-6989586621680031957"><span class="annot"><span class="annottext">(forall x. NPat -&gt; Rep NPat x)
-&gt; (forall x. Rep NPat x -&gt; NPat) -&gt; Generic NPat
forall x. Rep NPat x -&gt; NPat
forall x. NPat -&gt; Rep NPat x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. NPat -&gt; Rep NPat x
from :: forall x. NPat -&gt; Rep NPat x
$cto :: forall x. Rep NPat x -&gt; NPat
to :: forall x. Rep NPat x -&gt; NPat
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-88"></span><span>
</span><span id="line-89"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621680031963"><span class="annot"><a href="Elara.Data.Pretty.html#Pretty"><span class="hs-identifier hs-type">Pretty</span></a></span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span></span><span>
</span><span id="line-90"></span><span>
</span><span id="line-91"></span><span class="annot"><span class="hs-comment">{- | Pattern matrix backed by 'Data.Matrix'. Invariant:
 nrows pmPats == length pmRhs == length pmBinds
-}</span></span><span>
</span><span id="line-94"></span><span class="hs-keyword">data</span><span> </span><span id="PMatrix"><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-var">PMatrix</span></a></span></span><span> </span><span id="local-6989586621680031746"><span class="annot"><a href="#local-6989586621680031746"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="PMatrix"><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-var">PMatrix</span></a></span></span><span>
</span><span id="line-95"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="pmPats"><span class="annot"><span class="annottext">forall a. PMatrix a -&gt; Matrix NPat
</span><a href="Elara.ToCore.Match.html#pmPats"><span class="hs-identifier hs-var hs-var">pmPats</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Mat.Matrix</span></span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span>
</span><span id="line-96"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="pmRhs"><span class="annot"><span class="annottext">forall a. PMatrix a -&gt; [a]
</span><a href="Elara.ToCore.Match.html#pmRhs"><span class="hs-identifier hs-var hs-var">pmRhs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621680031746"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-97"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="pmBinds"><span class="annot"><span class="annottext">forall a. PMatrix a -&gt; [[(Unique VarName, Var)]]
</span><a href="Elara.ToCore.Match.html#pmBinds"><span class="hs-identifier hs-var hs-var">pmBinds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier hs-type">Unique</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier hs-type">VarName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><span id="line-98"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-99"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680032035"><span id="local-6989586621680032044"><span id="local-6989586621680032048"><span class="annot"><span class="annottext">Int -&gt; PMatrix a -&gt; ShowS
[PMatrix a] -&gt; ShowS
PMatrix a -&gt; String
(Int -&gt; PMatrix a -&gt; ShowS)
-&gt; (PMatrix a -&gt; String)
-&gt; ([PMatrix a] -&gt; ShowS)
-&gt; Show (PMatrix a)
forall a. Show a =&gt; Int -&gt; PMatrix a -&gt; ShowS
forall a. Show a =&gt; [PMatrix a] -&gt; ShowS
forall a. Show a =&gt; PMatrix a -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: forall a. Show a =&gt; Int -&gt; PMatrix a -&gt; ShowS
showsPrec :: Int -&gt; PMatrix a -&gt; ShowS
$cshow :: forall a. Show a =&gt; PMatrix a -&gt; String
show :: PMatrix a -&gt; String
$cshowList :: forall a. Show a =&gt; [PMatrix a] -&gt; ShowS
showList :: [PMatrix a] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032058"><span id="local-6989586621680032066"><span class="annot"><span class="annottext">PMatrix a -&gt; PMatrix a -&gt; Bool
(PMatrix a -&gt; PMatrix a -&gt; Bool)
-&gt; (PMatrix a -&gt; PMatrix a -&gt; Bool) -&gt; Eq (PMatrix a)
forall a. Eq a =&gt; PMatrix a -&gt; PMatrix a -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: forall a. Eq a =&gt; PMatrix a -&gt; PMatrix a -&gt; Bool
== :: PMatrix a -&gt; PMatrix a -&gt; Bool
$c/= :: forall a. Eq a =&gt; PMatrix a -&gt; PMatrix a -&gt; Bool
/= :: PMatrix a -&gt; PMatrix a -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-100"></span><span>
</span><span id="line-101"></span><span class="annot"><span class="hs-comment">{- | Build a single-column pattern matrix from branches (pattern, rhs).
The RHS is left polymorphic so callers can carry either TypedExpr or CoreExpr.
-}</span></span><span>
</span><span id="line-104"></span><span id="local-6989586621680031764"><span class="annot"><a href="Elara.ToCore.Match.html#buildMatrix1"><span class="hs-identifier hs-type">buildMatrix1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Typed.html#TypedPattern"><span class="hs-identifier hs-type">TypedPattern</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621680031764"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680031764"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-105"></span><span id="buildMatrix1"><span class="annot"><span class="annottext">buildMatrix1 :: forall a. [(TypedPattern, a)] -&gt; PMatrix a
</span><a href="Elara.ToCore.Match.html#buildMatrix1"><span class="hs-identifier hs-var hs-var">buildMatrix1</span></a></span></span><span> </span><span id="local-6989586621680032079"><span class="annot"><span class="annottext">[(TypedPattern, a)]
</span><a href="#local-6989586621680032079"><span class="hs-identifier hs-var">branches</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-106"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032080"><span class="annot"><span class="annottext">pats :: Matrix NPat
</span><a href="#local-6989586621680032080"><span class="hs-identifier hs-var hs-var">pats</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; [NPat] -&gt; Matrix NPat
forall a. Int -&gt; Int -&gt; [a] -&gt; Matrix a
</span><span class="hs-identifier hs-var">Mat.fromList</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(TypedPattern, a)] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[(TypedPattern, a)]
</span><a href="#local-6989586621680032079"><span class="hs-identifier hs-var">branches</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((TypedPattern, a) -&gt; NPat) -&gt; [(TypedPattern, a)] -&gt; [NPat]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TypedPattern -&gt; NPat
</span><a href="Elara.ToCore.Match.html#toNPat"><span class="hs-identifier hs-var">toNPat</span></a></span><span> </span><span class="annot"><span class="annottext">(TypedPattern -&gt; NPat)
-&gt; ((TypedPattern, a) -&gt; TypedPattern) -&gt; (TypedPattern, a) -&gt; NPat
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(TypedPattern, a) -&gt; TypedPattern
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[(TypedPattern, a)]
</span><a href="#local-6989586621680032079"><span class="hs-identifier hs-var">branches</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-107"></span><span>        </span><span id="local-6989586621680032086"><span class="annot"><span class="annottext">rhs :: [a]
</span><a href="#local-6989586621680032086"><span class="hs-identifier hs-var hs-var">rhs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((TypedPattern, a) -&gt; a) -&gt; [(TypedPattern, a)] -&gt; [a]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(TypedPattern, a) -&gt; a
forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span> </span><span class="annot"><span class="annottext">[(TypedPattern, a)]
</span><a href="#local-6989586621680032079"><span class="hs-identifier hs-var">branches</span></a></span><span>
</span><span id="line-108"></span><span>        </span><span id="local-6989586621680032088"><span class="annot"><span class="annottext">binds :: [[(Unique VarName, Var)]]
</span><a href="#local-6989586621680032088"><span class="hs-identifier hs-var hs-var">binds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [(Unique VarName, Var)] -&gt; [[(Unique VarName, Var)]]
forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">replicate</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(TypedPattern, a)] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[(TypedPattern, a)]
</span><a href="#local-6989586621680032079"><span class="hs-identifier hs-var">branches</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-109"></span><span>     </span><span class="hs-keyword">in</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span class="hs-special">{</span><span class="annot"><span class="annottext">pmPats :: Matrix NPat
</span><a href="Elara.ToCore.Match.html#pmPats"><span class="hs-identifier hs-var">pmPats</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Matrix NPat
</span><a href="#local-6989586621680032080"><span class="hs-identifier hs-var">pats</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmRhs :: [a]
</span><a href="Elara.ToCore.Match.html#pmRhs"><span class="hs-identifier hs-var">pmRhs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621680032086"><span class="hs-identifier hs-var">rhs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmBinds :: [[(Unique VarName, Var)]]
</span><a href="Elara.ToCore.Match.html#pmBinds"><span class="hs-identifier hs-var">pmBinds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[(Unique VarName, Var)]]
</span><a href="#local-6989586621680032088"><span class="hs-identifier hs-var">binds</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-110"></span><span>
</span><span id="line-111"></span><span class="annot"><span class="hs-comment">-- | Convert a TypedPattern into our normalized NPat form.</span></span><span>
</span><span id="line-112"></span><span class="annot"><a href="Elara.ToCore.Match.html#toNPat"><span class="hs-identifier hs-type">toNPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.AST.Typed.html#TypedPattern"><span class="hs-identifier hs-type">TypedPattern</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span>
</span><span id="line-113"></span><span id="toNPat"><span class="annot"><span class="annottext">toNPat :: TypedPattern -&gt; NPat
</span><a href="Elara.ToCore.Match.html#toNPat"><span class="hs-identifier hs-var hs-var">toNPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Generic.Types.html#Pattern"><span class="hs-identifier hs-type">AST.Pattern</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680032092"><span class="annot"><span class="annottext">Pattern' 'Typed
</span><a href="#local-6989586621680032092"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032093"><span class="annot"><span class="annottext">Select PatternType 'Typed
</span><a href="#local-6989586621680032093"><span class="hs-identifier hs-var">_t</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pattern' 'Typed -&gt; NPat
</span><a href="#local-6989586621680032094"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pattern' 'Typed
</span><a href="#local-6989586621680032092"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-114"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-115"></span><span>    </span><span id="local-6989586621680032094"><span class="annot"><span class="annottext">go :: Pattern' 'Typed -&gt; NPat
</span><a href="#local-6989586621680032094"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-116"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#IntegerPattern"><span class="hs-identifier hs-type">AST.IntegerPattern</span></a></span><span> </span><span id="local-6989586621680032096"><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621680032096"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Integer -&gt; Literal
</span><a href="Elara.Core.html#Int"><span class="hs-identifier hs-var">Core.Int</span></a></span><span> </span><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621680032096"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-117"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#FloatPattern"><span class="hs-identifier hs-type">AST.FloatPattern</span></a></span><span> </span><span id="local-6989586621680032099"><span class="annot"><span class="annottext">Double
</span><a href="#local-6989586621680032099"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Double -&gt; Literal
</span><a href="Elara.Core.html#Double"><span class="hs-identifier hs-var">Core.Double</span></a></span><span> </span><span class="annot"><span class="annottext">Double
</span><a href="#local-6989586621680032099"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-118"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#StringPattern"><span class="hs-identifier hs-type">AST.StringPattern</span></a></span><span> </span><span id="local-6989586621680032102"><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680032102"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Text -&gt; Literal
</span><a href="Elara.Core.html#String"><span class="hs-identifier hs-var">Core.String</span></a></span><span> </span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680032102"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-119"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#CharPattern"><span class="hs-identifier hs-type">AST.CharPattern</span></a></span><span> </span><span id="local-6989586621680032105"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680032105"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char -&gt; Literal
</span><a href="Elara.Core.html#Char"><span class="hs-identifier hs-var">Core.Char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621680032105"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-120"></span><span>        </span><span class="annot"><span class="annottext">Pattern' 'Typed
</span><a href="Elara.AST.Generic.Types.html#UnitPattern"><span class="hs-identifier hs-var">AST.UnitPattern</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span>
</span><span id="line-121"></span><span>        </span><span class="annot"><span class="annottext">Pattern' 'Typed
</span><a href="Elara.AST.Generic.Types.html#WildcardPattern"><span class="hs-identifier hs-var">AST.WildcardPattern</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="Elara.ToCore.Match.html#PWild"><span class="hs-identifier hs-var">PWild</span></a></span><span>
</span><span id="line-122"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#VarPattern"><span class="hs-identifier hs-type">AST.VarPattern</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680032111"><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680032111"><span class="hs-identifier hs-var">uvn</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Unique VarName -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-var">PVar</span></a></span><span> </span><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680032111"><span class="hs-identifier hs-var">uvn</span></a></span><span>
</span><span id="line-123"></span><span>        </span><span class="annot"><a href="Elara.AST.Generic.Types.html#ConstructorPattern"><span class="hs-identifier hs-type">AST.ConstructorPattern</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><span class="annottext">SourceRegion
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680032113"><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680032113"><span class="hs-identifier hs-var">qn</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621680032114"><span class="annot"><span class="annottext">[TypedPattern]
</span><a href="#local-6989586621680032114"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-124"></span><span>            </span><span class="annot"><span class="annottext">Qualified TypeName -&gt; [NPat] -&gt; NPat
</span><a href="Elara.ToCore.Match.html#PCon"><span class="hs-identifier hs-var">PCon</span></a></span><span> </span><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680032113"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(TypedPattern -&gt; NPat) -&gt; [TypedPattern] -&gt; [NPat]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TypedPattern -&gt; NPat
</span><a href="Elara.ToCore.Match.html#toNPat"><span class="hs-identifier hs-var">toNPat</span></a></span><span> </span><span class="annot"><span class="annottext">[TypedPattern]
</span><a href="#local-6989586621680032114"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-125"></span><span>
</span><span id="line-126"></span><span class="hs-comment">-- No explicit partition/drop helpers are needed with the matrix-based layout.</span><span>
</span><span id="line-127"></span><span>
</span><span id="line-128"></span><span class="hs-comment">{-
  Minimal compiler from a PMatrix to Core.
  - Single scrutinee to start; after matching a constructor with n fields we
    extend the scrutinee list with the freshly-bound field variables before the
    remaining columns. We always discriminate on column 0.
  - Variable patterns are currently treated as wildcards; binding them to user
    names can be layered in later by threading a bind-env per row and emitting
    Let at leaves.
-}</span><span>
</span><span id="line-137"></span><span>
</span><span id="line-138"></span><span class="hs-keyword">type</span><span> </span><span id="ConResolver"><span class="annot"><a href="Elara.ToCore.Match.html#ConResolver"><span class="hs-identifier hs-var">ConResolver</span></a></span></span><span> </span><span id="local-6989586621680032115"><span class="annot"><a href="#local-6989586621680032115"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Elara.AST.Name.html#Qualified"><span class="hs-identifier hs-type">Qualified</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680032115"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#DataCon"><span class="hs-identifier hs-type">Core.DataCon</span></a></span><span>
</span><span id="line-139"></span><span>
</span><span id="line-140"></span><span class="hs-keyword">type</span><span> </span><span id="FreshLocal"><span class="annot"><a href="Elara.ToCore.Match.html#FreshLocal"><span class="hs-identifier hs-var">FreshLocal</span></a></span></span><span> </span><span id="local-6989586621680032116"><span class="annot"><a href="#local-6989586621680032116"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">T.Text</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Core.html#Type"><span class="hs-identifier hs-type">Core.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680032116"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span>
</span><span id="line-141"></span><span>
</span><span id="line-142"></span><span class="annot"><span class="hs-comment">{- | Compile a pattern matrix to a Core expression. Assumes the first column
corresponds to the head scrutinee in the provided list of variables.
-}</span></span><span>
</span><span id="line-145"></span><span id="local-6989586621680031793"><span class="annot"><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-type">compileMatrix</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier hs-type">StructuredDebug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680031793"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#ConResolver"><span class="hs-identifier hs-type">ConResolver</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680031793"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#FreshLocal"><span class="hs-identifier hs-type">FreshLocal</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680031793"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680031793"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span></span><span>
</span><span id="line-146"></span><span id="compileMatrix"><span class="annot"><span class="annottext">compileMatrix :: forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-var hs-var">compileMatrix</span></a></span></span><span> </span><span id="local-6989586621680032130"><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680032130"><span class="hs-identifier hs-var">resolveCon</span></a></span></span><span> </span><span id="local-6989586621680032131"><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680032131"><span class="hs-identifier hs-var">fresh</span></a></span></span><span> </span><span id="local-6989586621680032132"><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680032132"><span class="hs-identifier hs-var">scruts</span></a></span></span><span> </span><span id="local-6989586621680032133"><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032133"><span class="hs-identifier hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-147"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Matrix NPat -&gt; Int
forall a. Matrix a -&gt; Int
</span><span class="hs-identifier hs-var">Mat.ncols</span></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032133"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmPats</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-148"></span><span>        </span><span class="hs-keyword">then</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032133"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032133"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-149"></span><span>            </span><span class="hs-special">(</span><span id="local-6989586621680032135"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032135"><span class="hs-identifier hs-var">rhs0</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><span class="annottext">[CoreExpr]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032136"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032136"><span class="hs-identifier hs-var">binds0</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><span class="annottext">[[(Unique VarName, Var)]]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(Unique VarName, Var)] -&gt; CoreExpr -&gt; CoreExpr
</span><a href="Elara.ToCore.Match.html#emitBinds"><span class="hs-identifier hs-var">emitBinds</span></a></span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032136"><span class="hs-identifier hs-var">binds0</span></a></span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032135"><span class="hs-identifier hs-var">rhs0</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-150"></span><span>            </span><span class="annot"><span class="annottext">([CoreExpr], [[(Unique VarName, Var)]])
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Literal -&gt; CoreExpr
forall b. Literal -&gt; Expr b
</span><a href="Elara.Core.html#Lit"><span class="hs-identifier hs-var">Core.Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-151"></span><span>        </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#stepOnColumn0"><span class="hs-identifier hs-var">stepOnColumn0</span></a></span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680032130"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680032131"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680032132"><span class="hs-identifier hs-var">scruts</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032133"><span class="hs-identifier hs-var">pm</span></a></span><span>
</span><span id="line-152"></span><span>
</span><span id="line-153"></span><span id="local-6989586621680032140"><span class="annot"><a href="Elara.ToCore.Match.html#stepOnColumn0"><span class="hs-identifier hs-type">stepOnColumn0</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier hs-type">StructuredDebug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680032140"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#ConResolver"><span class="hs-identifier hs-type">ConResolver</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680032140"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#FreshLocal"><span class="hs-identifier hs-type">FreshLocal</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680032140"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680032140"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span></span><span>
</span><span id="line-154"></span><span id="stepOnColumn0"><span class="annot"><span class="annottext">stepOnColumn0 :: forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#stepOnColumn0"><span class="hs-identifier hs-var hs-var">stepOnColumn0</span></a></span></span><span> </span><span id="local-6989586621680032283"><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680032283"><span class="hs-identifier hs-var">resolveCon</span></a></span></span><span> </span><span id="local-6989586621680032284"><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680032284"><span class="hs-identifier hs-var">fresh</span></a></span></span><span> </span><span id="local-6989586621680032285"><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680032285"><span class="hs-identifier hs-var">scruts</span></a></span></span><span> </span><span id="local-6989586621680032286"><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-155"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680032285"><span class="hs-identifier hs-var">scruts</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-156"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-157"></span><span>            </span><span class="hs-comment">-- No scrutinee left. If matrix is solved, emit first row; else Unit.</span><span>
</span><span id="line-158"></span><span>            </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Matrix NPat -&gt; Int
forall a. Matrix a -&gt; Int
</span><span class="hs-identifier hs-var">Mat.ncols</span></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmPats</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-159"></span><span>                </span><span class="hs-keyword">then</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-160"></span><span>                    </span><span class="hs-special">(</span><span id="local-6989586621680032287"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032287"><span class="hs-identifier hs-var">rhs0</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><span class="annottext">[CoreExpr]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032288"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032288"><span class="hs-identifier hs-var">binds0</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><span class="annottext">[[(Unique VarName, Var)]]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(Unique VarName, Var)] -&gt; CoreExpr -&gt; CoreExpr
</span><a href="Elara.ToCore.Match.html#emitBinds"><span class="hs-identifier hs-var">emitBinds</span></a></span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032288"><span class="hs-identifier hs-var">binds0</span></a></span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032287"><span class="hs-identifier hs-var">rhs0</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-161"></span><span>                    </span><span class="annot"><span class="annottext">([CoreExpr], [[(Unique VarName, Var)]])
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Literal -&gt; CoreExpr
forall b. Literal -&gt; Expr b
</span><a href="Elara.Core.html#Lit"><span class="hs-identifier hs-var">Core.Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-162"></span><span>                </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Literal -&gt; CoreExpr
forall b. Literal -&gt; Expr b
</span><a href="Elara.Core.html#Lit"><span class="hs-identifier hs-var">Core.Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-163"></span><span>        </span><span id="local-6989586621680032289"><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680032289"><span class="hs-identifier hs-var">s0</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621680032290"><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680032290"><span class="hs-identifier hs-var">restScruts</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-164"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032291"><span class="annot"><span class="annottext">rows :: Int
</span><a href="#local-6989586621680032291"><span class="hs-identifier hs-var hs-var">rows</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Matrix NPat -&gt; Int
forall a. Matrix a -&gt; Int
</span><span class="hs-identifier hs-var">Mat.nrows</span></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmPats</span><span>
</span><span id="line-165"></span><span>                </span><span id="local-6989586621680032293"><span class="annot"><span class="annottext">cols :: Int
</span><a href="#local-6989586621680032293"><span class="hs-identifier hs-var hs-var">cols</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Matrix NPat -&gt; Int
forall a. Matrix a -&gt; Int
</span><span class="hs-identifier hs-var">Mat.ncols</span></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmPats</span><span>
</span><span id="line-166"></span><span>                </span><span id="local-6989586621680032294"><span class="annot"><span class="annottext">rowInfo :: Int -&gt; Maybe (NPat, [NPat])
</span><a href="#local-6989586621680032294"><span class="hs-identifier hs-var hs-var">rowInfo</span></a></span></span><span> </span><span id="local-6989586621680032295"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032295"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-167"></span><span>                    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032293"><span class="hs-identifier hs-var">cols</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-168"></span><span>                        </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Maybe (NPat, [NPat])
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-169"></span><span>                        </span><span class="hs-keyword">else</span><span>
</span><span id="line-170"></span><span>                            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032296"><span class="annot"><span class="annottext">p0 :: NPat
</span><a href="#local-6989586621680032296"><span class="hs-identifier hs-var hs-var">p0</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Matrix NPat -&gt; NPat
forall a. Int -&gt; Int -&gt; Matrix a -&gt; a
</span><span class="hs-identifier hs-var">Mat.getElem</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032295"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmPats</span><span>
</span><span id="line-171"></span><span>                                </span><span id="local-6989586621680032298"><span class="annot"><span class="annottext">ps :: [NPat]
</span><a href="#local-6989586621680032298"><span class="hs-identifier hs-var hs-var">ps</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Matrix NPat -&gt; NPat
forall a. Int -&gt; Int -&gt; Matrix a -&gt; a
</span><span class="hs-identifier hs-var">Mat.getElem</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032295"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032299"><span class="hs-identifier hs-var">j</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmPats</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621680032299"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032299"><span class="hs-identifier hs-var">j</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="hs-glyph">..</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032293"><span class="hs-identifier hs-var">cols</span></a></span><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><span id="line-172"></span><span>                             </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">(NPat, [NPat]) -&gt; Maybe (NPat, [NPat])
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032296"><span class="hs-identifier hs-var">p0</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032298"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-173"></span><span>                </span><span class="annot"><a href="#local-6989586621680032300"><span class="hs-identifier hs-type">foldPart</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-174"></span><span>                    </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-175"></span><span>                    </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#Qualified"><span class="hs-identifier hs-type">Qualified</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-176"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><a href="Elara.Core.html#Literal"><span class="hs-identifier hs-type">Core.Literal</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-177"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-178"></span><span>                    </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-179"></span><span>                    </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Name.html#Qualified"><span class="hs-identifier hs-type">Qualified</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-180"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><a href="Elara.Core.html#Literal"><span class="hs-identifier hs-type">Core.Literal</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-181"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-182"></span><span>                    </span><span class="hs-special">)</span><span>
</span><span id="line-183"></span><span>                </span><span id="local-6989586621680032300"><span class="annot"><span class="annottext">foldPart :: Int
-&gt; (Map (Qualified TypeName) [(Int, [NPat], [NPat])],
    Map Literal [(Int, [NPat])], [(Int, NPat, [NPat])])
-&gt; (Map (Qualified TypeName) [(Int, [NPat], [NPat])],
    Map Literal [(Int, [NPat])], [(Int, NPat, [NPat])])
</span><a href="#local-6989586621680032300"><span class="hs-identifier hs-var hs-var">foldPart</span></a></span></span><span> </span><span id="local-6989586621680032301"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032301"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680032302"><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680032302"><span class="hs-identifier hs-var">consM</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032303"><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680032303"><span class="hs-identifier hs-var">litM</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032304"><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680032304"><span class="hs-identifier hs-var">defs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-184"></span><span>                    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Maybe (NPat, [NPat])
</span><a href="#local-6989586621680032294"><span class="hs-identifier hs-var">rowInfo</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032301"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-185"></span><span>                        </span><span class="annot"><span class="annottext">Maybe (NPat, [NPat])
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680032302"><span class="hs-identifier hs-var">consM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680032303"><span class="hs-identifier hs-var">litM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680032304"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-186"></span><span>                        </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680032305"><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032305"><span class="hs-identifier hs-var">p0</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032306"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032306"><span class="hs-identifier hs-var">ps</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032305"><span class="hs-identifier hs-var">p0</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-187"></span><span>                            </span><span class="annot"><a href="Elara.ToCore.Match.html#PCon"><span class="hs-identifier hs-type">PCon</span></a></span><span> </span><span id="local-6989586621680032307"><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680032307"><span class="hs-identifier hs-var">qn</span></a></span></span><span> </span><span id="local-6989586621680032308"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032308"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-188"></span><span>                                </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032309"><span class="annot"><span class="annottext">entry :: (Int, [NPat], [NPat])
</span><a href="#local-6989586621680032309"><span class="hs-identifier hs-var hs-var">entry</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032301"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032308"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032306"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-189"></span><span>                                 </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">([(Int, [NPat], [NPat])]
 -&gt; [(Int, [NPat], [NPat])] -&gt; [(Int, [NPat], [NPat])])
-&gt; Qualified TypeName
-&gt; [(Int, [NPat], [NPat])]
-&gt; Map (Qualified TypeName) [(Int, [NPat], [NPat])]
-&gt; Map (Qualified TypeName) [(Int, [NPat], [NPat])]
forall k a. Ord k =&gt; (a -&gt; a -&gt; a) -&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">M.insertWith</span></span><span> </span><span class="annot"><span class="annottext">[(Int, [NPat], [NPat])]
-&gt; [(Int, [NPat], [NPat])] -&gt; [(Int, [NPat], [NPat])]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">(++)</span></span><span> </span><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680032307"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">(Int, [NPat], [NPat])
</span><a href="#local-6989586621680032309"><span class="hs-identifier hs-var">entry</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680032302"><span class="hs-identifier hs-var">consM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680032303"><span class="hs-identifier hs-var">litM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680032304"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-190"></span><span>                            </span><span class="annot"><a href="Elara.ToCore.Match.html#PLit"><span class="hs-identifier hs-type">PLit</span></a></span><span> </span><span id="local-6989586621680032311"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621680032311"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-191"></span><span>                                </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032312"><span class="annot"><span class="annottext">entry :: (Int, [NPat])
</span><a href="#local-6989586621680032312"><span class="hs-identifier hs-var hs-var">entry</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032301"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032306"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-192"></span><span>                                 </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680032302"><span class="hs-identifier hs-var">consM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">([(Int, [NPat])] -&gt; [(Int, [NPat])] -&gt; [(Int, [NPat])])
-&gt; Literal
-&gt; [(Int, [NPat])]
-&gt; Map Literal [(Int, [NPat])]
-&gt; Map Literal [(Int, [NPat])]
forall k a. Ord k =&gt; (a -&gt; a -&gt; a) -&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">M.insertWith</span></span><span> </span><span class="annot"><span class="annottext">[(Int, [NPat])] -&gt; [(Int, [NPat])] -&gt; [(Int, [NPat])]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">(++)</span></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621680032311"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">(Int, [NPat])
</span><a href="#local-6989586621680032312"><span class="hs-identifier hs-var">entry</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680032303"><span class="hs-identifier hs-var">litM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680032304"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-193"></span><span>                            </span><span class="annot"><span class="annottext">NPat
</span><a href="Elara.ToCore.Match.html#PWild"><span class="hs-identifier hs-var">PWild</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680032302"><span class="hs-identifier hs-var">consM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680032303"><span class="hs-identifier hs-var">litM</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032301"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032305"><span class="hs-identifier hs-var">p0</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032306"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Int, NPat, [NPat])
-&gt; [(Int, NPat, [NPat])] -&gt; [(Int, NPat, [NPat])]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680032304"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-194"></span><span>                            </span><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-type">PVar</span></a></span><span> </span><span class="annot"><span class="annottext">Unique VarName
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680032302"><span class="hs-identifier hs-var">consM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680032303"><span class="hs-identifier hs-var">litM</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032301"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032305"><span class="hs-identifier hs-var">p0</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032306"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Int, NPat, [NPat])
-&gt; [(Int, NPat, [NPat])] -&gt; [(Int, NPat, [NPat])]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680032304"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-195"></span><span>                </span><span class="hs-special">(</span><span id="local-6989586621680032313"><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680032313"><span class="hs-identifier hs-var">consM</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032314"><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680032314"><span class="hs-identifier hs-var">litM</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032315"><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680032315"><span class="hs-identifier hs-var">defs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Int
 -&gt; (Map (Qualified TypeName) [(Int, [NPat], [NPat])],
     Map Literal [(Int, [NPat])], [(Int, NPat, [NPat])])
 -&gt; (Map (Qualified TypeName) [(Int, [NPat], [NPat])],
     Map Literal [(Int, [NPat])], [(Int, NPat, [NPat])]))
-&gt; (Map (Qualified TypeName) [(Int, [NPat], [NPat])],
    Map Literal [(Int, [NPat])], [(Int, NPat, [NPat])])
-&gt; [Int]
-&gt; (Map (Qualified TypeName) [(Int, [NPat], [NPat])],
    Map Literal [(Int, [NPat])], [(Int, NPat, [NPat])])
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">Int
-&gt; (Map (Qualified TypeName) [(Int, [NPat], [NPat])],
    Map Literal [(Int, [NPat])], [(Int, NPat, [NPat])])
-&gt; (Map (Qualified TypeName) [(Int, [NPat], [NPat])],
    Map Literal [(Int, [NPat])], [(Int, NPat, [NPat])])
</span><a href="#local-6989586621680032300"><span class="hs-identifier hs-var">foldPart</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
forall k a. Map k a
</span><span class="hs-identifier hs-var">M.empty</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
forall k a. Map k a
</span><span class="hs-identifier hs-var">M.empty</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="hs-glyph">..</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032291"><span class="hs-identifier hs-var">rows</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-196"></span><span>
</span><span id="line-197"></span><span>            </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])] -&gt; Bool
forall k a. Map k a -&gt; Bool
</span><span class="hs-identifier hs-var">M.null</span></span><span> </span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680032313"><span class="hs-identifier hs-var">consM</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-198"></span><span>                </span><span class="hs-keyword">then</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-199"></span><span>                    </span><span id="local-6989586621680032320"><span class="annot"><a href="#local-6989586621680032320"><span class="hs-identifier hs-var">conAlts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Qualified TypeName, [(Int, [NPat], [NPat])])]
-&gt; ((Qualified TypeName, [(Int, [NPat], [NPat])])
    -&gt; Eff r (AltCon, [Var], CoreExpr))
-&gt; Eff r [(AltCon, [Var], CoreExpr)]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m (t b)
</span><span class="hs-identifier hs-var">forM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
-&gt; [(Qualified TypeName, [(Int, [NPat], [NPat])])]
forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">M.toList</span></span><span> </span><span class="annot"><span class="annottext">Map (Qualified TypeName) [(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680032313"><span class="hs-identifier hs-var">consM</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(((Qualified TypeName, [(Int, [NPat], [NPat])])
  -&gt; Eff r (AltCon, [Var], CoreExpr))
 -&gt; Eff r [(AltCon, [Var], CoreExpr)])
-&gt; ((Qualified TypeName, [(Int, [NPat], [NPat])])
    -&gt; Eff r (AltCon, [Var], CoreExpr))
-&gt; Eff r [(AltCon, [Var], CoreExpr)]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680032323"><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680032323"><span class="hs-identifier hs-var">qn</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032324"><span class="annot"><span class="annottext">[(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680032324"><span class="hs-identifier hs-var">matched</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-200"></span><span>                        </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Eff r ()
forall (r :: [Effect]).
(HasCallStack, StructuredDebug :&gt; r) =&gt;
Doc AnsiStyle -&gt; Eff r ()
</span><a href="Elara.Logging.html#debug"><span class="hs-identifier hs-var">debug</span></a></span><span> </span><span class="annot"><span class="annottext">(Doc AnsiStyle -&gt; Eff r ()) -&gt; Doc AnsiStyle -&gt; Eff r ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle
</span><span class="hs-string">&quot;Compiling constructor alt for: &quot;</span></span><span> </span><span class="annot"><span class="annottext">Doc AnsiStyle -&gt; Doc AnsiStyle -&gt; Doc AnsiStyle
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Qualified TypeName, [(Int, [NPat], [NPat])]) -&gt; Doc AnsiStyle
forall a. Pretty a =&gt; a -&gt; Doc AnsiStyle
</span><a href="Elara.Data.Pretty.html#pretty"><span class="hs-identifier hs-var">pretty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680032323"><span class="hs-identifier hs-var">qn</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680032324"><span class="hs-identifier hs-var">matched</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-201"></span><span>                        </span><span id="local-6989586621680032327"><span class="annot"><a href="#local-6989586621680032327"><span class="hs-identifier hs-var">dc</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680032283"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">Qualified TypeName
</span><a href="#local-6989586621680032323"><span class="hs-identifier hs-var">qn</span></a></span><span>
</span><span id="line-202"></span><span>                        </span><span class="annot"><a href="Elara.Logging.html#debug"><span class="hs-identifier hs-type">debug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-string">&quot;dc: &quot;</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;&gt;</span></span><span> </span><span class="annot"><a href="Elara.Data.Pretty.html#pretty"><span class="hs-identifier hs-type">pretty</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032327"><span class="hs-identifier hs-type">dc</span></a></span><span>
</span><span id="line-203"></span><span>                        </span><span class="annot"><a href="Elara.Logging.html#debug"><span class="hs-identifier hs-type">debug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-string">&quot;varType: &quot;</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;&gt;</span></span><span> </span><span class="annot"><a href="Elara.Data.Pretty.html#pretty"><span class="hs-identifier hs-type">pretty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.Analysis.html#varType"><span class="hs-identifier hs-type">Core.varType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032289"><span class="hs-identifier hs-type">s0</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-204"></span><span>                        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032330"><span class="annot"><a href="#local-6989586621680032330"><span class="hs-identifier hs-var hs-var">argTys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Type]
</span><a href="Elara.Core.html#conTyArgs"><span class="hs-identifier hs-var">Core.conTyArgs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Var -&gt; Type
</span><a href="Elara.Core.Analysis.html#varType"><span class="hs-identifier hs-var">Core.varType</span></a></span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680032289"><span class="hs-identifier hs-var">s0</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-205"></span><span>                        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032332"><span class="annot"><a href="#local-6989586621680032332"><span class="hs-identifier hs-var hs-var">dcArgTys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Type]
</span><a href="Elara.Core.html#functionTypeArgs"><span class="hs-identifier hs-var">Core.functionTypeArgs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DataCon -&gt; Type
</span><a href="Elara.Core.html#dataConType"><span class="hs-identifier hs-var">Core.dataConType</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621680032327"><span class="hs-identifier hs-var">dc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-206"></span><span>
</span><span id="line-207"></span><span>                        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032335"><span class="annot"><a href="#local-6989586621680032335"><span class="hs-identifier hs-var hs-var">realArgTys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-208"></span><span>                                </span><span class="hs-comment">-- we construct the &quot;real&quot; binders as</span><span>
</span><span id="line-209"></span><span>                                </span><span class="annot"><span class="annottext">Int -&gt; [Type] -&gt; [Type]
forall a. Int -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">take</span></span><span>
</span><span id="line-210"></span><span>                                    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621680032332"><span class="hs-identifier hs-var">dcArgTys</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- no more than the amount the constructor has</span><span>
</span><span id="line-211"></span><span>                                    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621680032330"><span class="hs-identifier hs-var">argTys</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; [Type]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; [Type] -&gt; [Type]
forall a. Int -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">drop</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621680032330"><span class="hs-identifier hs-var">argTys</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621680032332"><span class="hs-identifier hs-var">dcArgTys</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- then the provided ones from the varType, plus any extras from the constructor to make up the exact length of the constructor</span><span>
</span><span id="line-212"></span><span>                        </span><span class="annot"><a href="Elara.Logging.html#debug"><span class="hs-identifier hs-type">debug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-string">&quot;argTys: &quot;</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;&gt;</span></span><span> </span><span class="annot"><a href="Elara.Data.Pretty.html#pretty"><span class="hs-identifier hs-type">pretty</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032330"><span class="hs-identifier hs-type">argTys</span></a></span><span>
</span><span id="line-213"></span><span>                        </span><span class="annot"><a href="Elara.Logging.html#debug"><span class="hs-identifier hs-type">debug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-string">&quot;realArgTys: &quot;</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;&gt;</span></span><span> </span><span class="annot"><a href="Elara.Data.Pretty.html#pretty"><span class="hs-identifier hs-type">pretty</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032335"><span class="hs-identifier hs-type">realArgTys</span></a></span><span>
</span><span id="line-214"></span><span>                        </span><span id="local-6989586621680032338"><span class="annot"><a href="#local-6989586621680032338"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">forM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">zip</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">..</span><span class="hs-special">]</span><span> </span><span class="annot"><a href="#local-6989586621680032335"><span class="hs-identifier hs-type">realArgTys</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680032339"><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621680032339"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032340"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621680032340"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680032284"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;p&quot;</span></span><span> </span><span class="annot"><span class="annottext">Text -&gt; Text -&gt; Text
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Integer -&gt; Text
forall b a. (Show a, IsString b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621680032339"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621680032340"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-215"></span><span>                        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032341"><span class="annot"><a href="#local-6989586621680032341"><span class="hs-identifier hs-var hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Var] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680032338"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-216"></span><span>                            </span><span id="local-6989586621680032342"><span class="annot"><a href="#local-6989586621680032342"><span class="hs-identifier hs-var hs-var">transformMatched</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680032343"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032343"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032344"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032344"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032345"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032345"><span class="hs-identifier hs-var">tailPs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-217"></span><span>                                </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680032346"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032346"><span class="hs-identifier hs-var">args'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032347"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032347"><span class="hs-identifier hs-var">addBinds</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Var] -&gt; [NPat] -&gt; ([NPat], [(Unique VarName, Var)])
</span><a href="#local-6989586621680032348"><span class="hs-identifier hs-var">bindImmediate</span></a></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680032338"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032344"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-218"></span><span>                                    </span><span id="local-6989586621680032349"><span class="annot"><span class="annottext">newRow :: [NPat]
</span><a href="#local-6989586621680032349"><span class="hs-identifier hs-var hs-var">newRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032346"><span class="hs-identifier hs-var">args'</span></a></span><span> </span><span class="annot"><span class="annottext">[NPat] -&gt; [NPat] -&gt; [NPat]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032345"><span class="hs-identifier hs-var">tailPs</span></a></span><span>
</span><span id="line-219"></span><span>                                    </span><span id="local-6989586621680032350"><span class="annot"><span class="annottext">rhsRow :: CoreExpr
</span><a href="#local-6989586621680032350"><span class="hs-identifier hs-var hs-var">rhsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [CoreExpr] -&gt; CoreExpr
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032343"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span>
</span><span id="line-220"></span><span>                                    </span><span id="local-6989586621680032352"><span class="annot"><span class="annottext">bindsRow :: [(Unique VarName, Var)]
</span><a href="#local-6989586621680032352"><span class="hs-identifier hs-var hs-var">bindsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032347"><span class="hs-identifier hs-var">addBinds</span></a></span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
-&gt; [(Unique VarName, Var)] -&gt; [(Unique VarName, Var)]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032343"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-221"></span><span>                                 </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032349"><span class="hs-identifier hs-var">newRow</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032350"><span class="hs-identifier hs-var">rhsRow</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032352"><span class="hs-identifier hs-var">bindsRow</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-222"></span><span>                            </span><span id="local-6989586621680032353"><span class="annot"><a href="#local-6989586621680032353"><span class="hs-identifier hs-var hs-var">transformDefault</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680032354"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032354"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032355"><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032355"><span class="hs-identifier hs-var">headPat</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032356"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032356"><span class="hs-identifier hs-var">tailPs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-223"></span><span>                                </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032357"><span class="annot"><span class="annottext">pad :: [NPat]
</span><a href="#local-6989586621680032357"><span class="hs-identifier hs-var hs-var">pad</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; NPat -&gt; [NPat]
forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">replicate</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032341"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="Elara.ToCore.Match.html#PWild"><span class="hs-identifier hs-var">PWild</span></a></span><span>
</span><span id="line-224"></span><span>                                    </span><span id="local-6989586621680032358"><span class="annot"><span class="annottext">newRow :: [NPat]
</span><a href="#local-6989586621680032358"><span class="hs-identifier hs-var hs-var">newRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032357"><span class="hs-identifier hs-var">pad</span></a></span><span> </span><span class="annot"><span class="annottext">[NPat] -&gt; [NPat] -&gt; [NPat]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032356"><span class="hs-identifier hs-var">tailPs</span></a></span><span>
</span><span id="line-225"></span><span>                                    </span><span id="local-6989586621680032359"><span class="annot"><span class="annottext">rhsRow :: CoreExpr
</span><a href="#local-6989586621680032359"><span class="hs-identifier hs-var hs-var">rhsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [CoreExpr] -&gt; CoreExpr
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032354"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span>
</span><span id="line-226"></span><span>                                    </span><span id="local-6989586621680032360"><span class="annot"><span class="annottext">bindsRow :: [(Unique VarName, Var)]
</span><a href="#local-6989586621680032360"><span class="hs-identifier hs-var hs-var">bindsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032355"><span class="hs-identifier hs-var">headPat</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-227"></span><span>                                        </span><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-type">PVar</span></a></span><span> </span><span id="local-6989586621680032361"><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680032361"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680032361"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680032289"><span class="hs-identifier hs-var">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Unique VarName, Var)
-&gt; [(Unique VarName, Var)] -&gt; [(Unique VarName, Var)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032354"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-228"></span><span>                                        </span><span class="annot"><span class="annottext">NPat
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032354"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-229"></span><span>                                 </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032358"><span class="hs-identifier hs-var">newRow</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032359"><span class="hs-identifier hs-var">rhsRow</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032360"><span class="hs-identifier hs-var">bindsRow</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-230"></span><span>                            </span><span id="local-6989586621680032362"><span class="annot"><a href="#local-6989586621680032362"><span class="hs-identifier hs-var hs-var">rowsForAlt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((Int, [NPat], [NPat])
 -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)]))
-&gt; [(Int, [NPat], [NPat])]
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(Int, [NPat], [NPat])
-&gt; ([NPat], CoreExpr, [(Unique VarName, Var)])
</span><a href="#local-6989586621680032342"><span class="hs-identifier hs-var">transformMatched</span></a></span><span> </span><span class="annot"><span class="annottext">[(Int, [NPat], [NPat])]
</span><a href="#local-6989586621680032324"><span class="hs-identifier hs-var">matched</span></a></span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">((Int, NPat, [NPat])
 -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)]))
-&gt; [(Int, NPat, [NPat])]
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(Int, NPat, [NPat]) -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)])
</span><a href="#local-6989586621680032353"><span class="hs-identifier hs-var">transformDefault</span></a></span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680032315"><span class="hs-identifier hs-var">defs</span></a></span><span>
</span><span id="line-231"></span><span>                        </span><span id="local-6989586621680032363"><span class="annot"><a href="#local-6989586621680032363"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-232"></span><span>                            </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="hs-identifier hs-type">null</span></span><span> </span><span class="annot"><a href="#local-6989586621680032362"><span class="hs-identifier hs-type">rowsForAlt</span></a></span><span>
</span><span id="line-233"></span><span>                                </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#Lit"><span class="hs-identifier hs-type">Core.Lit</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-type">Core.Unit</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-234"></span><span>                                </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-235"></span><span>                                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032365"><span class="annot"><a href="#local-6989586621680032365"><span class="hs-identifier hs-var hs-var">newPats</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[NPat]] -&gt; Matrix NPat
forall a. [[a]] -&gt; Matrix a
</span><span class="hs-identifier hs-var">Mat.fromLists</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)]) -&gt; [NPat])
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; [[NPat]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680032367"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032367"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032367"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032362"><span class="hs-identifier hs-var">rowsForAlt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-236"></span><span>                                        </span><span id="local-6989586621680032368"><span class="annot"><a href="#local-6989586621680032368"><span class="hs-identifier hs-var hs-var">newRhs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)]) -&gt; CoreExpr)
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; [CoreExpr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032369"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032369"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032369"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032362"><span class="hs-identifier hs-var">rowsForAlt</span></a></span><span>
</span><span id="line-237"></span><span>                                        </span><span id="local-6989586621680032370"><span class="annot"><a href="#local-6989586621680032370"><span class="hs-identifier hs-var hs-var">newBs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)])
 -&gt; [(Unique VarName, Var)])
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
-&gt; [[(Unique VarName, Var)]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032371"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032371"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032371"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032362"><span class="hs-identifier hs-var">rowsForAlt</span></a></span><span>
</span><span id="line-238"></span><span>                                    </span><span class="annot"><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-type">compileMatrix</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032283"><span class="hs-identifier hs-type">resolveCon</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032284"><span class="hs-identifier hs-type">fresh</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680032338"><span class="hs-identifier hs-type">xs</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">++</span></span><span> </span><span class="annot"><a href="#local-6989586621680032290"><span class="hs-identifier hs-type">restScruts</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.ToCore.Match.html#pmPats"><span class="hs-identifier hs-var">pmPats</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680032365"><span class="hs-identifier hs-type">newPats</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#pmRhs"><span class="hs-identifier hs-var">pmRhs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680032368"><span class="hs-identifier hs-type">newRhs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#pmBinds"><span class="hs-identifier hs-var">pmBinds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680032370"><span class="hs-identifier hs-type">newBs</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-239"></span><span>                        </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#DataAlt"><span class="hs-identifier hs-type">Core.DataAlt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032327"><span class="hs-identifier hs-type">dc</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621680032338"><span class="hs-identifier hs-type">xs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621680032363"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-240"></span><span>                    </span><span id="local-6989586621680032373"><span class="annot"><a href="#local-6989586621680032373"><span class="hs-identifier hs-var">defAlt</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#compileDefault"><span class="hs-identifier hs-type">compileDefault</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032283"><span class="hs-identifier hs-type">resolveCon</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032284"><span class="hs-identifier hs-type">fresh</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032289"><span class="hs-identifier hs-type">s0</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032290"><span class="hs-identifier hs-type">restScruts</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032286"><span class="hs-identifier hs-type">pm</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032315"><span class="hs-identifier hs-type">defs</span></a></span><span>
</span><span id="line-241"></span><span>                    </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="Elara.Core.html#Match"><span class="hs-identifier hs-type">Core.Match</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032289"><span class="hs-identifier hs-type">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><a href="#local-6989586621680032289"><span class="hs-identifier hs-type">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680032320"><span class="hs-identifier hs-type">conAlts</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">++</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">maybeToList</span></span><span> </span><span class="annot"><a href="#local-6989586621680032373"><span class="hs-identifier hs-type">defAlt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-242"></span><span>                </span><span class="hs-keyword">else</span><span>
</span><span id="line-243"></span><span>                    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])] -&gt; Bool
forall k a. Map k a -&gt; Bool
</span><span class="hs-identifier hs-var">M.null</span></span><span> </span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680032314"><span class="hs-identifier hs-var">litM</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-244"></span><span>                        </span><span class="hs-keyword">then</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-245"></span><span>                            </span><span id="local-6989586621680032378"><span class="annot"><a href="#local-6989586621680032378"><span class="hs-identifier hs-var">litAlts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Literal, [(Int, [NPat])])]
-&gt; ((Literal, [(Int, [NPat])]) -&gt; Eff r (AltCon, [Var], CoreExpr))
-&gt; Eff r [(AltCon, [Var], CoreExpr)]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m (t b)
</span><span class="hs-identifier hs-var">forM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])] -&gt; [(Literal, [(Int, [NPat])])]
forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">M.toList</span></span><span> </span><span class="annot"><span class="annottext">Map Literal [(Int, [NPat])]
</span><a href="#local-6989586621680032314"><span class="hs-identifier hs-var">litM</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(((Literal, [(Int, [NPat])]) -&gt; Eff r (AltCon, [Var], CoreExpr))
 -&gt; Eff r [(AltCon, [Var], CoreExpr)])
-&gt; ((Literal, [(Int, [NPat])]) -&gt; Eff r (AltCon, [Var], CoreExpr))
-&gt; Eff r [(AltCon, [Var], CoreExpr)]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680032379"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621680032379"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032380"><span class="annot"><span class="annottext">[(Int, [NPat])]
</span><a href="#local-6989586621680032380"><span class="hs-identifier hs-var">matched</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-246"></span><span>                                </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032381"><span class="annot"><span class="annottext">transformMatched :: (Int, [NPat]) -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)])
</span><a href="#local-6989586621680032381"><span class="hs-identifier hs-var hs-var hs-var">transformMatched</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680032382"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032382"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032383"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032383"><span class="hs-identifier hs-var">tailPs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-247"></span><span>                                        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032384"><span class="annot"><span class="annottext">rhsRow :: CoreExpr
</span><a href="#local-6989586621680032384"><span class="hs-identifier hs-var hs-var">rhsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [CoreExpr] -&gt; CoreExpr
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032382"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span>
</span><span id="line-248"></span><span>                                            </span><span id="local-6989586621680032385"><span class="annot"><span class="annottext">bindsRow :: [(Unique VarName, Var)]
</span><a href="#local-6989586621680032385"><span class="hs-identifier hs-var hs-var">bindsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032382"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-249"></span><span>                                         </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032383"><span class="hs-identifier hs-var">tailPs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032384"><span class="hs-identifier hs-var">rhsRow</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032385"><span class="hs-identifier hs-var">bindsRow</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-250"></span><span>                                    </span><span id="local-6989586621680032386"><span class="annot"><span class="annottext">transformDefault :: (Int, NPat, [NPat]) -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)])
</span><a href="#local-6989586621680032386"><span class="hs-identifier hs-var hs-var hs-var">transformDefault</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680032387"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032387"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032388"><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032388"><span class="hs-identifier hs-var">headPat</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032389"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032389"><span class="hs-identifier hs-var">tailPs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-251"></span><span>                                        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032390"><span class="annot"><span class="annottext">rhsRow :: CoreExpr
</span><a href="#local-6989586621680032390"><span class="hs-identifier hs-var hs-var">rhsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [CoreExpr] -&gt; CoreExpr
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032387"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span>
</span><span id="line-252"></span><span>                                            </span><span id="local-6989586621680032391"><span class="annot"><span class="annottext">bindsRow :: [(Unique VarName, Var)]
</span><a href="#local-6989586621680032391"><span class="hs-identifier hs-var hs-var">bindsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032388"><span class="hs-identifier hs-var">headPat</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-253"></span><span>                                                </span><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-type">PVar</span></a></span><span> </span><span id="local-6989586621680032392"><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680032392"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680032392"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680032289"><span class="hs-identifier hs-var">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Unique VarName, Var)
-&gt; [(Unique VarName, Var)] -&gt; [(Unique VarName, Var)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032387"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-254"></span><span>                                                </span><span class="annot"><span class="annottext">NPat
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032387"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-255"></span><span>                                         </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032389"><span class="hs-identifier hs-var">tailPs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032390"><span class="hs-identifier hs-var">rhsRow</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032391"><span class="hs-identifier hs-var">bindsRow</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-256"></span><span>                                    </span><span id="local-6989586621680032393"><span class="annot"><span class="annottext">rowsForAlt :: [([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032393"><span class="hs-identifier hs-var hs-var hs-var">rowsForAlt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((Int, [NPat]) -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)]))
-&gt; [(Int, [NPat])] -&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(Int, [NPat]) -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)])
</span><a href="#local-6989586621680032381"><span class="hs-identifier hs-var">transformMatched</span></a></span><span> </span><span class="annot"><span class="annottext">[(Int, [NPat])]
</span><a href="#local-6989586621680032380"><span class="hs-identifier hs-var">matched</span></a></span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">((Int, NPat, [NPat])
 -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)]))
-&gt; [(Int, NPat, [NPat])]
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(Int, NPat, [NPat]) -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)])
</span><a href="#local-6989586621680032386"><span class="hs-identifier hs-var">transformDefault</span></a></span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680032315"><span class="hs-identifier hs-var">defs</span></a></span><span>
</span><span id="line-257"></span><span>                                </span><span id="local-6989586621680032394"><span class="annot"><a href="#local-6989586621680032394"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-258"></span><span>                                    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032393"><span class="hs-identifier hs-var">rowsForAlt</span></a></span><span>
</span><span id="line-259"></span><span>                                        </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Literal -&gt; CoreExpr
forall b. Literal -&gt; Expr b
</span><a href="Elara.Core.html#Lit"><span class="hs-identifier hs-var">Core.Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-260"></span><span>                                        </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-261"></span><span>                                            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032395"><span class="annot"><span class="annottext">newPats :: Matrix NPat
</span><a href="#local-6989586621680032395"><span class="hs-identifier hs-var hs-var">newPats</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[NPat]] -&gt; Matrix NPat
forall a. [[a]] -&gt; Matrix a
</span><span class="hs-identifier hs-var">Mat.fromLists</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)]) -&gt; [NPat])
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; [[NPat]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680032396"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032396"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032396"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032393"><span class="hs-identifier hs-var">rowsForAlt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-262"></span><span>                                                </span><span id="local-6989586621680032397"><span class="annot"><span class="annottext">newRhs :: [CoreExpr]
</span><a href="#local-6989586621680032397"><span class="hs-identifier hs-var hs-var">newRhs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)]) -&gt; CoreExpr)
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; [CoreExpr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032398"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032398"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032398"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032393"><span class="hs-identifier hs-var">rowsForAlt</span></a></span><span>
</span><span id="line-263"></span><span>                                                </span><span id="local-6989586621680032399"><span class="annot"><span class="annottext">newBs :: [[(Unique VarName, Var)]]
</span><a href="#local-6989586621680032399"><span class="hs-identifier hs-var hs-var">newBs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)])
 -&gt; [(Unique VarName, Var)])
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
-&gt; [[(Unique VarName, Var)]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032400"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032400"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032400"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032393"><span class="hs-identifier hs-var">rowsForAlt</span></a></span><span>
</span><span id="line-264"></span><span>                                            </span><span class="annot"><span class="annottext">ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-var">compileMatrix</span></a></span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680032283"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680032284"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680032290"><span class="hs-identifier hs-var">restScruts</span></a></span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span class="hs-special">{</span><span class="annot"><span class="annottext">pmPats :: Matrix NPat
</span><a href="Elara.ToCore.Match.html#pmPats"><span class="hs-identifier hs-var">pmPats</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Matrix NPat
</span><a href="#local-6989586621680032395"><span class="hs-identifier hs-var">newPats</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmRhs :: [CoreExpr]
</span><a href="Elara.ToCore.Match.html#pmRhs"><span class="hs-identifier hs-var">pmRhs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[CoreExpr]
</span><a href="#local-6989586621680032397"><span class="hs-identifier hs-var">newRhs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmBinds :: [[(Unique VarName, Var)]]
</span><a href="Elara.ToCore.Match.html#pmBinds"><span class="hs-identifier hs-var">pmBinds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[(Unique VarName, Var)]]
</span><a href="#local-6989586621680032399"><span class="hs-identifier hs-var">newBs</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-265"></span><span>                                </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#LitAlt"><span class="hs-identifier hs-type">Core.LitAlt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032379"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621680032394"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-266"></span><span>                            </span><span id="local-6989586621680032402"><span class="annot"><a href="#local-6989586621680032402"><span class="hs-identifier hs-var">defAlt</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#compileDefault"><span class="hs-identifier hs-type">compileDefault</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032283"><span class="hs-identifier hs-type">resolveCon</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032284"><span class="hs-identifier hs-type">fresh</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032289"><span class="hs-identifier hs-type">s0</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032290"><span class="hs-identifier hs-type">restScruts</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032286"><span class="hs-identifier hs-type">pm</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032315"><span class="hs-identifier hs-type">defs</span></a></span><span>
</span><span id="line-267"></span><span>                            </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="Elara.Core.html#Match"><span class="hs-identifier hs-type">Core.Match</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680032289"><span class="hs-identifier hs-type">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><a href="#local-6989586621680032289"><span class="hs-identifier hs-type">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680032378"><span class="hs-identifier hs-type">litAlts</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">++</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">maybeToList</span></span><span> </span><span class="annot"><a href="#local-6989586621680032402"><span class="hs-identifier hs-type">defAlt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-268"></span><span>                        </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-269"></span><span>                            </span><span class="hs-comment">-- Only defaults (wild/var). Drop head and continue.</span><span>
</span><span id="line-270"></span><span>                            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032403"><span class="annot"><span class="annottext">transformDefault :: (Int, NPat, [NPat]) -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)])
</span><a href="#local-6989586621680032403"><span class="hs-identifier hs-var hs-var">transformDefault</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680032404"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032404"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032405"><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032405"><span class="hs-identifier hs-var">headPat</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032406"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032406"><span class="hs-identifier hs-var">tailPs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-271"></span><span>                                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032407"><span class="annot"><span class="annottext">rhsRow :: CoreExpr
</span><a href="#local-6989586621680032407"><span class="hs-identifier hs-var hs-var">rhsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [CoreExpr] -&gt; CoreExpr
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032404"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span>
</span><span id="line-272"></span><span>                                        </span><span id="local-6989586621680032408"><span class="annot"><span class="annottext">bindsRow :: [(Unique VarName, Var)]
</span><a href="#local-6989586621680032408"><span class="hs-identifier hs-var hs-var">bindsRow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032405"><span class="hs-identifier hs-var">headPat</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-273"></span><span>                                            </span><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-type">PVar</span></a></span><span> </span><span id="local-6989586621680032409"><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680032409"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680032409"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680032289"><span class="hs-identifier hs-var">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Unique VarName, Var)
-&gt; [(Unique VarName, Var)] -&gt; [(Unique VarName, Var)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032404"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-274"></span><span>                                            </span><span class="annot"><span class="annottext">NPat
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032404"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032286"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-275"></span><span>                                     </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032406"><span class="hs-identifier hs-var">tailPs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032407"><span class="hs-identifier hs-var">rhsRow</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032408"><span class="hs-identifier hs-var">bindsRow</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-276"></span><span>                                </span><span id="local-6989586621680032410"><span class="annot"><span class="annottext">rowsOnlyDef :: [([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032410"><span class="hs-identifier hs-var hs-var">rowsOnlyDef</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((Int, NPat, [NPat])
 -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)]))
-&gt; [(Int, NPat, [NPat])]
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(Int, NPat, [NPat]) -&gt; ([NPat], CoreExpr, [(Unique VarName, Var)])
</span><a href="#local-6989586621680032403"><span class="hs-identifier hs-var">transformDefault</span></a></span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680032315"><span class="hs-identifier hs-var">defs</span></a></span><span>
</span><span id="line-277"></span><span>                            </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032410"><span class="hs-identifier hs-var">rowsOnlyDef</span></a></span><span>
</span><span id="line-278"></span><span>                                </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Literal -&gt; CoreExpr
forall b. Literal -&gt; Expr b
</span><a href="Elara.Core.html#Lit"><span class="hs-identifier hs-var">Core.Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-279"></span><span>                                </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-280"></span><span>                                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032411"><span class="annot"><span class="annottext">newPats :: Matrix NPat
</span><a href="#local-6989586621680032411"><span class="hs-identifier hs-var hs-var">newPats</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[NPat]] -&gt; Matrix NPat
forall a. [[a]] -&gt; Matrix a
</span><span class="hs-identifier hs-var">Mat.fromLists</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)]) -&gt; [NPat])
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; [[NPat]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680032412"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032412"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032412"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032410"><span class="hs-identifier hs-var">rowsOnlyDef</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-281"></span><span>                                        </span><span id="local-6989586621680032413"><span class="annot"><span class="annottext">newRhs :: [CoreExpr]
</span><a href="#local-6989586621680032413"><span class="hs-identifier hs-var hs-var">newRhs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)]) -&gt; CoreExpr)
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; [CoreExpr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032414"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032414"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032414"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032410"><span class="hs-identifier hs-var">rowsOnlyDef</span></a></span><span>
</span><span id="line-282"></span><span>                                        </span><span id="local-6989586621680032415"><span class="annot"><span class="annottext">newBs :: [[(Unique VarName, Var)]]
</span><a href="#local-6989586621680032415"><span class="hs-identifier hs-var hs-var">newBs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)])
 -&gt; [(Unique VarName, Var)])
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
-&gt; [[(Unique VarName, Var)]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032416"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032416"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032416"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032410"><span class="hs-identifier hs-var">rowsOnlyDef</span></a></span><span>
</span><span id="line-283"></span><span>                                    </span><span class="annot"><span class="annottext">ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-var">compileMatrix</span></a></span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680032283"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680032284"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680032290"><span class="hs-identifier hs-var">restScruts</span></a></span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span class="hs-special">{</span><span class="annot"><span class="annottext">pmPats :: Matrix NPat
</span><a href="Elara.ToCore.Match.html#pmPats"><span class="hs-identifier hs-var">pmPats</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Matrix NPat
</span><a href="#local-6989586621680032411"><span class="hs-identifier hs-var">newPats</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmRhs :: [CoreExpr]
</span><a href="Elara.ToCore.Match.html#pmRhs"><span class="hs-identifier hs-var">pmRhs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[CoreExpr]
</span><a href="#local-6989586621680032413"><span class="hs-identifier hs-var">newRhs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmBinds :: [[(Unique VarName, Var)]]
</span><a href="Elara.ToCore.Match.html#pmBinds"><span class="hs-identifier hs-var">pmBinds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[(Unique VarName, Var)]]
</span><a href="#local-6989586621680032415"><span class="hs-identifier hs-var">newBs</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-284"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-285"></span><span>    </span><span class="hs-comment">-- Bind immediate constructor-argument PVars to the provided xs.</span><span>
</span><span id="line-286"></span><span>    </span><span class="annot"><a href="#local-6989586621680032348"><span class="hs-identifier hs-type">bindImmediate</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier hs-type">Unique</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier hs-type">VarName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-287"></span><span>    </span><span id="local-6989586621680032348"><span class="annot"><span class="annottext">bindImmediate :: [Var] -&gt; [NPat] -&gt; ([NPat], [(Unique VarName, Var)])
</span><a href="#local-6989586621680032348"><span class="hs-identifier hs-var hs-var">bindImmediate</span></a></span></span><span> </span><span id="local-6989586621680032417"><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680032417"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621680032418"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032418"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-288"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032419"><span class="annot"><span class="annottext">step :: (b, NPat) -&gt; (NPat, Maybe (Unique VarName, b))
</span><a href="#local-6989586621680032419"><span class="hs-identifier hs-var hs-var">step</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680032420"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621680032420"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032421"><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032421"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032421"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-289"></span><span>                </span><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-type">PVar</span></a></span><span> </span><span id="local-6989586621680032422"><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680032422"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NPat
</span><a href="Elara.ToCore.Match.html#PWild"><span class="hs-identifier hs-var">PWild</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(Unique VarName, b) -&gt; Maybe (Unique VarName, b)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680032422"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621680032420"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-290"></span><span>                </span><span id="local-6989586621680032423"><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032423"><span class="hs-identifier hs-var">other</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032423"><span class="hs-identifier hs-var">other</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Maybe (Unique VarName, b)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-291"></span><span>            </span><span class="hs-special">(</span><span id="local-6989586621680032424"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032424"><span class="hs-identifier hs-var">args'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032425"><span class="annot"><span class="annottext">[Maybe (Unique VarName, Var)]
</span><a href="#local-6989586621680032425"><span class="hs-identifier hs-var">newBinds</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(NPat, Maybe (Unique VarName, Var))]
-&gt; ([NPat], [Maybe (Unique VarName, Var)])
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Var -&gt; NPat -&gt; (NPat, Maybe (Unique VarName, Var)))
-&gt; [Var] -&gt; [NPat] -&gt; [(NPat, Maybe (Unique VarName, Var))]
forall a b c. (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
</span><span class="hs-identifier hs-var">zipWith</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((Var, NPat) -&gt; (NPat, Maybe (Unique VarName, Var)))
-&gt; Var -&gt; NPat -&gt; (NPat, Maybe (Unique VarName, Var))
forall a b c. ((a, b) -&gt; c) -&gt; a -&gt; b -&gt; c
</span><span class="hs-identifier hs-var">curry</span></span><span> </span><span class="annot"><span class="annottext">(Var, NPat) -&gt; (NPat, Maybe (Unique VarName, Var))
forall {b}. (b, NPat) -&gt; (NPat, Maybe (Unique VarName, b))
</span><a href="#local-6989586621680032419"><span class="hs-identifier hs-var">step</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680032417"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032418"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-292"></span><span>         </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032424"><span class="hs-identifier hs-var">args'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Maybe (Unique VarName, Var)] -&gt; [(Unique VarName, Var)]
forall a. [Maybe a] -&gt; [a]
</span><span class="hs-identifier hs-var">catMaybes</span></span><span> </span><span class="annot"><span class="annottext">[Maybe (Unique VarName, Var)]
</span><a href="#local-6989586621680032425"><span class="hs-identifier hs-var">newBinds</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-293"></span><span>
</span><span id="line-294"></span><span class="annot"><span class="hs-comment">{- | Build a DEFAULT alternative when default rows exist.
 'defs' contains triples of (rowIndex, headPat, tailPatterns)
-}</span></span><span>
</span><span id="line-297"></span><span id="local-6989586621680031857"><span class="annot"><a href="Elara.ToCore.Match.html#compileDefault"><span class="hs-identifier hs-type">compileDefault</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-298"></span><span>    </span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier hs-type">StructuredDebug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680031857"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-299"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#ConResolver"><span class="hs-identifier hs-type">ConResolver</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680031857"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-300"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#FreshLocal"><span class="hs-identifier hs-type">FreshLocal</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680031857"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-301"></span><span>    </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-302"></span><span>    </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-303"></span><span>    </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-304"></span><span>    </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.ToCore.Match.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-305"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680031857"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Core.html#CoreAlt"><span class="hs-identifier hs-type">Core.CoreAlt</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-306"></span><span id="compileDefault"><span class="annot"><span class="annottext">compileDefault :: forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; Var
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; [(Int, NPat, [NPat])]
-&gt; Eff r (Maybe (AltCon, [Var], CoreExpr))
</span><a href="Elara.ToCore.Match.html#compileDefault"><span class="hs-identifier hs-var hs-var">compileDefault</span></a></span></span><span> </span><span id="local-6989586621680032442"><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680032442"><span class="hs-identifier hs-var">resolveCon</span></a></span></span><span> </span><span id="local-6989586621680032443"><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680032443"><span class="hs-identifier hs-var">fresh</span></a></span></span><span> </span><span id="local-6989586621680032444"><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680032444"><span class="hs-identifier hs-var">s0</span></a></span></span><span> </span><span id="local-6989586621680032445"><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680032445"><span class="hs-identifier hs-var">restScruts</span></a></span></span><span> </span><span id="local-6989586621680032446"><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032446"><span class="hs-identifier hs-var">pm</span></a></span></span><span> </span><span id="local-6989586621680032447"><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680032447"><span class="hs-identifier hs-var">defs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-307"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680032447"><span class="hs-identifier hs-var">defs</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-308"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (AltCon, [Var], CoreExpr)
-&gt; Eff r (Maybe (AltCon, [Var], CoreExpr))
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe (AltCon, [Var], CoreExpr)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-309"></span><span>        </span><span id="local-6989586621680032448"><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680032448"><span class="hs-identifier hs-var">ds</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-310"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032449"><span class="annot"><span class="annottext">rows' :: [([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032449"><span class="hs-identifier hs-var hs-var hs-var">rows'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-311"></span><span>                    </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032450"><span class="hs-identifier hs-var">tailPs</span></a></span><span>
</span><span id="line-312"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [CoreExpr] -&gt; CoreExpr
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032451"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032446"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmRhs</span><span>
</span><span id="line-313"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032452"><span class="hs-identifier hs-var">headPat</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-314"></span><span>                            </span><span class="annot"><a href="Elara.ToCore.Match.html#PVar"><span class="hs-identifier hs-type">PVar</span></a></span><span> </span><span id="local-6989586621680032453"><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680032453"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680032453"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680032444"><span class="hs-identifier hs-var">s0</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Unique VarName, Var)
-&gt; [(Unique VarName, Var)] -&gt; [(Unique VarName, Var)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032451"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032446"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-315"></span><span>                            </span><span class="annot"><span class="annottext">NPat
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [[(Unique VarName, Var)]] -&gt; [(Unique VarName, Var)]
forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var">at1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032451"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">PMatrix CoreExpr
</span><a href="#local-6989586621680032446"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">pmBinds</span><span>
</span><span id="line-316"></span><span>                      </span><span class="hs-special">)</span><span>
</span><span id="line-317"></span><span>                    </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680032451"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032451"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032452"><span class="annot"><span class="annottext">NPat
</span><a href="#local-6989586621680032452"><span class="hs-identifier hs-var">headPat</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032450"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032450"><span class="hs-identifier hs-var">tailPs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Int, NPat, [NPat])]
</span><a href="#local-6989586621680032448"><span class="hs-identifier hs-var">ds</span></a></span><span>
</span><span id="line-318"></span><span>                    </span><span class="hs-special">]</span><span>
</span><span id="line-319"></span><span>                </span><span id="local-6989586621680032454"><span class="annot"><span class="annottext">newPats :: Matrix NPat
</span><a href="#local-6989586621680032454"><span class="hs-identifier hs-var hs-var hs-var">newPats</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[NPat]] -&gt; Matrix NPat
forall a. [[a]] -&gt; Matrix a
</span><span class="hs-identifier hs-var">Mat.fromLists</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)]) -&gt; [NPat])
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; [[NPat]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621680032455"><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032455"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[NPat]
</span><a href="#local-6989586621680032455"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032449"><span class="hs-identifier hs-var">rows'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-320"></span><span>                </span><span id="local-6989586621680032456"><span class="annot"><span class="annottext">newRhs :: [CoreExpr]
</span><a href="#local-6989586621680032456"><span class="hs-identifier hs-var hs-var hs-var">newRhs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)]) -&gt; CoreExpr)
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])] -&gt; [CoreExpr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032457"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032457"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032457"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032449"><span class="hs-identifier hs-var">rows'</span></a></span><span>
</span><span id="line-321"></span><span>                </span><span id="local-6989586621680032458"><span class="annot"><span class="annottext">newBs :: [[(Unique VarName, Var)]]
</span><a href="#local-6989586621680032458"><span class="hs-identifier hs-var hs-var hs-var">newBs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(([NPat], CoreExpr, [(Unique VarName, Var)])
 -&gt; [(Unique VarName, Var)])
-&gt; [([NPat], CoreExpr, [(Unique VarName, Var)])]
-&gt; [[(Unique VarName, Var)]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[NPat]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032459"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032459"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032459"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([NPat], CoreExpr, [(Unique VarName, Var)])]
</span><a href="#local-6989586621680032449"><span class="hs-identifier hs-var">rows'</span></a></span><span>
</span><span id="line-322"></span><span>            </span><span id="local-6989586621680032460"><span class="annot"><a href="#local-6989586621680032460"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-323"></span><span>                </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Matrix NPat -&gt; Int
forall a. Matrix a -&gt; Int
</span><span class="hs-identifier hs-var">Mat.nrows</span></span><span> </span><span class="annot"><span class="annottext">Matrix NPat
</span><a href="#local-6989586621680032454"><span class="hs-identifier hs-var">newPats</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-324"></span><span>                    </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">CoreExpr -&gt; Eff r CoreExpr
forall a. a -&gt; Eff r a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Literal -&gt; CoreExpr
forall b. Literal -&gt; Expr b
</span><a href="Elara.Core.html#Lit"><span class="hs-identifier hs-var">Core.Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="Elara.Core.html#Unit"><span class="hs-identifier hs-var">Core.Unit</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-325"></span><span>                    </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
forall (r :: [Effect]).
(StructuredDebug :&gt; r) =&gt;
ConResolver (Eff r)
-&gt; FreshLocal (Eff r)
-&gt; [Var]
-&gt; PMatrix CoreExpr
-&gt; Eff r CoreExpr
</span><a href="Elara.ToCore.Match.html#compileMatrix"><span class="hs-identifier hs-var">compileMatrix</span></a></span><span> </span><span class="annot"><span class="annottext">ConResolver (Eff r)
</span><a href="#local-6989586621680032442"><span class="hs-identifier hs-var">resolveCon</span></a></span><span> </span><span class="annot"><span class="annottext">FreshLocal (Eff r)
</span><a href="#local-6989586621680032443"><span class="hs-identifier hs-var">fresh</span></a></span><span> </span><span class="annot"><span class="annottext">[Var]
</span><a href="#local-6989586621680032445"><span class="hs-identifier hs-var">restScruts</span></a></span><span> </span><span class="annot"><a href="Elara.ToCore.Match.html#PMatrix"><span class="hs-identifier hs-type">PMatrix</span></a></span><span class="hs-special">{</span><span class="annot"><span class="annottext">pmPats :: Matrix NPat
</span><a href="Elara.ToCore.Match.html#pmPats"><span class="hs-identifier hs-var">pmPats</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Matrix NPat
</span><a href="#local-6989586621680032454"><span class="hs-identifier hs-var">newPats</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmRhs :: [CoreExpr]
</span><a href="Elara.ToCore.Match.html#pmRhs"><span class="hs-identifier hs-var">pmRhs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[CoreExpr]
</span><a href="#local-6989586621680032456"><span class="hs-identifier hs-var">newRhs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pmBinds :: [[(Unique VarName, Var)]]
</span><a href="Elara.ToCore.Match.html#pmBinds"><span class="hs-identifier hs-var">pmBinds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[(Unique VarName, Var)]]
</span><a href="#local-6989586621680032458"><span class="hs-identifier hs-var">newBs</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-326"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#DEFAULT"><span class="hs-identifier hs-type">Core.DEFAULT</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621680032460"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-327"></span><span>
</span><span id="line-328"></span><span class="hs-comment">-- Emit nested non-recursive lets for collected variable bindings.</span><span>
</span><span id="line-329"></span><span class="annot"><a href="Elara.ToCore.Match.html#emitBinds"><span class="hs-identifier hs-type">emitBinds</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier hs-type">Unique</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier hs-type">VarName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Core.html#CoreExpr"><span class="hs-identifier hs-type">Core.CoreExpr</span></a></span><span>
</span><span id="line-330"></span><span id="emitBinds"><span class="annot"><span class="annottext">emitBinds :: [(Unique VarName, Var)] -&gt; CoreExpr -&gt; CoreExpr
</span><a href="Elara.ToCore.Match.html#emitBinds"><span class="hs-identifier hs-var hs-var">emitBinds</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span id="local-6989586621680032467"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032467"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032467"><span class="hs-identifier hs-var">body</span></a></span><span>
</span><span id="line-331"></span><span class="annot"><a href="Elara.ToCore.Match.html#emitBinds"><span class="hs-identifier hs-var">emitBinds</span></a></span><span> </span><span id="local-6989586621680032468"><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032468"><span class="hs-identifier hs-var">bs</span></a></span></span><span> </span><span id="local-6989586621680032469"><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032469"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-332"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span class="annot"><a href="#local-6989586621680032470"><span class="hs-identifier hs-type">mkBinder</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Data.Unique.html#Unique"><span class="hs-identifier hs-type">Unique</span></a></span><span> </span><span class="annot"><a href="Elara.AST.Name.html#VarName"><span class="hs-identifier hs-type">VarName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Elara.Core.html#Var"><span class="hs-identifier hs-type">Core.Var</span></a></span><span>
</span><span id="line-333"></span><span>        </span><span id="local-6989586621680032470"><span class="annot"><span class="annottext">mkBinder :: (Unique VarName, Var) -&gt; Maybe Var
</span><a href="#local-6989586621680032470"><span class="hs-identifier hs-var hs-var">mkBinder</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680032471"><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680032471"><span class="hs-identifier hs-var">u</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032472"><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680032472"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680032472"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-334"></span><span>            </span><span class="annot"><a href="Elara.Core.html#Id"><span class="hs-identifier hs-type">Core.Id</span></a></span><span> </span><span class="annot"><span class="annottext">UnlocatedVarRef Text
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680032474"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621680032474"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe DataCon
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-335"></span><span>                </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680032475"><span class="annot"><span class="annottext">uqText :: Unique Text
</span><a href="#local-6989586621680032475"><span class="hs-identifier hs-var hs-var">uqText</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(VarName -&gt; Text) -&gt; Unique VarName -&gt; Unique Text
forall a b. (a -&gt; b) -&gt; Unique a -&gt; Unique b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">VarName -&gt; Text
forall name. NameLike name =&gt; name -&gt; Text
</span><a href="Elara.AST.Name.html#nameText"><span class="hs-identifier hs-var">nameText</span></a></span><span> </span><span class="annot"><span class="annottext">Unique VarName
</span><a href="#local-6989586621680032471"><span class="hs-identifier hs-var">u</span></a></span><span>
</span><span id="line-336"></span><span>                    </span><span class="annot"><a href="#local-6989586621680032477"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.AST.VarRef.html#UnlocatedVarRef"><span class="hs-identifier hs-type">UnlocatedVarRef</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span>
</span><span id="line-337"></span><span>                    </span><span id="local-6989586621680032477"><span class="annot"><span class="annottext">b :: UnlocatedVarRef Text
</span><a href="#local-6989586621680032477"><span class="hs-identifier hs-var hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VarRefImpl UnlocatedVarRefKind (Unique Text)
-&gt; UnlocatedVarRef Text
forall (c :: VarRefKind) n. VarRefImpl c (Unique n) -&gt; VarRef' c n
</span><a href="Elara.AST.VarRef.html#Local"><span class="hs-identifier hs-var">Local</span></a></span><span> </span><span class="annot"><span class="annottext">Unique Text
VarRefImpl UnlocatedVarRefKind (Unique Text)
</span><a href="#local-6989586621680032475"><span class="hs-identifier hs-var">uqText</span></a></span><span>
</span><span id="line-338"></span><span>                 </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Var -&gt; Maybe Var
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">UnlocatedVarRef Text -&gt; Type -&gt; Maybe DataCon -&gt; Var
</span><a href="Elara.Core.html#Id"><span class="hs-identifier hs-var">Core.Id</span></a></span><span> </span><span class="annot"><span class="annottext">UnlocatedVarRef Text
</span><a href="#local-6989586621680032477"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621680032474"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe DataCon
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-339"></span><span>            </span><span class="annot"><a href="Elara.Core.html#TyVar"><span class="hs-identifier hs-type">Core.TyVar</span></a></span><span> </span><span class="annot"><span class="annottext">TypeVariable
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Var
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-340"></span><span>        </span><span id="local-6989586621680032480"><span class="annot"><span class="annottext">mkLet :: (b, b) -&gt; Expr b -&gt; Expr b
</span><a href="#local-6989586621680032480"><span class="hs-identifier hs-var hs-var">mkLet</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680032481"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621680032481"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032482"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621680032482"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bind b -&gt; Expr b -&gt; Expr b
forall b. Bind b -&gt; Expr b -&gt; Expr b
</span><a href="Elara.Core.html#Let"><span class="hs-identifier hs-var">Core.Let</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(b, Expr b) -&gt; Bind b
forall b (expr :: * -&gt; *). (b, expr b) -&gt; Bind b expr
</span><a href="Elara.Core.Generic.html#NonRecursive"><span class="hs-identifier hs-var">G.NonRecursive</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621680032481"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; Expr b
forall b. b -&gt; Expr b
</span><a href="Elara.Core.html#Var"><span class="hs-identifier hs-var">Core.Var</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621680032482"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-341"></span><span>        </span><span id="local-6989586621680032485"><span class="annot"><span class="annottext">pairs :: [(Var, Var)]
</span><a href="#local-6989586621680032485"><span class="hs-identifier hs-var hs-var">pairs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680032486"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680032487"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621680032488"><span class="annot"><span class="annottext">(Unique VarName, Var)
</span><a href="#local-6989586621680032488"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Unique VarName, Var)]
</span><a href="#local-6989586621680032468"><span class="hs-identifier hs-var">bs</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Unique VarName
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680032487"><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680032487"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Unique VarName, Var)
</span><a href="#local-6989586621680032488"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621680032486"><span class="annot"><span class="annottext">Var
</span><a href="#local-6989586621680032486"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">(Unique VarName, Var) -&gt; Maybe Var
</span><a href="#local-6989586621680032470"><span class="hs-identifier hs-var">mkBinder</span></a></span><span> </span><span class="annot"><span class="annottext">(Unique VarName, Var)
</span><a href="#local-6989586621680032488"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><span id="line-342"></span><span>     </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">((Var, Var) -&gt; CoreExpr -&gt; CoreExpr)
-&gt; CoreExpr -&gt; [(Var, Var)] -&gt; CoreExpr
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">(Var, Var) -&gt; CoreExpr -&gt; CoreExpr
forall {b}. (b, b) -&gt; Expr b -&gt; Expr b
</span><a href="#local-6989586621680032480"><span class="hs-identifier hs-var">mkLet</span></a></span><span> </span><span class="annot"><span class="annottext">CoreExpr
</span><a href="#local-6989586621680032469"><span class="hs-identifier hs-var">body</span></a></span><span> </span><span class="annot"><span class="annottext">[(Var, Var)]
</span><a href="#local-6989586621680032485"><span class="hs-identifier hs-var">pairs</span></a></span><span>
</span><span id="line-343"></span><span>
</span><span id="line-344"></span><span class="hs-comment">-- 1-based indexing helper aligned with Data.Matrix row indices.</span><span>
</span><span id="line-345"></span><span id="local-6989586621680031854"><span class="annot"><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-type">at1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621680031854"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680031854"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-346"></span><span id="at1"><span class="annot"><span class="annottext">at1 :: forall a. Int -&gt; [a] -&gt; a
</span><a href="Elara.ToCore.Match.html#at1"><span class="hs-identifier hs-var hs-var">at1</span></a></span></span><span> </span><span id="local-6989586621680032498"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032498"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621680032499"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621680032499"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [a] -&gt; [a]
forall a. Int -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">drop</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680032498"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621680032499"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-347"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621680032500"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680032500"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680032500"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-348"></span><span>    </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Text -&gt; a
forall a t. (HasCallStack, IsText t) =&gt; t -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;PMatrix row index out of bounds&quot;</span></span><span>
</span><span id="line-349"></span><span>
</span><span id="line-350"></span><span id="coreConstructorTypeArgs"><span class="annot"><span class="annottext">coreConstructorTypeArgs :: Type -&gt; [a]
</span><a href="Elara.ToCore.Match.html#coreConstructorTypeArgs"><span class="hs-identifier hs-var hs-var">coreConstructorTypeArgs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-351"></span><span>    </span><span class="annot"><a href="Elara.Core.html#ConTy"><span class="hs-identifier hs-type">Core.ConTy</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#TyCon"><span class="hs-identifier hs-type">Core.TyCon</span></a></span><span> </span><span id="local-6989586621680032505"><span class="annot"><span class="annottext">Qualified Text
</span><a href="#local-6989586621680032505"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Core.html#TyADT"><span class="hs-identifier hs-type">Core.TyADT</span></a></span><span> </span><span id="local-6989586621680032507"><span class="annot"><span class="annottext">[Qualified Text]
</span><a href="#local-6989586621680032507"><span class="hs-identifier hs-var">adts</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-352"></span><span>    </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-353"></span></pre></body></html>