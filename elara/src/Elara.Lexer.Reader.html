<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Elara.Lexer.Reader.html"><span class="hs-identifier">Elara.Lexer.Reader</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.AST.Region.html"><span class="hs-identifier">Elara.AST.Region</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier">Located</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.AST.Region.html#Located"><span class="hs-identifier">Located</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#SourceRegion"><span class="hs-identifier">SourceRegion</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#line"><span class="hs-identifier">line</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.AST.Region.html#unlocated"><span class="hs-identifier">unlocated</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-4"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Lexer.Lexer.html"><span class="hs-identifier">Elara.Lexer.Lexer</span></a></span><span>
</span><span id="line-5"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html"><span class="hs-identifier">Elara.Lexer.Token</span></a></span><span>
</span><span id="line-6"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html"><span class="hs-identifier">Elara.Lexer.Utils</span></a></span><span>
</span><span id="line-7"></span><span>
</span><span id="line-8"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Text</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Text</span></span><span>
</span><span id="line-9"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Eff</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">inject</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(:&gt;)</span></span><span class="hs-special">)</span><span>
</span><span id="line-10"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful.Error.Static</span></span><span>
</span><span id="line-11"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful.FileSystem</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">FileSystem</span></span><span class="hs-special">)</span><span>
</span><span id="line-12"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Effectful.State.Extra.html"><span class="hs-identifier">Effectful.State.Extra</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier">use'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-13"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Effectful.State.Static.Local</span></span><span>
</span><span id="line-14"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Logging.html"><span class="hs-identifier">Elara.Logging</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier">StructuredDebug</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-15"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Query.html"><span class="hs-identifier">Elara.Query</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Query.html#Query"><span class="hs-identifier">Query</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Query.html#GetFileContents"><span class="hs-identifier">GetFileContents</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-16"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.Query.Effects.html"><span class="hs-identifier">Elara.Query.Effects</span></a></span><span>
</span><span id="line-17"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Elara.ReadFile.html"><span class="hs-identifier">Elara.ReadFile</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.ReadFile.html#FileContents"><span class="hs-identifier">FileContents</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.ReadFile.html#FileContents"><span class="hs-identifier">FileContents</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-18"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Rock.html"><span class="hs-identifier">Rock</span></a></span><span> </span><span class="hs-keyword">qualified</span><span>
</span><span id="line-19"></span><span>
</span><span id="line-20"></span><span class="hs-comment">-- TODO: maybe also define empty Constructor for TokPosition</span><span>
</span><span id="line-21"></span><span class="hs-comment">-- use it when constructing and here compute position and update it and return complete and correct Token</span><span>
</span><span id="line-22"></span><span class="hs-comment">-- TODO2: I may actually not need to store position in the Token at all</span><span>
</span><span id="line-23"></span><span class="hs-comment">-- thanks to monadic parsing I have the state at every moment of parsing --&gt; just need to find out</span><span>
</span><span id="line-24"></span><span class="hs-comment">-- how to use the state for better parse-error messages</span><span>
</span><span id="line-25"></span><span class="annot"><a href="Elara.Lexer.Reader.html#readToken"><span class="hs-identifier hs-type">readToken</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span>
</span><span id="line-26"></span><span id="readToken"><span class="annot"><span class="annottext">readToken :: LexMonad Lexeme
</span><a href="Elara.Lexer.Reader.html#readToken"><span class="hs-identifier hs-var hs-var">readToken</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-27"></span><span>    </span><span id="local-6989586621680063921"><span class="annot"><a href="#local-6989586621680063921"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Eff
  '[State ParseState, Error LexerError, StructuredDebug] ParseState
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
Eff es s
</span><span class="hs-identifier hs-var">get</span></span><span>
</span><span id="line-28"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621680063921"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">^.</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#pendingTokens"><span class="hs-identifier hs-type">pendingTokens</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-29"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621680063925"><span class="annot"><span class="annottext">Lexeme
</span><a href="#local-6989586621680063925"><span class="hs-identifier hs-var">token</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621680063926"><span class="annot"><span class="annottext">[Lexeme]
</span><a href="#local-6989586621680063926"><span class="hs-identifier hs-var">tokens</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-30"></span><span>            </span><span class="annot"><span class="annottext">(ParseState -&gt; ParseState)
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
(s -&gt; s) -&gt; Eff es ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Optic' A_Lens NoIx ParseState [Lexeme]
</span><a href="Elara.Lexer.Utils.html#pendingTokens"><span class="hs-identifier hs-var">pendingTokens</span></a></span><span> </span><span class="annot"><span class="annottext">Optic' A_Lens NoIx ParseState [Lexeme]
-&gt; [Lexeme] -&gt; ParseState -&gt; ParseState
forall k (is :: IxList) s t a b.
Is k A_Setter =&gt;
Optic k is s t a b -&gt; b -&gt; s -&gt; t
</span><span class="hs-operator hs-var">.~</span></span><span> </span><span class="annot"><span class="annottext">[Lexeme]
</span><a href="#local-6989586621680063926"><span class="hs-identifier hs-var">tokens</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-31"></span><span>            </span><span class="annot"><span class="annottext">Lexeme -&gt; LexMonad Lexeme
forall a.
a -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Lexeme
</span><a href="#local-6989586621680063925"><span class="hs-identifier hs-var">token</span></a></span><span>
</span><span id="line-32"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-33"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">AlexInput -&gt; Int -&gt; AlexReturn LexAction
</span><a href="Elara.Lexer.Lexer.html#alexScan"><span class="hs-identifier hs-var">alexScan</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680063921"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">ParseState -&gt; Optic' A_Lens NoIx ParseState AlexInput -&gt; AlexInput
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Optic' A_Lens NoIx ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680063921"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">ParseState -&gt; Optic' A_Lens NoIx ParseState Int -&gt; Int
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Optic' A_Lens NoIx ParseState Int
</span><a href="Elara.Lexer.Utils.html#lexSC"><span class="hs-identifier hs-var">lexSC</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-34"></span><span>                </span><span class="annot"><span class="annottext">AlexReturn LexAction
</span><a href="Elara.Lexer.Lexer.html#AlexEOF"><span class="hs-identifier hs-var">AlexEOF</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-35"></span><span>                    </span><span class="annot"><span class="annottext">Bool
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] ()
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] ()
forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">when</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680063921"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">ParseState -&gt; Optic' A_Lens NoIx ParseState Int -&gt; Int
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Optic' A_Lens NoIx ParseState Int
</span><a href="Elara.Lexer.Utils.html#lexSC"><span class="hs-identifier hs-var">lexSC</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="Elara.Lexer.Lexer.html#stringSC"><span class="hs-identifier hs-var">stringSC</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LexerError
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] ()
forall e (es :: [(* -&gt; *) -&gt; * -&gt; *]) a.
(HasCallStack, Error e :&gt; es, Show e) =&gt;
e -&gt; Eff es a
</span><span class="hs-identifier hs-var">throwError</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParseState -&gt; LexerError
</span><a href="Elara.Lexer.Utils.html#UnterminatedStringLiteral"><span class="hs-identifier hs-var">UnterminatedStringLiteral</span></a></span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680063921"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-36"></span><span>                    </span><span id="local-6989586621680063937"><span class="annot"><a href="#local-6989586621680063937"><span class="hs-identifier hs-var">closeIndents</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">LexMonad [Lexeme]
</span><a href="Elara.Lexer.Utils.html#cleanIndentation"><span class="hs-identifier hs-var">cleanIndentation</span></a></span><span>
</span><span id="line-37"></span><span>                    </span><span id="local-6989586621680063939"><span class="annot"><a href="#local-6989586621680063939"><span class="hs-identifier hs-var">pos</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Effectful.State.Extra.html#use%27"><span class="hs-identifier hs-type">use'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-type">input</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">%</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-type">position</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-38"></span><span>                    </span><span id="local-6989586621680063942"><span class="annot"><a href="#local-6989586621680063942"><span class="hs-identifier hs-var">region</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#createRegion"><span class="hs-identifier hs-type">createRegion</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680063939"><span class="hs-identifier hs-type">pos</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680063939"><span class="hs-identifier hs-type">pos</span></a></span><span>
</span><span id="line-39"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680063944"><span class="annot"><a href="#local-6989586621680063944"><span class="hs-identifier hs-var hs-var">eofToken</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SourceRegion -&gt; Token -&gt; Lexeme
forall a. SourceRegion -&gt; a -&gt; Located a
</span><a href="Elara.AST.Region.html#Located"><span class="hs-identifier hs-var">Located</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">RealSourceRegion -&gt; SourceRegion
</span><a href="Elara.AST.Region.html#RealSourceRegion"><span class="hs-identifier hs-var">RealSourceRegion</span></a></span><span> </span><span class="annot"><span class="annottext">RealSourceRegion
</span><a href="#local-6989586621680063942"><span class="hs-identifier hs-var">region</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="Elara.Lexer.Token.html#TokenEOF"><span class="hs-identifier hs-var">TokenEOF</span></a></span><span>
</span><span id="line-40"></span><span>                    </span><span class="annot"><span class="hs-identifier hs-type">modify</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">over</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#pendingTokens"><span class="hs-identifier hs-type">pendingTokens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-operator">&lt;&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">closeIndents</span></span><span> </span><span class="annot"><span class="hs-operator">&lt;&gt;</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier">eofToken</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-41"></span><span>                    </span><span class="annot"><a href="Elara.Lexer.Reader.html#readToken"><span class="hs-identifier hs-type">readToken</span></a></span><span>
</span><span id="line-42"></span><span>                </span><span class="annot"><a href="Elara.Lexer.Lexer.html#AlexError"><span class="hs-identifier hs-type">AlexError</span></a></span><span> </span><span id="local-6989586621680063949"><span class="annot"><span class="annottext">AlexInput
</span><a href="#local-6989586621680063949"><span class="hs-identifier hs-var">token</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Text -&gt; LexMonad Lexeme
forall a t. (HasCallStack, IsText t) =&gt; t -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">(Text -&gt; LexMonad Lexeme) -&gt; Text -&gt; LexMonad Lexeme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-string">&quot;Lexical error on line &quot;</span></span><span> </span><span class="annot"><span class="annottext">Text -&gt; Text -&gt; Text
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Text
forall b a. (Show a, IsString b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">AlexInput
</span><a href="#local-6989586621680063949"><span class="hs-identifier hs-var">token</span></a></span><span> </span><span class="annot"><span class="annottext">AlexInput -&gt; Optic' A_Lens NoIx AlexInput Int -&gt; Int
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Optic A_Lens NoIx AlexInput AlexInput RealPosition RealPosition
</span><a href="Elara.Lexer.Utils.html#position"><span class="hs-identifier hs-var">position</span></a></span><span> </span><span class="annot"><span class="annottext">Optic A_Lens NoIx AlexInput AlexInput RealPosition RealPosition
-&gt; Optic A_Lens NoIx RealPosition RealPosition Int Int
-&gt; Optic' A_Lens NoIx AlexInput Int
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Optic A_Lens NoIx RealPosition RealPosition Int Int
</span><a href="Elara.AST.Region.html#line"><span class="hs-identifier hs-var">line</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-43"></span><span>                </span><span class="annot"><a href="Elara.Lexer.Lexer.html#AlexSkip"><span class="hs-identifier hs-type">AlexSkip</span></a></span><span> </span><span id="local-6989586621680063953"><span class="annot"><span class="annottext">AlexInput
</span><a href="#local-6989586621680063953"><span class="hs-identifier hs-var">inp</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-44"></span><span>                    </span><span class="annot"><span class="annottext">ParseState
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
s -&gt; Eff es ()
</span><span class="hs-identifier hs-var">put</span></span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680063921"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.Lexer.Utils.html#_input"><span class="hs-identifier hs-var">_input</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680063953"><span class="hs-identifier hs-type">inp</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-45"></span><span>                    </span><span class="annot"><span class="annottext">LexMonad Lexeme
</span><a href="Elara.Lexer.Reader.html#readToken"><span class="hs-identifier hs-var">readToken</span></a></span><span>
</span><span id="line-46"></span><span>                </span><span class="annot"><a href="Elara.Lexer.Lexer.html#AlexToken"><span class="hs-identifier hs-type">AlexToken</span></a></span><span> </span><span id="local-6989586621680063957"><span class="annot"><span class="annottext">AlexInput
</span><a href="#local-6989586621680063957"><span class="hs-identifier hs-var">inp</span></a></span></span><span> </span><span id="local-6989586621680063958"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680063958"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621680063959"><span class="annot"><span class="annottext">LexAction
</span><a href="#local-6989586621680063959"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-47"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680063960"><span class="annot"><span class="annottext">buf :: Text
</span><a href="#local-6989586621680063960"><span class="hs-identifier hs-var hs-var hs-var">buf</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680063921"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">ParseState -&gt; Optic' A_Lens NoIx ParseState Text -&gt; Text
forall k s (is :: IxList) a.
Is k A_Getter =&gt;
s -&gt; Optic' k is s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span> </span><span class="annot"><span class="annottext">Optic' A_Lens NoIx ParseState AlexInput
</span><a href="Elara.Lexer.Utils.html#input"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">Optic' A_Lens NoIx ParseState AlexInput
-&gt; Optic A_Lens NoIx AlexInput AlexInput Text Text
-&gt; Optic' A_Lens NoIx ParseState Text
forall k l m (is :: IxList) (js :: IxList) (ks :: IxList) s t u v a
       b.
(JoinKinds k l m, AppendIndices is js ks) =&gt;
Optic k is s t u v -&gt; Optic l js u v a b -&gt; Optic m ks s t a b
</span><span class="hs-operator hs-var">%</span></span><span> </span><span class="annot"><span class="annottext">Optic A_Lens NoIx AlexInput AlexInput Text Text
</span><a href="Elara.Lexer.Utils.html#rest"><span class="hs-identifier hs-var">rest</span></a></span><span>
</span><span id="line-48"></span><span>                    </span><span class="annot"><span class="annottext">ParseState
-&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] ()
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(HasCallStack, State s :&gt; es) =&gt;
s -&gt; Eff es ()
</span><span class="hs-identifier hs-var">put</span></span><span> </span><span class="annot"><span class="annottext">ParseState
</span><a href="#local-6989586621680063921"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">{</span><span class="annot"><a href="Elara.Lexer.Utils.html#_input"><span class="hs-identifier hs-var">_input</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621680063957"><span class="hs-identifier hs-type">inp</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-49"></span><span>                    </span><span id="local-6989586621680063962"><span class="annot"><a href="#local-6989586621680063962"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">LexAction
</span><a href="#local-6989586621680063959"><span class="hs-identifier hs-var">act</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680063958"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Text -&gt; Text
</span><span class="hs-identifier hs-var">Text.take</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621680063958"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680063960"><span class="hs-identifier hs-var">buf</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-50"></span><span>                    </span><span class="annot"><span class="hs-identifier hs-type">maybe</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Reader.html#readToken"><span class="hs-identifier hs-type">readToken</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><a href="#local-6989586621680063962"><span class="hs-identifier hs-type">res</span></a></span><span>
</span><span id="line-51"></span><span>
</span><span id="line-52"></span><span class="annot"><a href="Elara.Lexer.Reader.html#readTokens"><span class="hs-identifier hs-type">readTokens</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-53"></span><span id="readTokens"><span class="annot"><span class="annottext">readTokens :: LexMonad [Lexeme]
</span><a href="Elara.Lexer.Reader.html#readTokens"><span class="hs-identifier hs-var hs-var">readTokens</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-54"></span><span>    </span><span id="local-6989586621680063971"><span class="annot"><a href="#local-6989586621680063971"><span class="hs-identifier hs-var">tok</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">LexMonad Lexeme
</span><a href="Elara.Lexer.Reader.html#readToken"><span class="hs-identifier hs-var">readToken</span></a></span><span>
</span><span id="line-55"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621680063971"><span class="hs-identifier hs-type">tok</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">^.</span></span><span> </span><span class="annot"><a href="Elara.AST.Region.html#unlocated"><span class="hs-identifier hs-type">unlocated</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-56"></span><span>        </span><span class="annot"><span class="annottext">Token
</span><a href="Elara.Lexer.Token.html#TokenEOF"><span class="hs-identifier hs-var">TokenEOF</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Lexeme] -&gt; LexMonad [Lexeme]
forall a.
a -&gt; Eff '[State ParseState, Error LexerError, StructuredDebug] a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-57"></span><span>        </span><span class="annot"><span class="annottext">Token
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-58"></span><span>            </span><span id="local-6989586621680063972"><span class="annot"><a href="#local-6989586621680063972"><span class="hs-identifier hs-var">next</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">LexMonad [Lexeme]
</span><a href="Elara.Lexer.Reader.html#readTokens"><span class="hs-identifier hs-var">readTokens</span></a></span><span>
</span><span id="line-59"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680063971"><span class="hs-identifier hs-type">tok</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><a href="#local-6989586621680063972"><span class="hs-identifier hs-type">next</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-60"></span><span>
</span><span id="line-61"></span><span id="local-6989586621680063795"><span class="annot"><a href="Elara.Lexer.Reader.html#readTokensWith"><span class="hs-identifier hs-type">readTokensWith</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-62"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Error</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexerError"><span class="hs-identifier hs-type">LexerError</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680063795"><span class="hs-identifier hs-type">es</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Elara.Logging.html#StructuredDebug"><span class="hs-identifier hs-type">StructuredDebug</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621680063795"><span class="hs-identifier hs-type">es</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-63"></span><span>    </span><span class="annot"><a href="Elara.ReadFile.html#FileContents"><span class="hs-identifier hs-type">FileContents</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="annot"><a href="#local-6989586621680063795"><span class="hs-identifier hs-type">es</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-64"></span><span id="readTokensWith"><span class="annot"><span class="annottext">readTokensWith :: forall (es :: [(* -&gt; *) -&gt; * -&gt; *]).
(Error LexerError :&gt; es, StructuredDebug :&gt; es) =&gt;
FileContents -&gt; Eff es [Lexeme]
</span><a href="Elara.Lexer.Reader.html#readTokensWith"><span class="hs-identifier hs-var hs-var">readTokensWith</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.ReadFile.html#FileContents"><span class="hs-identifier hs-type">FileContents</span></a></span><span> </span><span id="local-6989586621680063991"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621680063991"><span class="hs-identifier hs-var">fp</span></a></span></span><span> </span><span id="local-6989586621680063992"><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680063992"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-65"></span><span>    </span><span class="annot"><span class="annottext">ParseState
-&gt; Eff (State ParseState : es) [Lexeme] -&gt; Eff es [Lexeme]
forall s (es :: [(* -&gt; *) -&gt; * -&gt; *]) a.
HasCallStack =&gt;
s -&gt; Eff (State s : es) a -&gt; Eff es a
</span><span class="hs-identifier hs-var">evalState</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; Text -&gt; ParseState
</span><a href="Elara.Lexer.Utils.html#initialState"><span class="hs-identifier hs-var">initialState</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621680063991"><span class="hs-identifier hs-var">fp</span></a></span><span> </span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621680063992"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LexMonad [Lexeme] -&gt; Eff (State ParseState : es) [Lexeme]
forall (subEs :: [(* -&gt; *) -&gt; * -&gt; *]) (es :: [(* -&gt; *) -&gt; * -&gt; *])
       a.
Subset subEs es =&gt;
Eff subEs a -&gt; Eff es a
</span><span class="hs-identifier hs-var">inject</span></span><span> </span><span class="annot"><span class="annottext">LexMonad [Lexeme]
</span><a href="Elara.Lexer.Reader.html#readTokens"><span class="hs-identifier hs-var">readTokens</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-66"></span><span>
</span><span id="line-67"></span><span class="annot"><a href="Elara.Lexer.Reader.html#getLexedFile"><span class="hs-identifier hs-type">getLexedFile</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eff</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Query.Effects.html#ConsQueryEffects"><span class="hs-identifier hs-type">ConsQueryEffects</span></a></span><span> </span><span class="hs-special">'</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Error</span></span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexerError"><span class="hs-identifier hs-type">LexerError</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Rock.html#Rock"><span class="hs-identifier hs-type">Rock.Rock</span></a></span><span> </span><span class="annot"><a href="Elara.Query.html#Query"><span class="hs-identifier hs-type">Query</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-68"></span><span id="getLexedFile"><span class="annot"><span class="annottext">getLexedFile :: String
-&gt; Eff (ConsQueryEffects '[Error LexerError, Rock Query]) [Lexeme]
</span><a href="Elara.Lexer.Reader.html#getLexedFile"><span class="hs-identifier hs-var hs-var">getLexedFile</span></a></span></span><span> </span><span id="local-6989586621680064056"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621680064056"><span class="hs-identifier hs-var">fp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-69"></span><span>    </span><span id="local-6989586621680064057"><span class="annot"><a href="#local-6989586621680064057"><span class="hs-identifier hs-var">fileContents</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Query
  (Rock Query
     : ConsMinimumQueryEffects
         '[FileSystem, DiagnosticWriter (Doc AnsiStyle)])
  FileContents
-&gt; Eff
     (ConsQueryEffects '[Error LexerError, Rock Query]) FileContents
forall (xs :: [(* -&gt; *) -&gt; * -&gt; *]) (es :: [(* -&gt; *) -&gt; * -&gt; *])
       (f :: [(* -&gt; *) -&gt; * -&gt; *] -&gt; * -&gt; *) a.
(Subset xs es, Rock f :&gt; es, HasCallStack) =&gt;
f xs a -&gt; Eff es a
</span><a href="Rock.html#fetch"><span class="hs-identifier hs-var">Rock.fetch</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
-&gt; Query
     (Rock Query
        : ConsMinimumQueryEffects
            '[FileSystem, DiagnosticWriter (Doc AnsiStyle)])
     FileContents
</span><a href="Elara.Query.html#GetFileContents"><span class="hs-identifier hs-var">GetFileContents</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621680064056"><span class="hs-identifier hs-var">fp</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-70"></span><span>    </span><span class="annot"><a href="Elara.Lexer.Reader.html#readTokensWith"><span class="hs-identifier hs-type">readTokensWith</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680064057"><span class="hs-identifier hs-type">fileContents</span></a></span><span>
</span><span id="line-71"></span><span>
</span><span id="line-72"></span><span id="local-6989586621680063829"><span class="annot"><a href="Elara.Lexer.Reader.html#lexer"><span class="hs-identifier hs-type">lexer</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Elara.Lexer.Token.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680063829"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Elara.Lexer.Utils.html#LexMonad"><span class="hs-identifier hs-type">LexMonad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680063829"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-73"></span><span id="lexer"><span class="annot"><span class="annottext">lexer :: forall a. (Lexeme -&gt; LexMonad a) -&gt; LexMonad a
</span><a href="Elara.Lexer.Reader.html#lexer"><span class="hs-identifier hs-var hs-var">lexer</span></a></span></span><span> </span><span id="local-6989586621680064061"><span class="annot"><span class="annottext">Lexeme -&gt; LexMonad a
</span><a href="#local-6989586621680064061"><span class="hs-identifier hs-var">cont</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-74"></span><span>    </span><span id="local-6989586621680064062"><span class="annot"><a href="#local-6989586621680064062"><span class="hs-identifier hs-var">tok</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">LexMonad Lexeme
</span><a href="Elara.Lexer.Reader.html#readToken"><span class="hs-identifier hs-var">readToken</span></a></span><span>
</span><span id="line-75"></span><span>    </span><span class="annot"><a href="#local-6989586621680064061"><span class="hs-identifier hs-type">cont</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680064062"><span class="hs-identifier hs-type">tok</span></a></span><span>
</span><span id="line-76"></span></pre></body></html>