module Prelude
{ Prelude.charToInt : Char -> Int
    = \ (c_16 : Char) -> case Elara.Prim.== c_16 '0' 
        { Elara.Prim.True : Bool  -> 0; Elara.Prim.False : Bool  -> case Elara.Prim.== c_16 '1' 
            { Elara.Prim.True : Bool  -> 1; Elara.Prim.False : Bool  -> case Elara.Prim.== c_16 '2' 
                { Elara.Prim.True : Bool  -> 2; Elara.Prim.False : Bool  -> case Elara.Prim.== c_16 '3' 
                    { Elara.Prim.True : Bool  -> 3; Elara.Prim.False : Bool  -> case Elara.Prim.== c_16 '4' 
                        { Elara.Prim.True : Bool  -> 4; Elara.Prim.False : Bool  -> case Elara.Prim.== c_16 '5' 
                            { Elara.Prim.True : Bool  -> 5; Elara.Prim.False : Bool  -> case Elara.Prim.== c_16 '6' 
                                { Elara.Prim.True : Bool  -> 6; Elara.Prim.False : Bool  -> case Elara.Prim.== c_16 '7' 
                                    { Elara.Prim.True : Bool  -> 7; Elara.Prim.False : Bool  -> case Elara.Prim.== c_16 '8' 
                                        { Elara.Prim.True : Bool  -> 8; Elara.Prim.False : Bool  -> case Elara.Prim.== c_16 '9' 
                                            { Elara.Prim.True : Bool  -> 9; Elara.Prim.False : Bool  -> -1}}}}}}}}}}
; 
Prelude.filter : forall (a_17 : Type). (a_17 -> Bool) -> [a_17] -> [a_17]
    = \ (f_18 : a_17 -> Bool) (a_19 : [a_17]) -> case a_19 of (a_149 : forall (a_17 : Type). [a_17])
        { Elara.Prim.empty : [([a_17])]  -> Elara.Prim.empty; Elara.Prim.cons : [] (x_20 : a_17) (xs_21 : [a_17]) -> case f_18 x_20 
            { Elara.Prim.True : Bool  -> Elara.Prim.cons x_20 (Prelude.filter f_18 xs_21); Elara.Prim.False : Bool  -> Prelude.filter f_18 xs_21}}
; 
Prelude.head : forall (a_22 : Type). [a_22] -> a_22
    = \ (a_23 : [a_22]) -> case a_23 of (a_150 : forall (a_22 : Type). [a_22])
        { Elara.Prim.empty : [([a_22])]  -> Elara.Prim.undefined @a_22; Elara.Prim.cons : [] (x_24 : a_22) (xs_25 : [a_22]) -> x_24}
; 
Prelude.last : forall (a_26 : Type). [a_26] -> a_26
    = \ (a_27 : [a_26]) -> case a_27 of (a_151 : forall (a_26 : Type). [a_26])
        { Elara.Prim.empty : [([a_26])]  -> Elara.Prim.undefined @a_26; Elara.Prim.cons : [] (x_28 : a_26) (xs_29 : [a_26]) -> case Elara.Prim.== xs_29 Elara.Prim.empty 
            { Elara.Prim.True : Bool  -> x_28; Elara.Prim.False : Bool  -> Prelude.last xs_29}}
; 
Prelude.map : forall (a_30 : Type). forall (b_31 : Type). (a_30 -> b_31) -> [a_30] -> [b_31]
    = \ (f_32 : a_30 -> b_31) (a_33 : [a_30]) -> case a_33 of (a_152 : forall (a_30 : Type). [a_30])
        { Elara.Prim.empty : [([a_30])]  -> Elara.Prim.empty; Elara.Prim.cons : [] (x_34 : a_30) (xs_35 : [a_30]) -> Elara.Prim.cons (f_32 x_34) (Prelude.map f_32 xs_35)}
; 
Prelude.not : Bool -> Bool
    = \ (a_36 : Bool) -> case a_36 
        { Elara.Prim.True : Bool  -> Elara.Prim.False; Elara.Prim.False : Bool  -> Elara.Prim.True}
; 
Prelude.print : forall (a_37 : Type). a_37 -> IO ()
    = \ (a_38 : a_37) -> Elara.Prim.println (Elara.Prim.toString a_38)
; 
Prelude.++ : forall (a_43 : Type). [a_43] -> [a_43] -> [a_43]
    = \ (a_44 : [a_43]) (b_45 : [a_43]) -> case a_44 of (a_153 : forall (a_43 : Type). [a_43])
        { Elara.Prim.empty : [([a_43])]  -> b_45; Elara.Prim.cons : [] (x_46 : a_43) (xs_47 : [a_43]) -> Elara.Prim.cons x_46 (Prelude.++ xs_47 b_45)}
; 
Prelude.reverse : forall (a_39 : Type). [a_39] -> [a_39]
    = \ (a_40 : [a_39]) -> case a_40 of (a_154 : forall (a_39 : Type). [a_39])
        { Elara.Prim.empty : [([a_39])]  -> Elara.Prim.empty; Elara.Prim.cons : [] (x_41 : a_39) (xs_42 : [a_39]) -> Prelude.++ (Prelude.reverse xs_42) (Elara.Prim.cons x_41 Elara.Prim.empty)}
; 
Prelude./= : forall (a_48 : Type). a_48 -> a_48 -> Bool
    = \ (a_49 : a_48) (b_50 : a_48) -> Prelude.not (Elara.Prim.== a_49 b_50) }