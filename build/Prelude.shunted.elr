module Prelude exposing (..)

import Elara.Prim exposing (..)

def Prelude.charToInt : (Elara.Prim.Char -> Elara.Prim.Int)
let Prelude.charToInt =
    (\ c_16 -> ((if ((Elara.Prim.(==)  c_16 )  '0' )  then 0  else (if ((Elara.Prim.(==)  c_16 )  '1' )  then 1  else (if ((Elara.Prim.(==)  c_16 )  '2' )  then 2  else (if ((Elara.Prim.(==)  c_16 )  '3' )  then 3  else (if ((Elara.Prim.(==)  c_16 )  '4' )  then 4  else (if ((Elara.Prim.(==)  c_16 )  '5' )  then 5  else (if ((Elara.Prim.(==)  c_16 )  '6' )  then 6  else (if ((Elara.Prim.(==)  c_16 )  '7' )  then 7  else (if ((Elara.Prim.(==)  c_16 )  '8' )  then 8  else (if ((Elara.Prim.(==)  c_16 )  '9' )  then 9  else -1 ) ) ) ) ) ) ) ) ) ) )) 

def Prelude.filter : ((a_17 -> Elara.Prim.Bool) -> ([ a_17 ] -> [ a_17 ]))
let Prelude.filter =
    (\ f_18 -> ((\ a_19 -> ((match a_19  with { [  ]  -> [  ] ; (x_20  :: xs_21 )  -> (if (f_18  x_20 )  then ((Elara.Prim.cons  x_20 )  ((Prelude.filter  f_18 )  xs_21 ) )  else ((Prelude.filter  f_18 )  xs_21 ) ) }) )) )) 

def Prelude.head : ([ a_22 ] -> a_22)
let Prelude.head =
    (\ a_23 -> ((match a_23  with { [  ]  -> Elara.Prim.undefined ; (x_24  :: xs_25 )  -> x_24 }) )) 

def Prelude.last : ([ a_26 ] -> a_26)
let Prelude.last =
    (\ a_27 -> ((match a_27  with { [  ]  -> Elara.Prim.undefined ; (x_28  :: xs_29 )  -> (if ((Elara.Prim.(==)  xs_29 )  [  ] )  then x_28  else (Prelude.last  xs_29 ) ) }) )) 

def Prelude.map : ((a_30 -> b_31) -> ([ a_30 ] -> [ b_31 ]))
let Prelude.map =
    (\ f_32 -> ((\ a_33 -> ((match a_33  with { [  ]  -> [  ] ; (x_34  :: xs_35 )  -> ((Elara.Prim.cons  (f_32  x_34 ) )  ((Prelude.map  f_32 )  xs_35 ) ) }) )) )) 

def Prelude.not : (Elara.Prim.Bool -> Elara.Prim.Bool)
let Prelude.not =
    (\ a_36 -> ((if a_36  then Elara.Prim.False  else Elara.Prim.True ) )) 

def Prelude.print : (a_37 -> Elara.Prim.IO ())
let Prelude.print =
    (\ a_38 -> ((Elara.Prim.println  (Elara.Prim.toString  a_38 ) ) )) 

def Prelude.reverse : ([ a_39 ] -> [ a_39 ])
let Prelude.reverse =
    (\ a_40 -> ((match a_40  with { [  ]  -> [  ] ; (x_41  :: xs_42 )  -> ((Prelude.(++)  (Prelude.reverse  xs_42 ) )  [ x_41  ] ) }) )) 

def Prelude.(++) : ([ a_43 ] -> ([ a_43 ] -> [ a_43 ]))
let Prelude.(++) =
    (\ a_44 -> ((\ b_45 -> ((match a_44  with { [  ]  -> b_45 ; (x_46  :: xs_47 )  -> ((Elara.Prim.cons  x_46 )  ((Prelude.(++)  xs_47 )  b_45 ) ) }) )) )) 

def Prelude.(/=) : (a_48 -> (a_48 -> Elara.Prim.Bool))
let Prelude.(/=) =
    (\ a_49 -> ((\ b_50 -> ((Prelude.not  ((Elara.Prim.(==)  a_49 )  b_50 ) ) )) )) 
