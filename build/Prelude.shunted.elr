module Prelude exposing (..)

import Elara.Prim exposing (..)

def Prelude.charToInt : (Elara.Prim.Char -> Elara.Prim.Int)
let Prelude.charToInt =
    (\ c_13 -> ((if ((Elara.Prim.(==)  c_13 )  '0' )  then 0  else (if ((Elara.Prim.(==)  c_13 )  '1' )  then 1  else (if ((Elara.Prim.(==)  c_13 )  '2' )  then 2  else (if ((Elara.Prim.(==)  c_13 )  '3' )  then 3  else (if ((Elara.Prim.(==)  c_13 )  '4' )  then 4  else (if ((Elara.Prim.(==)  c_13 )  '5' )  then 5  else (if ((Elara.Prim.(==)  c_13 )  '6' )  then 6  else (if ((Elara.Prim.(==)  c_13 )  '7' )  then 7  else (if ((Elara.Prim.(==)  c_13 )  '8' )  then 8  else (if ((Elara.Prim.(==)  c_13 )  '9' )  then 9  else -1 ) ) ) ) ) ) ) ) ) ) )) 

def Prelude.head : ([ a_14 ] -> a_14)
let Prelude.head =
    (\ a_15 -> ((match a_15  with { [  ]  -> Elara.Prim.undefined ; (x_16  :: xs_17 )  -> x_16 }) )) 

def Prelude.last : ([ a_18 ] -> a_18)
let Prelude.last =
    (\ a_19 -> ((match a_19  with { [  ]  -> Elara.Prim.undefined ; (x_20  :: xs_21 )  -> (if ((Elara.Prim.(==)  xs_21 )  [  ] )  then x_20  else (Prelude.last  xs_21 ) ) }) )) 

def Prelude.map : ((a_22 -> b_23) -> ([ a_22 ] -> [ b_23 ]))
let Prelude.map =
    (\ f_24 -> ((\ a_25 -> ((match a_25  with { [  ]  -> [  ] ; (x_26  :: xs_27 )  -> ((Elara.Prim.cons  (f_24  x_26 ) )  ((Prelude.map  f_24 )  xs_27 ) ) }) )) )) 

def Prelude.print : (a_28 -> Elara.Prim.IO ())
let Prelude.print =
    (\ a_29 -> ((Elara.Prim.println  (Elara.Prim.toString  a_29 ) ) )) 

def Prelude.reverse : ([ a_30 ] -> [ a_30 ])
let Prelude.reverse =
    (\ a_31 -> ((match a_31  with { [  ]  -> [  ] ; (x_32  :: xs_33 )  -> ((Prelude.(++)  (Prelude.reverse  xs_33 ) )  [ x_32  ] ) }) )) 

def Prelude.(++) : ([ a_34 ] -> ([ a_34 ] -> [ a_34 ]))
let Prelude.(++) =
    (\ a_35 -> ((\ b_36 -> ((match a_35  with { [  ]  -> b_36 ; (x_37  :: xs_38 )  -> ((Elara.Prim.cons  x_37 )  ((Prelude.(++)  xs_38 )  b_36 ) ) }) )) )) 
